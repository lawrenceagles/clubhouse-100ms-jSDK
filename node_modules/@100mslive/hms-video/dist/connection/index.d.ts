import { HMSConnectionRole } from './model';
import { ISignal } from '../signal/ISignal';
import { HMSLocalTrack } from '../media/tracks';
import { TrackState } from '../notification-manager';
export default abstract class HMSConnection {
    readonly role: HMSConnectionRole;
    protected readonly signal: ISignal;
    abstract readonly nativeConnection: RTCPeerConnection;
    /**
     * We keep a list of pending IceCandidates received
     * from the signalling server. When the peer-connection
     * is initialized we call [addIceCandidate] for each.
     *
     * WARN:
     *  - [HMSPublishConnection] keeps the complete list of candidates (for
     *      ice-connection failed/disconnect) forever.
     *  - [HMSSubscribeConnection] clears this list as soon as we call [addIceCandidate]
     */
    readonly candidates: RTCIceCandidateInit[];
    protected constructor(role: HMSConnectionRole, signal: ISignal);
    get iceConnectionState(): RTCIceConnectionState;
    get connectionState(): RTCPeerConnectionState;
    private get action();
    addTransceiver(track: MediaStreamTrack, init: RTCRtpTransceiverInit): RTCRtpTransceiver;
    createOffer(options: RTCOfferOptions | undefined, tracks: Map<string, TrackState>): Promise<RTCSessionDescriptionInit>;
    createAnswer(options?: RTCOfferOptions | undefined): Promise<RTCSessionDescriptionInit>;
    setLocalDescription(description: RTCSessionDescriptionInit): Promise<void>;
    setRemoteDescription(description: RTCSessionDescriptionInit): Promise<void>;
    addIceCandidate(candidate: RTCIceCandidateInit): Promise<void>;
    get remoteDescription(): RTCSessionDescription | null;
    getSenders(): Array<RTCRtpSender>;
    removeTrack(sender: RTCRtpSender): void;
    setMaxBitrate(maxBitrate: number, track: HMSLocalTrack): Promise<void>;
    getStats(): Promise<any[]>;
    close(): Promise<void>;
}
