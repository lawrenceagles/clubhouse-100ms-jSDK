'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var adapter = _interopDefault(require('webrtc-adapter'));
var sdpTransform = require('sdp-transform');
var uaParserJs = require('ua-parser-js');
var uuid = require('uuid');
var EventEmitter = require('events');
var EventEmitter__default = _interopDefault(EventEmitter);

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;

  _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it) return (it = it.call(o)).next.bind(it);

  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it) o = it;
    var i = 0;
    return function () {
      if (i >= o.length) return {
        done: true
      };
      return {
        done: false,
        value: o[i++]
      };
    };
  }

  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var runtime_1 = createCommonjsModule(function (module) {
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined$1; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
    return obj[key];
  }
  try {
    // IE 8 has a broken Object.defineProperty that only works on DOM objects.
    define({}, "");
  } catch (err) {
    define = function(obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  define(IteratorPrototype, iteratorSymbol, function () {
    return this;
  });

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = GeneratorFunctionPrototype;
  define(Gp, "constructor", GeneratorFunctionPrototype);
  define(GeneratorFunctionPrototype, "constructor", GeneratorFunction);
  GeneratorFunction.displayName = define(
    GeneratorFunctionPrototype,
    toStringTagSymbol,
    "GeneratorFunction"
  );

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      define(genFun, toStringTagSymbol, "GeneratorFunction");
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
    return this;
  });
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;

    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList),
      PromiseImpl
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined$1) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined$1;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined$1;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  define(Gp, toStringTagSymbol, "Generator");

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  define(Gp, iteratorSymbol, function() {
    return this;
  });

  define(Gp, "toString", function() {
    return "[object Generator]";
  });

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined$1;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined$1, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined$1;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined$1;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined$1;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined$1;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined$1;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
   module.exports 
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, in modern engines
  // we can explicitly access globalThis. In older engines we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  if (typeof globalThis === "object") {
    globalThis.regeneratorRuntime = runtime;
  } else {
    Function("r", "regeneratorRuntime = r")(runtime);
  }
}
});

var HMSConnectionRole;

(function (HMSConnectionRole) {
  HMSConnectionRole[HMSConnectionRole["Publish"] = 0] = "Publish";
  HMSConnectionRole[HMSConnectionRole["Subscribe"] = 1] = "Subscribe";
})(HMSConnectionRole || (HMSConnectionRole = {}));

(function (HMSLogLevel) {
  HMSLogLevel[HMSLogLevel["VERBOSE"] = 0] = "VERBOSE";
  HMSLogLevel[HMSLogLevel["DEBUG"] = 1] = "DEBUG";
  HMSLogLevel[HMSLogLevel["INFO"] = 2] = "INFO";
  HMSLogLevel[HMSLogLevel["WARN"] = 3] = "WARN";
  HMSLogLevel[HMSLogLevel["TIME"] = 4] = "TIME";
  HMSLogLevel[HMSLogLevel["TIMEEND"] = 5] = "TIMEEND";
  HMSLogLevel[HMSLogLevel["ERROR"] = 6] = "ERROR";
  HMSLogLevel[HMSLogLevel["NONE"] = 7] = "NONE";
})(exports.HMSLogLevel || (exports.HMSLogLevel = {}));
/**
 * TODO: fix this so logs show the real file and line numbers where they originated from instead of this class
 * https://stackoverflow.com/questions/13815640/a-proper-wrapper-for-console-log-with-correct-line-number
 */


var HMSLogger = /*#__PURE__*/function () {
  function HMSLogger() {}

  HMSLogger.v = function v(tag) {
    for (var _len = arguments.length, data = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      data[_key - 1] = arguments[_key];
    }

    this.log.apply(this, [exports.HMSLogLevel.VERBOSE, tag].concat(data));
  };

  HMSLogger.d = function d(tag) {
    for (var _len2 = arguments.length, data = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      data[_key2 - 1] = arguments[_key2];
    }

    this.log.apply(this, [exports.HMSLogLevel.DEBUG, tag].concat(data));
  };

  HMSLogger.i = function i(tag) {
    for (var _len3 = arguments.length, data = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
      data[_key3 - 1] = arguments[_key3];
    }

    this.log.apply(this, [exports.HMSLogLevel.INFO, tag].concat(data));
  };

  HMSLogger.w = function w(tag) {
    for (var _len4 = arguments.length, data = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
      data[_key4 - 1] = arguments[_key4];
    }

    this.log.apply(this, [exports.HMSLogLevel.WARN, tag].concat(data));
  };

  HMSLogger.e = function e(tag) {
    for (var _len5 = arguments.length, data = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
      data[_key5 - 1] = arguments[_key5];
    }

    this.log.apply(this, [exports.HMSLogLevel.ERROR, tag].concat(data));
  };

  HMSLogger.time = function time(mark) {
    this.log(exports.HMSLogLevel.TIME, '[HMSPerformanceTiming]', mark);
  };

  HMSLogger.timeEnd = function timeEnd(mark) {
    this.log(exports.HMSLogLevel.TIMEEND, '[HMSPerformanceTiming]', mark, mark);
  };

  HMSLogger.cleanUp = function cleanUp() {
    performance.clearMarks();
    performance.clearMeasures();
  };

  HMSLogger.log = function log(level, tag) {
    if (this.level.valueOf() > level.valueOf()) {
      return;
    }

    for (var _len6 = arguments.length, data = new Array(_len6 > 2 ? _len6 - 2 : 0), _key6 = 2; _key6 < _len6; _key6++) {
      data[_key6 - 2] = arguments[_key6];
    }

    switch (level) {
      case exports.HMSLogLevel.VERBOSE:
        {
          var _console;

          (_console = console).log.apply(_console, [tag].concat(data));

          break;
        }

      case exports.HMSLogLevel.DEBUG:
        {
          var _console2;

          (_console2 = console).debug.apply(_console2, [tag].concat(data));

          break;
        }

      case exports.HMSLogLevel.INFO:
        {
          var _console3;

          (_console3 = console).info.apply(_console3, [tag].concat(data));

          break;
        }

      case exports.HMSLogLevel.WARN:
        {
          var _console4;

          (_console4 = console).warn.apply(_console4, [tag].concat(data));

          break;
        }

      case exports.HMSLogLevel.ERROR:
        {
          var _console5;

          (_console5 = console).error.apply(_console5, [tag].concat(data));

          break;
        }

      case exports.HMSLogLevel.TIME:
        {
          performance.mark(data[0]);
          break;
        }

      case exports.HMSLogLevel.TIMEEND:
        {
          var mark = data[0];

          try {
            var entry = performance.measure(mark, mark); // @ts-ignore

            this.log(exports.HMSLogLevel.DEBUG, tag, mark, entry == null ? void 0 : entry.duration);
            performance.clearMarks(mark);
            performance.clearMeasures(mark);
          } catch (error) {
            this.log(exports.HMSLogLevel.DEBUG, tag, mark, error);
          }

          break;
        }
    }
  };

  return HMSLogger;
}();
HMSLogger.level = exports.HMSLogLevel.VERBOSE;

/**
 * Check only for presence(not truthy) of a value.
 * Use in places where 0, false need to be considered valid.
 */
function isPresent(value) {
  return value !== undefined && value !== null;
}

/**
 * @DISCUSS: Should we have a wrapper over RTCSessionDescriptionInit(SDP) and have these methods in it?
 */

function fixMsid(desc, tracks) {
  var _parsedSdp$origin;

  var parsedSdp = sdpTransform.parse(desc.sdp);

  if (!((_parsedSdp$origin = parsedSdp.origin) != null && _parsedSdp$origin.username.startsWith('mozilla'))) {
    // This isn't firefox, so we return the original offer without doing anything
    return desc;
  }

  var mediaTracks = Array.from(tracks.values());
  parsedSdp.media.forEach(function (m) {
    var _m$msid, _mediaTracks$find;

    var streamId = (_m$msid = m.msid) == null ? void 0 : _m$msid.split(' ')[0]; // check for both type and streamid as both video and screenshare have same type but different stream_id

    var trackId = (_mediaTracks$find = mediaTracks.find(function (val) {
      return val.type === m.type && val.stream_id === streamId;
    })) == null ? void 0 : _mediaTracks$find.track_id;

    if (trackId) {
      var _m$msid2;

      m.msid = (_m$msid2 = m.msid) == null ? void 0 : _m$msid2.replace(/\s(.+)/, " " + trackId);
    }
  });
  return {
    type: desc.type,
    sdp: sdpTransform.write(parsedSdp)
  };
}
/**
 * Get the track ID from the SDP using the transceiver's mid from RTCTrackEvent
 * @TODO: This could take more processing time in a large room and when the SDP is big.
 * Consider using this for Firefox only?
 */

function getSdpTrackIdForMid(desc, mid) {
  var _trackSection$msid;

  if (!(desc != null && desc.sdp) || !mid) {
    return undefined;
  }

  var parsedSdp = sdpTransform.parse(desc.sdp);
  var trackSection = parsedSdp.media.find(function (media) {
    return isPresent(media.mid) && parseInt(media.mid) === parseInt(mid);
  });
  var trackId = trackSection == null ? void 0 : (_trackSection$msid = trackSection.msid) == null ? void 0 : _trackSection$msid.split(' ')[1];
  return trackId;
}
function enableOpusDtx(desc) {
  if (desc.sdp.includes('usedtx=1')) return desc;
  return {
    type: desc.type,
    sdp: desc.sdp.replace('useinbandfec=1', 'useinbandfec=1;usedtx=1')
  };
}

/*
 * ErrorCodes.ts
 *
 * Created by codegen
 * Copyright © 2021 100ms. All rights reserved.
 */
var ErrorCodes = {
  WebSocketConnectionErrors: {
    // Something went wrong
    GENERIC_CONNECT: 1000,
    // Network connection lost
    WEBSOCKET_CONNECTION_LOST: 1003
  },
  InitAPIErrors: {
    // [INIT]: Server error
    SERVER_ERRORS: 2000,
    // [INIT]: Network error
    CONNECTION_LOST: 2001,
    // Bad Request
    HTTP_ERROR: 2400,
    // Endpoint URL is invalid
    INVALID_ENDPOINT_URL: 2002,
    // Endpoint is not reachable.
    ENDPOINT_UNREACHABLE: 2003,
    // Token is not in proper JWT format
    INVALID_TOKEN_FORMAT: 2004
  },
  TracksErrors: {
    // [PUBLISH]: Something went wrong
    GENERIC_TRACK: 3000,
    // [PUBLISH]: No permission to access capture device - {device_type}
    CANT_ACCESS_CAPTURE_DEVICE: 3001,
    // [PUBLISH]: Capture device is no longer available - {device_type}
    DEVICE_NOT_AVAILABLE: 3002,
    // [PUBLISH]: Capture device is in use by another application - {device_type}
    DEVICE_IN_USE: 3003,
    // Lost access to capture device midway - {device_type}
    DEVICE_LOST_MIDWAY: 3008,
    // There is no media to return. Please select either video or audio or both.
    NOTHING_TO_RETURN: 3005,
    // Cannot enable simulcast when no video settings are provided
    INVALID_VIDEO_SETTINGS: 3006,
    // Codec can't be changed mid call.
    CODEC_CHANGE_NOT_PERMITTED: 3007,
    // When the browser throws autoplay exception if something is played before interacting
    AUTOPLAY_ERROR: 3008
  },
  WebrtcErrors: {
    // [{action}]: Failed to create offer.
    CREATE_OFFER_FAILED: 4001,
    // [{action}]: Failed to create answer.
    CREATE_ANSWER_FAILED: 4002,
    // [{action}]: Failed to set offer.
    SET_LOCAL_DESCRIPTION_FAILED: 4003,
    // [{action}]: Failed to set answer.
    SET_REMOTE_DESCRIPTION_FAILED: 4004,
    // [{action}]: Ice connection state FAILED
    ICE_FAILURE: 4005
  },
  WebsocketMethodErrors: {
    // [JOIN]: {server_error}
    SERVER_ERRORS: 5000,
    // [JOIN]: You have already joined this room.
    ALREADY_JOINED: 5001,
    // [JOIN]: Cannot join if preview is in progress
    CANNOT_JOIN_PREVIEW_IN_PROGRESS: 5002
  },
  GenericErrors: {
    // Client is not connected
    NOT_CONNECTED: 6000,
    // Unknown signalling error: {action} {error_info}
    SIGNALLING: 6001,
    // Unknown exception: {error_info}
    UNKNOWN: 6002,
    // WebRTC engine is not ready yet
    NOT_READY: 6003,
    // Failed to parse JSON message - {json_message}
    JSON_PARSING_FAILED: 6004,
    // Track Metadata Missing
    TRACK_METADATA_MISSING: 6005,
    // RTC Track missing
    RTC_TRACK_MISSING: 6006,
    // Peer Metadata Missing
    PEER_METADATA_MISSING: 6007,
    // Joined with invalid role
    INVALID_ROLE: 6008
  },
  PlaylistErrors: {
    NO_ENTRY_TO_PLAY: 8001,
    NO_ENTRY_IS_PLAYING: 8002
  }
};

var HMSException = /*#__PURE__*/function (_Error) {
  _inheritsLoose(HMSException, _Error);

  function HMSException(code, name, action, message, description, isTerminal) {
    var _this;

    if (isTerminal === void 0) {
      isTerminal = false;
    }

    _this = _Error.call(this, message) || this;
    _this.code = code;
    _this.name = name;
    _this.message = message;
    _this.description = description;
    _this.isTerminal = isTerminal; // Ref: https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work

    Object.setPrototypeOf(_assertThisInitialized(_this), HMSException.prototype);
    _this.action = action.toString();
    return _this;
  }

  var _proto = HMSException.prototype;

  _proto.toAnalyticsProperties = function toAnalyticsProperties() {
    return {
      error_name: this.name,
      error_code: this.code,
      error_message: this.message,
      error_description: this.description,
      action: this.action,
      is_terminal: this.isTerminal
    };
  };

  _proto.addNativeError = function addNativeError(error) {
    this.nativeError = error;
  };

  return HMSException;
}( /*#__PURE__*/_wrapNativeSuper(Error));

/*
 * ErrorFactory.ts
 *
 * Created by codegen
 * Copyright © 2021 100ms. All rights reserved.
 */
var HMSAction;

(function (HMSAction) {
  HMSAction["NONE"] = "NONE";
  HMSAction["TRACK"] = "TRACK";
  HMSAction["INIT"] = "INIT";
  HMSAction["PUBLISH"] = "PUBLISH";
  HMSAction["UNPUBLISH"] = "UNPUBLISH";
  HMSAction["JOIN"] = "JOIN";
  HMSAction["SUBSCRIBE"] = "SUBSCRIBE";
  HMSAction["DATA_CHANNEL_SEND"] = "DATA_CHANNEL_SEND";
  HMSAction["RESTART_ICE"] = "RESTART_ICE";
  HMSAction["VIDEO_PLUGINS"] = "VIDEO_PLUGINS";
  HMSAction["AUDIO_PLUGINS"] = "AUDIO_PLUGINS";
  HMSAction["AUTOPLAY"] = "AUTOPLAY";
  HMSAction["RECONNECT_SIGNAL"] = "RECONNECT_SIGNAL";
  HMSAction["VALIDATION"] = "VALIDATION";
  HMSAction["PLAYLIST"] = "PLAYLIST";
})(HMSAction || (HMSAction = {}));

var ErrorFactory = {
  WebSocketConnectionErrors: {
    GenericConnect: function GenericConnect(action, description) {
      if (description === void 0) {
        description = '';
      }

      return new HMSException(1000, 'GenericConnect', action, "Something went wrong", description);
    },
    WebSocketConnectionLost: function WebSocketConnectionLost(action, description) {
      if (description === void 0) {
        description = '';
      }

      return new HMSException(1003, 'WebSocketConnectionLost', action, "Network connection lost ", description);
    }
  },
  InitAPIErrors: {
    ServerErrors: function ServerErrors(code, action, description) {
      if (description === void 0) {
        description = '';
      }

      return new HMSException(code, 'ServerErrors', action, "[INIT]: Server error", description);
    },
    ConnectionLost: function ConnectionLost(action, description) {
      if (description === void 0) {
        description = '';
      }

      return new HMSException(2001, 'ConnectionLost', action, "[INIT]: Network error", description);
    },
    HTTPError: function HTTPError(code, action, description) {
      if (description === void 0) {
        description = '';
      }

      return new HMSException(code, 'HTTPError', action, "[INIT]: Bad Request", description);
    },
    InvalidEndpointURL: function InvalidEndpointURL(action, description) {
      if (description === void 0) {
        description = '';
      }

      return new HMSException(2002, 'InvalidEndpointURL', action, "Endpoint URL is invalid", description);
    },
    EndpointUnreachable: function EndpointUnreachable(action, description) {
      if (description === void 0) {
        description = '';
      }

      return new HMSException(2003, 'EndpointUnreachable', action, "Endpoint is not reachable.", description);
    },
    InvalidTokenFormat: function InvalidTokenFormat(action, description) {
      if (description === void 0) {
        description = '';
      }

      return new HMSException(2004, 'InvalidTokenFormat', action, "Token is not in proper JWT format", description);
    }
  },
  TracksErrors: {
    GenericTrack: function GenericTrack(action, description) {
      if (description === void 0) {
        description = '';
      }

      return new HMSException(3000, 'GenericTrack', action, "[TRACK]: Something went wrong", description);
    },
    CantAccessCaptureDevice: function CantAccessCaptureDevice(action, deviceInfo, description) {
      if (description === void 0) {
        description = '';
      }

      return new HMSException(3001, 'CantAccessCaptureDevice', action, "[TRACK]: No permission to access capture device - " + deviceInfo, description);
    },
    DeviceNotAvailable: function DeviceNotAvailable(action, deviceInfo, description) {
      if (description === void 0) {
        description = '';
      }

      return new HMSException(3002, 'DeviceNotAvailable', action, "[TRACK]: Capture device is no longer available - " + deviceInfo, description);
    },
    DeviceInUse: function DeviceInUse(action, deviceInfo, description) {
      if (description === void 0) {
        description = '';
      }

      return new HMSException(3003, 'DeviceInUse', action, "[TRACK]: Capture device is in use by another application - " + deviceInfo, description);
    },
    DeviceLostMidway: function DeviceLostMidway(action, deviceInfo, description) {
      if (description === void 0) {
        description = '';
      }

      return new HMSException(3008, 'DeviceLostMidway', action, "Lost access to capture device midway - " + deviceInfo, description);
    },
    NothingToReturn: function NothingToReturn(action, description) {
      if (description === void 0) {
        description = '';
      }

      return new HMSException(3005, 'NothingToReturn', action, "There is no media to return. Please select either video or audio or both.", description);
    },
    InvalidVideoSettings: function InvalidVideoSettings(action, description) {
      if (description === void 0) {
        description = '';
      }

      return new HMSException(3006, 'InvalidVideoSettings', action, "Cannot enable simulcast when no video settings are provided", description);
    },
    AutoplayBlocked: function AutoplayBlocked(action, description) {
      if (description === void 0) {
        description = '';
      }

      return new HMSException(ErrorCodes.TracksErrors.AUTOPLAY_ERROR, 'AutoplayBlocked', action, "Autoplay blocked because the user didn't interact with the document first", description);
    },
    CodecChangeNotPermitted: function CodecChangeNotPermitted(action, description) {
      if (description === void 0) {
        description = '';
      }

      return new HMSException(3007, 'CodecChangeNotPermitted', action, "Codec can't be changed mid call.", description);
    }
  },
  WebrtcErrors: {
    CreateOfferFailed: function CreateOfferFailed(action, description) {
      if (description === void 0) {
        description = '';
      }

      return new HMSException(4001, 'CreateOfferFailed', action, "[" + action.toString() + "]: Failed to create offer. ", description);
    },
    CreateAnswerFailed: function CreateAnswerFailed(action, description) {
      if (description === void 0) {
        description = '';
      }

      return new HMSException(4002, 'CreateAnswerFailed', action, "[" + action.toString() + "]: Failed to create answer. ", description);
    },
    SetLocalDescriptionFailed: function SetLocalDescriptionFailed(action, description) {
      if (description === void 0) {
        description = '';
      }

      return new HMSException(4003, 'SetLocalDescriptionFailed', action, "[" + action.toString() + "]: Failed to set offer. ", description);
    },
    SetRemoteDescriptionFailed: function SetRemoteDescriptionFailed(action, description) {
      if (description === void 0) {
        description = '';
      }

      return new HMSException(4004, 'SetRemoteDescriptionFailed', action, "[" + action.toString() + "]: Failed to set answer. ", description);
    },
    ICEFailure: function ICEFailure(action, description) {
      if (description === void 0) {
        description = '';
      }

      return new HMSException(4005, 'ICEFailure', action, "[" + action.toString() + "]: Ice connection state FAILED", description);
    }
  },
  WebsocketMethodErrors: {
    ServerErrors: function ServerErrors(code, action, description) {
      return new HMSException(code, 'ServerErrors', action, description, description);
    },
    AlreadyJoined: function AlreadyJoined(action, description) {
      if (description === void 0) {
        description = '';
      }

      return new HMSException(5001, 'AlreadyJoined', action, "[JOIN]: You have already joined this room.", description);
    },
    CannotJoinPreviewInProgress: function CannotJoinPreviewInProgress(action, description) {
      if (description === void 0) {
        description = '';
      }

      return new HMSException(5002, 'CannotJoinPreviewInProgress', action, "[JOIN]: Cannot join if preview is in progress", description);
    }
  },
  GenericErrors: {
    NotConnected: function NotConnected(action, description) {
      if (description === void 0) {
        description = '';
      }

      return new HMSException(6000, 'NotConnected', action, "Client is not connected", description);
    },
    Signalling: function Signalling(action, description) {
      return new HMSException(6001, 'Signalling', action, "Unknown signalling error: " + action.toString() + " " + description + " ", description);
    },
    Unknown: function Unknown(action, description) {
      return new HMSException(6002, 'Unknown', action, "Unknown exception: " + description, description);
    },
    NotReady: function NotReady(action, description) {
      if (description === void 0) {
        description = '';
      }

      return new HMSException(6003, 'NotReady', action, "WebRTC engine is not ready yet", description);
    },
    JsonParsingFailed: function JsonParsingFailed(action, jsonMessage, description) {
      if (description === void 0) {
        description = '';
      }

      return new HMSException(6004, 'JsonParsingFailed', action, "Failed to parse JSON message - " + jsonMessage, description);
    },
    TrackMetadataMissing: function TrackMetadataMissing(action, description) {
      if (description === void 0) {
        description = '';
      }

      return new HMSException(6005, 'TrackMetadataMissing', action, "Track Metadata Missing", description);
    },
    RTCTrackMissing: function RTCTrackMissing(action, description) {
      if (description === void 0) {
        description = '';
      }

      return new HMSException(6006, 'RTCTrackMissing', action, "RTC Track missing", description);
    },
    PeerMetadataMissing: function PeerMetadataMissing(action, description) {
      if (description === void 0) {
        description = '';
      }

      return new HMSException(6007, 'PeerMetadataMissing', action, "Peer Metadata Missing", description);
    },
    ValidationFailed: function ValidationFailed(message, entity) {
      return new HMSException(6008, 'ValidationFailed', HMSAction.VALIDATION, message, entity ? JSON.stringify(entity) : '');
    },
    InvalidRole: function InvalidRole(action, description) {
      return new HMSException(ErrorCodes.GenericErrors.INVALID_ROLE, 'InvalidRole', action, "Invalid role. Join with valid role", description, true);
    }
  },
  MediaPluginErrors: {
    PlatformNotSupported: function PlatformNotSupported(action, description) {
      if (description === void 0) {
        description = '';
      }

      return new HMSException(7001, 'PlatformNotSupported', action, 'Check HMS Docs to see the list of supported platforms', description);
    },
    InitFailed: function InitFailed(action, description) {
      if (description === void 0) {
        description = '';
      }

      return new HMSException(7002, 'InitFailed', action, 'Plugin init failed', description);
    },
    ProcessingFailed: function ProcessingFailed(action, description) {
      if (description === void 0) {
        description = '';
      }

      return new HMSException(7003, 'ProcessingFailed', action, 'Plugin processing failed', description);
    },
    AddAlreadyInProgress: function AddAlreadyInProgress(action, description) {
      if (description === void 0) {
        description = '';
      }

      return new HMSException(7004, 'AddAlreadyInProgress', action, 'Plugin add already in progress', description);
    }
  },
  PlaylistErrors: {
    NoEntryToPlay: function NoEntryToPlay(action, description) {
      return new HMSException(ErrorCodes.PlaylistErrors.NO_ENTRY_TO_PLAY, 'NoEntryToPlay', action, 'Reached end of playlist', description);
    },
    NoEntryPlaying: function NoEntryPlaying(action, description) {
      return new HMSException(ErrorCodes.PlaylistErrors.NO_ENTRY_IS_PLAYING, 'NoEntryIsPlaying', action, 'No entry is playing at this time', description);
    }
  }
};

var TAG = 'HMSConnection';

var HMSConnection = /*#__PURE__*/function () {
  function HMSConnection(role, signal) {
    /**
     * We keep a list of pending IceCandidates received
     * from the signalling server. When the peer-connection
     * is initialized we call [addIceCandidate] for each.
     *
     * WARN:
     *  - [HMSPublishConnection] keeps the complete list of candidates (for
     *      ice-connection failed/disconnect) forever.
     *  - [HMSSubscribeConnection] clears this list as soon as we call [addIceCandidate]
     */
    this.candidates = new Array();
    this.role = role;
    this.signal = signal;
  }

  var _proto = HMSConnection.prototype;

  _proto.addTransceiver = function addTransceiver(track, init) {
    return this.nativeConnection.addTransceiver(track, init);
  };

  _proto.createOffer = /*#__PURE__*/function () {
    var _createOffer = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(options, tracks) {
      var offer;
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (options === void 0) {
                options = undefined;
              }

              _context.prev = 1;
              _context.next = 4;
              return this.nativeConnection.createOffer(options);

            case 4:
              offer = _context.sent;
              HMSLogger.d(TAG, "[role=" + this.role + "] createOffer offer=" + JSON.stringify(offer, null, 1));
              return _context.abrupt("return", enableOpusDtx(fixMsid(offer, tracks)));

            case 9:
              _context.prev = 9;
              _context.t0 = _context["catch"](1);
              throw ErrorFactory.WebrtcErrors.CreateOfferFailed(this.action, _context.t0.message);

            case 12:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this, [[1, 9]]);
    }));

    function createOffer(_x, _x2) {
      return _createOffer.apply(this, arguments);
    }

    return createOffer;
  }();

  _proto.createAnswer = /*#__PURE__*/function () {
    var _createAnswer = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(options) {
      var answer;
      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (options === void 0) {
                options = undefined;
              }

              _context2.prev = 1;
              _context2.next = 4;
              return this.nativeConnection.createAnswer(options);

            case 4:
              answer = _context2.sent;
              HMSLogger.d(TAG, "[role=" + this.role + "] createAnswer answer=" + JSON.stringify(answer, null, 1));
              return _context2.abrupt("return", answer);

            case 9:
              _context2.prev = 9;
              _context2.t0 = _context2["catch"](1);
              throw ErrorFactory.WebrtcErrors.CreateAnswerFailed(this.action, _context2.t0.message);

            case 12:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this, [[1, 9]]);
    }));

    function createAnswer(_x3) {
      return _createAnswer.apply(this, arguments);
    }

    return createAnswer;
  }();

  _proto.setLocalDescription = /*#__PURE__*/function () {
    var _setLocalDescription = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3(description) {
      return runtime_1.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              _context3.prev = 0;
              HMSLogger.d(TAG, "[role=" + this.role + "] setLocalDescription description=" + JSON.stringify(description, null, 1));
              _context3.next = 4;
              return this.nativeConnection.setLocalDescription(description);

            case 4:
              _context3.next = 9;
              break;

            case 6:
              _context3.prev = 6;
              _context3.t0 = _context3["catch"](0);
              throw ErrorFactory.WebrtcErrors.SetLocalDescriptionFailed(this.action, _context3.t0.message);

            case 9:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, this, [[0, 6]]);
    }));

    function setLocalDescription(_x4) {
      return _setLocalDescription.apply(this, arguments);
    }

    return setLocalDescription;
  }();

  _proto.setRemoteDescription = /*#__PURE__*/function () {
    var _setRemoteDescription = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4(description) {
      return runtime_1.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              _context4.prev = 0;
              HMSLogger.d(TAG, "[role=" + this.role + "] setRemoteDescription description=" + JSON.stringify(description, null, 1));
              _context4.next = 4;
              return this.nativeConnection.setRemoteDescription(description);

            case 4:
              _context4.next = 9;
              break;

            case 6:
              _context4.prev = 6;
              _context4.t0 = _context4["catch"](0);
              throw ErrorFactory.WebrtcErrors.SetRemoteDescriptionFailed(this.action, _context4.t0.message);

            case 9:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4, this, [[0, 6]]);
    }));

    function setRemoteDescription(_x5) {
      return _setRemoteDescription.apply(this, arguments);
    }

    return setRemoteDescription;
  }();

  _proto.addIceCandidate = /*#__PURE__*/function () {
    var _addIceCandidate = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee5(candidate) {
      return runtime_1.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              HMSLogger.d(TAG, "[role=" + this.role + "] addIceCandidate candidate=" + JSON.stringify(candidate, null, 1));
              _context5.next = 3;
              return this.nativeConnection.addIceCandidate(candidate);

            case 3:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5, this);
    }));

    function addIceCandidate(_x6) {
      return _addIceCandidate.apply(this, arguments);
    }

    return addIceCandidate;
  }();

  _proto.getSenders = function getSenders() {
    return this.nativeConnection.getSenders();
  };

  _proto.removeTrack = function removeTrack(sender) {
    this.nativeConnection.removeTrack(sender);
  };

  _proto.setMaxBitrate = /*#__PURE__*/function () {
    var _setMaxBitrate = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee6(maxBitrate, track) {
      var sender, params;
      return runtime_1.wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              sender = this.getSenders().find(function (s) {
                var _s$track;

                return (s == null ? void 0 : (_s$track = s.track) == null ? void 0 : _s$track.id) === track.getTrackIDBeingSent();
              });

              if (!sender) {
                _context6.next = 8;
                break;
              }

              params = sender.getParameters();

              if (params.encodings.length > 0) {
                params.encodings[0].maxBitrate = maxBitrate * 1000;
              }

              _context6.next = 6;
              return sender.setParameters(params);

            case 6:
              _context6.next = 9;
              break;

            case 8:
              HMSLogger.w(TAG, "no sender found to setMaxBitrate for track - " + track.trackId + ", sentTrackId - " + track.getTrackIDBeingSent());

            case 9:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6, this);
    }));

    function setMaxBitrate(_x7, _x8) {
      return _setMaxBitrate.apply(this, arguments);
    }

    return setMaxBitrate;
  }();

  _proto.getStats = /*#__PURE__*/function () {
    var _getStats = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee7() {
      var stats, reports;
      return runtime_1.wrap(function _callee7$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              _context7.next = 2;
              return this.nativeConnection.getStats();

            case 2:
              stats = _context7.sent;
              reports = [];
              stats.forEach(function (stat) {
                return reports.push(stat);
              });
              return _context7.abrupt("return", reports);

            case 6:
            case "end":
              return _context7.stop();
          }
        }
      }, _callee7, this);
    }));

    function getStats() {
      return _getStats.apply(this, arguments);
    }

    return getStats;
  }();

  _proto.close = /*#__PURE__*/function () {
    var _close = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee8() {
      return runtime_1.wrap(function _callee8$(_context8) {
        while (1) {
          switch (_context8.prev = _context8.next) {
            case 0:
              this.nativeConnection.close();

            case 1:
            case "end":
              return _context8.stop();
          }
        }
      }, _callee8, this);
    }));

    function close() {
      return _close.apply(this, arguments);
    }

    return close;
  }();

  _createClass(HMSConnection, [{
    key: "iceConnectionState",
    get: function get() {
      return this.nativeConnection.iceConnectionState;
    }
  }, {
    key: "connectionState",
    get: function get() {
      return this.nativeConnection.connectionState;
    }
  }, {
    key: "action",
    get: function get() {
      return this.role === HMSConnectionRole.Publish ? HMSAction.PUBLISH : HMSAction.SUBSCRIBE;
    }
  }, {
    key: "remoteDescription",
    get: function get() {
      return this.nativeConnection.remoteDescription;
    }
  }]);

  return HMSConnection;
}();

var RENEGOTIATION_CALLBACK_ID = 'renegotiation-callback-id';
var API_DATA_CHANNEL = 'ion-sfu';
var ANALYTICS_BUFFER_SIZE = 100;
/**
 * Maximum number of retries that transport-layer will try
 * before giving up on the connection and returning a failure
 *
 * Refer https://100ms.atlassian.net/browse/HMS-2369
 */

var MAX_TRANSPORT_RETRIES = 5;
var MAX_TRANSPORT_RETRY_DELAY = 60;
var DEFAULT_SIGNAL_PING_TIMEOUT = 10000;
var SIGNAL_PING_INTERVAL = 1000;
var SUBSCRIBE_ICE_CONNECTION_CALLBACK_ID = 'SUBSCRIBE_ICE_CONNECTION_CALLBACK_ID';
var SUBSCRIBE_TIMEOUT = 60000;
var RTC_STATS_MONITOR_INTERVAL = 1000;

var TAG$1 = 'HMSPublishConnection';

var HMSPublishConnection = /*#__PURE__*/function (_HMSConnection) {
  _inheritsLoose(HMSPublishConnection, _HMSConnection);

  function HMSPublishConnection(signal, config, observer, transport) {
    var _this;

    _this = _HMSConnection.call(this, HMSConnectionRole.Publish, signal) || this;
    _this.observer = observer;
    _this.transport = transport;
    _this.nativeConnection = new RTCPeerConnection(config);

    _this.nativeConnection.createDataChannel(API_DATA_CHANNEL, {
      protocol: 'SCTP'
    });

    _this.nativeConnection.onicecandidate = function (_ref) {
      var candidate = _ref.candidate;

      if (candidate) {
        signal.trickle(_this.role, candidate);
      }
    };

    _this.nativeConnection.oniceconnectionstatechange = function () {
      _this.observer.onIceConnectionChange(_this.nativeConnection.iceConnectionState);
    }; // @TODO(eswar): Remove this. Use iceconnectionstate change with interval and threshold.


    _this.nativeConnection.onconnectionstatechange = function () {
      _this.observer.onConnectionStateChange(_this.nativeConnection.connectionState);
    };

    return _this;
  }

  var _proto = HMSPublishConnection.prototype;

  _proto.initAfterJoin = function initAfterJoin() {
    var _this2 = this;

    this.nativeConnection.onnegotiationneeded = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee() {
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              HMSLogger.d(TAG$1, "onnegotiationneeded");
              _context.next = 3;
              return _this2.observer.onRenegotiationNeeded();

            case 3:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
  };

  _proto.trackUpdate = function trackUpdate(track) {
    this.transport.trackUpdate(track);
  };

  return HMSPublishConnection;
}(HMSConnection);

var HMSMediaStream = function HMSMediaStream(nativeStream) {
  this.tracks = new Array();
  this.nativeStream = nativeStream;
  this.id = nativeStream.id;
};

(function (HMSRoomUpdate) {
  HMSRoomUpdate[HMSRoomUpdate["PEER_ADDED"] = 0] = "PEER_ADDED";
  HMSRoomUpdate[HMSRoomUpdate["PEER_REMOVED"] = 1] = "PEER_REMOVED";
  HMSRoomUpdate[HMSRoomUpdate["PEER_KNOCKED"] = 2] = "PEER_KNOCKED";
  HMSRoomUpdate[HMSRoomUpdate["ROOM_TYPE_CHANGED"] = 3] = "ROOM_TYPE_CHANGED";
  HMSRoomUpdate[HMSRoomUpdate["METADATA_UPDATED"] = 4] = "METADATA_UPDATED";
  HMSRoomUpdate[HMSRoomUpdate["SCREENSHARE_STARTED"] = 5] = "SCREENSHARE_STARTED";
  HMSRoomUpdate[HMSRoomUpdate["SCREENSHARE_STOPPED"] = 6] = "SCREENSHARE_STOPPED";
  HMSRoomUpdate[HMSRoomUpdate["DEFAULT_UPDATE"] = 7] = "DEFAULT_UPDATE";
  HMSRoomUpdate[HMSRoomUpdate["RECORDING_STATE_UPDATED"] = 8] = "RECORDING_STATE_UPDATED";
  HMSRoomUpdate[HMSRoomUpdate["BROWSER_RECORDING_STATE_UPDATED"] = 9] = "BROWSER_RECORDING_STATE_UPDATED";
  HMSRoomUpdate[HMSRoomUpdate["SERVER_RECORDING_STATE_UPDATED"] = 10] = "SERVER_RECORDING_STATE_UPDATED";
  HMSRoomUpdate[HMSRoomUpdate["RTMP_STREAMING_STATE_UPDATED"] = 11] = "RTMP_STREAMING_STATE_UPDATED";
})(exports.HMSRoomUpdate || (exports.HMSRoomUpdate = {}));

(function (HMSPeerUpdate) {
  HMSPeerUpdate[HMSPeerUpdate["PEER_JOINED"] = 0] = "PEER_JOINED";
  HMSPeerUpdate[HMSPeerUpdate["PEER_LEFT"] = 1] = "PEER_LEFT";
  HMSPeerUpdate[HMSPeerUpdate["AUDIO_TOGGLED"] = 2] = "AUDIO_TOGGLED";
  HMSPeerUpdate[HMSPeerUpdate["VIDEO_TOGGLED"] = 3] = "VIDEO_TOGGLED";
  HMSPeerUpdate[HMSPeerUpdate["BECAME_DOMINANT_SPEAKER"] = 4] = "BECAME_DOMINANT_SPEAKER";
  HMSPeerUpdate[HMSPeerUpdate["RESIGNED_DOMINANT_SPEAKER"] = 5] = "RESIGNED_DOMINANT_SPEAKER";
  HMSPeerUpdate[HMSPeerUpdate["STARTED_SPEAKING"] = 6] = "STARTED_SPEAKING";
  HMSPeerUpdate[HMSPeerUpdate["STOPPED_SPEAKING"] = 7] = "STOPPED_SPEAKING";
  HMSPeerUpdate[HMSPeerUpdate["ROLE_UPDATED"] = 8] = "ROLE_UPDATED";
  HMSPeerUpdate[HMSPeerUpdate["PEER_LIST"] = 9] = "PEER_LIST";
})(exports.HMSPeerUpdate || (exports.HMSPeerUpdate = {}));

(function (HMSTrackUpdate) {
  HMSTrackUpdate[HMSTrackUpdate["TRACK_ADDED"] = 0] = "TRACK_ADDED";
  HMSTrackUpdate[HMSTrackUpdate["TRACK_REMOVED"] = 1] = "TRACK_REMOVED";
  HMSTrackUpdate[HMSTrackUpdate["TRACK_MUTED"] = 2] = "TRACK_MUTED";
  HMSTrackUpdate[HMSTrackUpdate["TRACK_UNMUTED"] = 3] = "TRACK_UNMUTED";
  HMSTrackUpdate[HMSTrackUpdate["TRACK_DESCRIPTION_CHANGED"] = 4] = "TRACK_DESCRIPTION_CHANGED";
  HMSTrackUpdate[HMSTrackUpdate["TRACK_DEGRADED"] = 5] = "TRACK_DEGRADED";
  HMSTrackUpdate[HMSTrackUpdate["TRACK_RESTORED"] = 6] = "TRACK_RESTORED";
})(exports.HMSTrackUpdate || (exports.HMSTrackUpdate = {}));

(function (HMSRoomType) {
  HMSRoomType[HMSRoomType["DEFAULT"] = 0] = "DEFAULT";
})(exports.HMSRoomType || (exports.HMSRoomType = {}));

(function (HMSSimulcastLayer) {
  HMSSimulcastLayer["NONE"] = "none";
  HMSSimulcastLayer["LOW"] = "low";
  HMSSimulcastLayer["MEDIUM"] = "medium";
  HMSSimulcastLayer["HIGH"] = "high";
})(exports.HMSSimulcastLayer || (exports.HMSSimulcastLayer = {}));

var simulcastMapping = {
  f: exports.HMSSimulcastLayer.HIGH,
  h: exports.HMSSimulcastLayer.MEDIUM,
  q: exports.HMSSimulcastLayer.LOW
};

(function (HMSVideoCodec) {
  HMSVideoCodec["VP8"] = "vp8";
  HMSVideoCodec["VP9"] = "vp9";
  HMSVideoCodec["H264"] = "h264";
})(exports.HMSVideoCodec || (exports.HMSVideoCodec = {}));

(function (HMSAudioCodec) {
  HMSAudioCodec["OPUS"] = "opus";
})(exports.HMSAudioCodec || (exports.HMSAudioCodec = {}));

(function (HMSPlaylistType) {
  HMSPlaylistType["audio"] = "audio";
  HMSPlaylistType["video"] = "video";
})(exports.HMSPlaylistType || (exports.HMSPlaylistType = {}));

/** @internal */

var HMSRemoteStream = /*#__PURE__*/function (_HMSMediaStream) {
  _inheritsLoose(HMSRemoteStream, _HMSMediaStream);

  function HMSRemoteStream(nativeStream, connection) {
    var _this;

    _this = _HMSMediaStream.call(this, nativeStream) || this;
    _this.audio = true;
    _this.video = exports.HMSSimulcastLayer.NONE;
    _this.frameRate = exports.HMSSimulcastLayer.HIGH;
    _this.connection = connection;
    return _this;
  }

  var _proto = HMSRemoteStream.prototype;

  _proto.setAudio = function setAudio(enabled) {
    if (this.audio === enabled) return;
    this.audio = enabled;
    this.syncWithApiChannel();
  };

  _proto.setVideo = function setVideo(layer) {
    if (this.video === layer) {
      HMSLogger.d("[Remote stream] " + this.id, "Already on " + layer + " layer");
      return;
    }

    this.video = layer;
    HMSLogger.d("[Remote stream] " + this.id, "Switching to " + layer + " layer");
    this.syncWithApiChannel();
  };

  _proto.getSimulcastLayer = function getSimulcastLayer() {
    return this.video;
  };

  _proto.isAudioSubscribed = function isAudioSubscribed() {
    return this.audio;
  };

  _proto.syncWithApiChannel = function syncWithApiChannel() {
    var data = {
      streamId: this.id,
      video: this.video,
      audio: this.audio,
      framerate: this.frameRate
    };
    this.connection.sendOverApiDataChannel(JSON.stringify(data));
  };

  return HMSRemoteStream;
}(HMSMediaStream);

var HMSDataChannel = /*#__PURE__*/function () {
  function HMSDataChannel(nativeChannel, observer, metadata) {
    var _this = this;

    if (metadata === void 0) {
      metadata = '';
    }

    this.TAG = 'HMSDataChannel';
    this.nativeChannel = nativeChannel;
    this.observer = observer;
    this.metadata = metadata;

    nativeChannel.onmessage = function (e) {
      // HMSLogger.d(this.TAG, `[${this.metadata}] onMessage: label=${this.label}, message=${e.data}`);
      _this.observer.onMessage(e.data);
    };
  }

  var _proto = HMSDataChannel.prototype;

  _proto.send = function send(message) {
    HMSLogger.d(this.TAG, "[" + this.metadata + "] Sending [size=" + message.length + "] message=" + message);
    this.nativeChannel.send(message);
  };

  _proto.close = function close() {
    this.nativeChannel.close();
  };

  _createClass(HMSDataChannel, [{
    key: "id",
    get: function get() {
      return this.nativeChannel.id;
    }
  }, {
    key: "label",
    get: function get() {
      return this.nativeChannel.label;
    }
  }, {
    key: "readyState",
    get: function get() {
      return this.nativeChannel.readyState;
    }
  }]);

  return HMSDataChannel;
}();

var HMSTrack = /*#__PURE__*/function () {
  function HMSTrack(stream, track, source) {
    this.stream = stream;
    this.nativeTrack = track;
    this.source = source;
  }

  var _proto = HMSTrack.prototype;

  _proto.getMediaTrackSettings = function getMediaTrackSettings() {
    return this.nativeTrack.getSettings();
  };

  _proto.setEnabled = /*#__PURE__*/function () {
    var _setEnabled = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(value) {
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              this.nativeTrack.enabled = value;

            case 1:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function setEnabled(_x) {
      return _setEnabled.apply(this, arguments);
    }

    return setEnabled;
  }()
  /**
   * @internal
   */
  ;

  _proto.setSdpTrackId = function setSdpTrackId(sdpTrackId) {
    this.sdpTrackId = sdpTrackId;
  }
  /**
   * @internal
   */
  ;

  _proto.setFirstTrackId = function setFirstTrackId(trackId) {
    this.firstTrackId = trackId;
  }
  /**
   * @internal
   * take care of -
   * 1. https://bugs.chromium.org/p/chromium/issues/detail?id=1232649
   * 2. stopping any tracks
   * 3. plugins related cleanups and stopping
   */
  ;

  _proto.cleanup = function cleanup() {
    var _this$nativeTrack;

    (_this$nativeTrack = this.nativeTrack) == null ? void 0 : _this$nativeTrack.stop();
  };

  _createClass(HMSTrack, [{
    key: "enabled",
    get: function get() {
      return this.nativeTrack.enabled;
    }
    /**
     * firstTrackId => encapsulates change in local track ids
     * sdpTrackId => fixes remote track updates correlation on firefox
     */

  }, {
    key: "trackId",
    get: function get() {
      return this.firstTrackId || this.sdpTrackId || this.nativeTrack.id;
    }
  }]);

  return HMSTrack;
}();

(function (HMSTrackType) {
  HMSTrackType["AUDIO"] = "audio";
  HMSTrackType["VIDEO"] = "video";
})(exports.HMSTrackType || (exports.HMSTrackType = {}));

var HMSAudioTrack = /*#__PURE__*/function (_HMSTrack) {
  _inheritsLoose(HMSAudioTrack, _HMSTrack);

  function HMSAudioTrack(stream, track, source) {
    var _this;

    _this = _HMSTrack.call(this, stream, track, source) || this;
    _this.type = exports.HMSTrackType.AUDIO;
    _this.audioElement = null;
    if (track.kind !== 'audio') throw new Error("Expected 'track' kind = 'audio'");
    return _this;
  }

  var _proto = HMSAudioTrack.prototype;

  _proto.getVolume = function getVolume() {
    return this.audioElement ? this.audioElement.volume * 100 : null;
  };

  _proto.setVolume = function setVolume(value) {
    if (value < 0 || value > 100) {
      throw Error('Please pass a valid number between 0-100');
    } // Don't subscribe to audio when volume is 0


    this.subscribeToAudio(value === 0 ? false : this.enabled);

    if (this.audioElement) {
      this.audioElement.volume = value / 100;
    }
  };

  _proto.setAudioElement = function setAudioElement(element) {
    this.audioElement = element;
  }
  /**
   * @internal
   * @returns {HTMLAudioElement | null}
   */
  ;

  _proto.getAudioElement = function getAudioElement() {
    return this.audioElement;
  };

  _proto.getOutputDevice = function getOutputDevice() {
    return this.outputDevice;
  };

  _proto.cleanup = function cleanup() {
    _HMSTrack.prototype.cleanup.call(this);

    if (this.audioElement) {
      this.audioElement.srcObject = null;
      this.audioElement.remove();
      this.audioElement = null;
    }
  };

  _proto.setOutputDevice = /*#__PURE__*/function () {
    var _setOutputDevice = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(device) {
      var _this$audioElement;

      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (this.audioElement) {
                _context.next = 3;
                break;
              }

              HMSLogger.d('audio-track', 'no audio element to set output');
              return _context.abrupt("return");

            case 3:
              _context.prev = 3;

              if (!(typeof this.audioElement.setSinkId === 'function')) {
                _context.next = 8;
                break;
              }

              _context.next = 7;
              return (_this$audioElement = this.audioElement) == null ? void 0 : _this$audioElement.setSinkId(device.deviceId);

            case 7:
              this.outputDevice = device;

            case 8:
              _context.next = 12;
              break;

            case 10:
              _context.prev = 10;
              _context.t0 = _context["catch"](3);

            case 12:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this, [[3, 10]]);
    }));

    function setOutputDevice(_x) {
      return _setOutputDevice.apply(this, arguments);
    }

    return setOutputDevice;
  }()
  /**
   * removes the track from the audio element of the track
   * @experimental - Not production ready
   */
  ;

  _proto.removeSink = function removeSink() {
    var _window$HMS;

    // @ts-ignore
    if (this.audioElement && (_window$HMS = window.HMS) != null && _window$HMS.AUDIO_SINK) {
      this.audioElement.srcObject = null;
      this.subscribeToAudio(false);
    }
  }
  /**
   * add track if not already added
   * @experimental - Not production ready
   */
  ;

  _proto.addSink = function addSink() {
    var _window$HMS2;

    // @ts-ignore
    if (!this.nativeTrack || !this.audioElement || !((_window$HMS2 = window.HMS) != null && _window$HMS2.AUDIO_SINK)) {
      return;
    }

    var srcObject = this.audioElement.srcObject;

    if (srcObject !== null && srcObject instanceof MediaStream) {
      var _srcObject$getAudioTr;

      var existingTrackID = (_srcObject$getAudioTr = srcObject.getAudioTracks()[0]) == null ? void 0 : _srcObject$getAudioTr.id;

      if (existingTrackID === this.nativeTrack.id) {
        // it's already attached, no need to attach again
        return;
      }
    }

    this.audioElement.srcObject = new MediaStream([this.nativeTrack]);
    this.subscribeToAudio(true);
  };

  _proto.subscribeToAudio = function subscribeToAudio(value) {
    if (this.stream instanceof HMSRemoteStream) {
      this.stream.setAudio(value);
    }
  };

  return HMSAudioTrack;
}(HMSTrack);

var HMSRemoteAudioTrack = /*#__PURE__*/function (_HMSAudioTrack) {
  _inheritsLoose(HMSRemoteAudioTrack, _HMSAudioTrack);

  function HMSRemoteAudioTrack() {
    return _HMSAudioTrack.apply(this, arguments) || this;
  }

  var _proto = HMSRemoteAudioTrack.prototype;

  _proto.setEnabled = /*#__PURE__*/function () {
    var _setEnabled = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(value) {
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (!(value === this.enabled)) {
                _context.next = 2;
                break;
              }

              return _context.abrupt("return");

            case 2:
              _context.next = 4;
              return _HMSAudioTrack.prototype.setEnabled.call(this, value);

            case 4:
              this.subscribeToAudio(value);

            case 5:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function setEnabled(_x) {
      return _setEnabled.apply(this, arguments);
    }

    return setEnabled;
  }();

  return HMSRemoteAudioTrack;
}(HMSAudioTrack);

var HMSVideoTrack = /*#__PURE__*/function (_HMSTrack) {
  _inheritsLoose(HMSVideoTrack, _HMSTrack);

  function HMSVideoTrack(stream, track, source) {
    var _this;

    _this = _HMSTrack.call(this, stream, track, source) || this;
    _this.type = exports.HMSTrackType.VIDEO;
    _this.sinkCount = 0;
    if (track.kind !== 'video') throw new Error("Expected 'track' kind = 'video'");
    return _this;
  }

  var _proto = HMSVideoTrack.prototype;

  _proto.hasSinks = function hasSinks() {
    return this.sinkCount > 0;
  }
  /**
   * attaches the track to the passed in video element
   * @param videoElement
   */
  ;

  _proto.addSink = function addSink(videoElement) {
    this.addSinkInternal(videoElement, this.nativeTrack);
  }
  /**
   * removes the track from the passed in video element
   * @param videoElement
   */
  ;

  _proto.removeSink = function removeSink(videoElement) {
    videoElement.srcObject = null;

    if (this.sinkCount > 0) {
      this.sinkCount--;
    }
  };

  _proto.addSinkInternal = function addSinkInternal(videoElement, track) {
    var srcObject = videoElement.srcObject;

    if (srcObject !== null && srcObject instanceof MediaStream) {
      var _srcObject$getVideoTr;

      var existingTrackID = (_srcObject$getVideoTr = srcObject.getVideoTracks()[0]) == null ? void 0 : _srcObject$getVideoTr.id;

      if (existingTrackID === track.id) {
        // it's already attached, attaching again would just cause flickering
        return;
      }
    }

    videoElement.srcObject = new MediaStream([track]);
    this.sinkCount++;
  };

  return HMSVideoTrack;
}(HMSTrack);

var HMSRemoteVideoTrack = /*#__PURE__*/function (_HMSVideoTrack) {
  _inheritsLoose(HMSRemoteVideoTrack, _HMSVideoTrack);

  function HMSRemoteVideoTrack() {
    var _this;

    _this = _HMSVideoTrack.apply(this, arguments) || this;
    _this._degraded = false;
    _this._layerDefinitions = [];
    return _this;
  }

  var _proto = HMSRemoteVideoTrack.prototype;

  _proto.setEnabled = /*#__PURE__*/function () {
    var _setEnabled = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(value) {
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (!(value === this.enabled)) {
                _context.next = 2;
                break;
              }

              return _context.abrupt("return");

            case 2:
              // If remote track is muted when degraded, reset degraded state
              if (this._degraded && !value) {
                this._degraded = false;
              }

              _context.next = 5;
              return _HMSVideoTrack.prototype.setEnabled.call(this, value);

            case 5:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function setEnabled(_x) {
      return _setEnabled.apply(this, arguments);
    }

    return setEnabled;
  }();

  _proto.preferLayer = function preferLayer(layer) {
    this.stream.setVideo(layer);
  };

  _proto.getSimulcastLayer = function getSimulcastLayer() {
    return this.stream.getSimulcastLayer();
  };

  _proto.addSink = function addSink(videoElement) {
    _HMSVideoTrack.prototype.addSink.call(this, videoElement);

    this.updateLayer();
  };

  _proto.removeSink = function removeSink(videoElement) {
    _HMSVideoTrack.prototype.removeSink.call(this, videoElement);

    this.updateLayer();
  }
  /**
   * Method to get available simulcast definitions for the track
   * @returns {SimulcastLayerDefinition[]}
   */
  ;

  _proto.getSimulcastDefinitions = function getSimulcastDefinitions() {
    // send a clone to store as it will freeze the object from further updates
    return [].concat(this._layerDefinitions);
  }
  /** @internal */
  ;

  _proto.setSimulcastDefinitons = function setSimulcastDefinitons(definitions) {
    this._layerDefinitions = definitions;
  }
  /** @internal */
  ;

  _proto.setDegraded = function setDegraded(value) {
    this._degraded = value;
    this.updateLayer();
  };

  _proto.updateLayer = function updateLayer() {
    var newLayer = this.hasSinks() ? exports.HMSSimulcastLayer.HIGH : exports.HMSSimulcastLayer.NONE;
    if (this.degraded) newLayer = exports.HMSSimulcastLayer.NONE;
    this.stream.setVideo(newLayer);
  };

  _createClass(HMSRemoteVideoTrack, [{
    key: "degraded",
    get: function get() {
      return this._degraded;
    }
  }]);

  return HMSRemoteVideoTrack;
}(HMSVideoTrack);

var HMSSubscribeConnection = /*#__PURE__*/function (_HMSConnection) {
  _inheritsLoose(HMSSubscribeConnection, _HMSConnection);

  function HMSSubscribeConnection(signal, config, observer) {
    var _this;

    _this = _HMSConnection.call(this, HMSConnectionRole.Subscribe, signal) || this;
    _this.TAG = '[HMSSubscribeConnection]';
    _this.remoteStreams = new Map();
    _this.pendingMessageQueue = [];

    _this.handlePendingApiMessages = function () {
      if (_this.pendingMessageQueue.length > 0) {
        HMSLogger.d(_this.TAG, 'Found pending message queue, sending messages');

        _this.pendingMessageQueue.forEach(function (msg) {
          return _this.sendOverApiDataChannel(msg);
        });

        _this.pendingMessageQueue.length = 0;
      }
    };

    _this.observer = observer;
    _this.nativeConnection = new RTCPeerConnection(config);

    _this.initNativeConnectionCallbacks();

    return _this;
  }

  var _proto = HMSSubscribeConnection.prototype;

  _proto.initNativeConnectionCallbacks = function initNativeConnectionCallbacks() {
    var _this2 = this;

    this.nativeConnection.oniceconnectionstatechange = function () {
      _this2.observer.onIceConnectionChange(_this2.nativeConnection.iceConnectionState);
    }; // @TODO(eswar): Remove this. Use iceconnectionstate change with interval and threshold.


    this.nativeConnection.onconnectionstatechange = function () {
      _this2.observer.onConnectionStateChange(_this2.nativeConnection.connectionState);
    };

    this.nativeConnection.ondatachannel = function (e) {
      if (e.channel.label !== API_DATA_CHANNEL) {
        // TODO: this.observer.onDataChannel(e.channel);
        return;
      }

      _this2.apiChannel = new HMSDataChannel(e.channel, {
        onMessage: function onMessage(value) {
          _this2.observer.onApiChannelMessage(value);
        }
      }, "role=" + _this2.role);
      e.channel.onopen = _this2.handlePendingApiMessages;
    };

    this.nativeConnection.onicecandidate = function (e) {
      if (e.candidate !== null) {
        _this2.signal.trickle(_this2.role, e.candidate);
      }
    };

    this.nativeConnection.ontrack = function (e) {
      var _e$transceiver;

      var stream = e.streams[0];
      var streamId = stream.id;

      if (!_this2.remoteStreams.has(streamId)) {
        var _remote = new HMSRemoteStream(stream, _this2);

        _this2.remoteStreams.set(streamId, _remote);

        stream.onremovetrack = function (e) {
          /*
           * this match has to be with nativetrack.id instead of track.trackId as the latter refers to sdp track id for
           * ease of correlating update messages coming from the backend. The two track ids are usually the same, but
           * can be different for some browsers. checkout sdptrackid field in HMSTrack for more details.
           */
          var toRemoveTrackIdx = _remote.tracks.findIndex(function (track) {
            return track.nativeTrack.id === e.track.id;
          });

          if (toRemoveTrackIdx >= 0) {
            var toRemoveTrack = _remote.tracks[toRemoveTrackIdx];

            _this2.observer.onTrackRemove(toRemoveTrack);

            _remote.tracks.splice(toRemoveTrackIdx, 1); // If the length becomes 0 we assume that stream is removed entirely


            if (_remote.tracks.length === 0) {
              _this2.remoteStreams["delete"](streamId);
            }
          }
        };
      }

      var remote = _this2.remoteStreams.get(streamId);

      var TrackCls = e.track.kind === 'audio' ? HMSRemoteAudioTrack : HMSRemoteVideoTrack;
      var track = new TrackCls(remote, e.track);
      var trackId = getSdpTrackIdForMid(_this2.remoteDescription, (_e$transceiver = e.transceiver) == null ? void 0 : _e$transceiver.mid);
      trackId && track.setSdpTrackId(trackId);
      remote.tracks.push(track);

      _this2.observer.onTrackAdd(track);
    };
  };

  _proto.sendOverApiDataChannel = function sendOverApiDataChannel(message) {
    if (this.apiChannel && this.apiChannel.readyState === 'open') {
      this.apiChannel.send(message);
    } else {
      HMSLogger.w(this.TAG, "API Data channel not " + (this.apiChannel ? 'open' : 'present') + ", queueing", message);
      this.pendingMessageQueue.push(message);
    }
  };

  _proto.close = /*#__PURE__*/function () {
    var _close = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee() {
      var _this$apiChannel;

      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return _HMSConnection.prototype.close.call(this);

            case 2:
              (_this$apiChannel = this.apiChannel) == null ? void 0 : _this$apiChannel.close();

            case 3:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function close() {
      return _close.apply(this, arguments);
    }

    return close;
  }();

  return HMSSubscribeConnection;
}(HMSConnection);

var version = "0.1.18";

var parsedUserAgent = /*#__PURE__*/new uaParserJs.UAParser();
var isNode = typeof process !== 'undefined' && process.versions != null && process.versions.node != null;
var isBrowser = typeof window !== 'undefined';

var checkIsSupported = function checkIsSupported() {
  if (isNode) {
    return false;
  } // @TODO: Get this from preview/init API from server


  return true;
};

var isSupported = /*#__PURE__*/checkIsSupported();

function createUserAgent() {
  if (isNode) {
    return "hmsclient/" + version;
  }

  var device = parsedUserAgent.getDevice();
  var browser = parsedUserAgent.getBrowser();
  var os = parsedUserAgent.getOS();

  if (device.type) {
    return "hmsclient/" + version + " " + os.name + "/" + os.version + " (" + device.vendor + "_" + device.type + "_/_" + browser.name + "_" + browser.version + ")";
  } else {
    return "hmsclient/" + version + " " + os.name + "/" + os.version + " (" + browser.name + "_" + browser.version + ")";
  }
}

var isMobile = function isMobile() {
  return parsedUserAgent.getDevice().type === 'mobile';
};
var userAgent = /*#__PURE__*/createUserAgent();

var TAG$2 = 'InitService';

var InitService = /*#__PURE__*/function () {
  function InitService() {}

  InitService.fetchInitConfig = /*#__PURE__*/function () {
    var _fetchInitConfig = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(token, initEndpoint, region) {
      var url, response, config, _response, body, _response2, error;

      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (initEndpoint === void 0) {
                initEndpoint = 'https://prod-init.100ms.live';
              }

              if (region === void 0) {
                region = '';
              }

              HMSLogger.d(TAG$2, "fetchInitConfig: initEndpoint=" + initEndpoint + " token=" + token + " region=" + region);
              url = getUrl(initEndpoint, region);
              _context.prev = 4;
              _context.next = 7;
              return fetch(url, {
                headers: {
                  Authorization: "Bearer " + token
                }
              });

            case 7:
              response = _context.sent;
              _context.next = 10;
              return response.json();

            case 10:
              body = _context.sent;

              if (!(response.status === 404)) {
                _context.next = 13;
                break;
              }

              throw ErrorFactory.InitAPIErrors.EndpointUnreachable(HMSAction.INIT, body.message || response.statusText);

            case 13:
              if (!(((_response = response) == null ? void 0 : _response.status) !== 200)) {
                _context.next = 15;
                break;
              }

              throw ErrorFactory.InitAPIErrors.ServerErrors(body.code || response.status, HMSAction.INIT, body.message || ((_response2 = response) == null ? void 0 : _response2.statusText));

            case 15:
              config = body;
              HMSLogger.d(TAG$2, "config is " + JSON.stringify(config, null, 2));
              _context.next = 25;
              break;

            case 19:
              _context.prev = 19;
              _context.t0 = _context["catch"](4);
              error = _context.t0;

              if (!(error.message === 'Failed to fetch')) {
                _context.next = 24;
                break;
              }

              throw ErrorFactory.InitAPIErrors.ConnectionLost(HMSAction.INIT, error.message);

            case 24:
              throw error;

            case 25:
              return _context.abrupt("return", transformInitConfig(config));

            case 26:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, null, [[4, 19]]);
    }));

    function fetchInitConfig(_x, _x2, _x3) {
      return _fetchInitConfig.apply(this, arguments);
    }

    return fetchInitConfig;
  }();

  return InitService;
}();
function getUrl(endpoint, region) {
  try {
    var url = new URL('/init', endpoint);

    if (region && region.trim().length > 0) {
      url.searchParams.set('region', region.trim());
    }

    url.searchParams.set('user_agent', userAgent);
    return url.toString();
  } catch (err) {
    var error = err;
    HMSLogger.e(TAG$2, error.name, error.message);
    throw error;
  }
}
function transformInitConfig(config) {
  return _extends({}, config, {
    rtcConfiguration: _extends({}, config.rtcConfiguration, {
      iceServers: config.rtcConfiguration.ice_servers
    })
  });
}

var HMSSignalMethod;

(function (HMSSignalMethod) {
  HMSSignalMethod["JOIN"] = "join";
  HMSSignalMethod["OFFER"] = "offer";
  HMSSignalMethod["ANSWER"] = "answer";
  HMSSignalMethod["TRICKLE"] = "trickle";
  HMSSignalMethod["TRACK_UPDATE"] = "track-update";
  HMSSignalMethod["BROADCAST"] = "broadcast";
  HMSSignalMethod["ANALYTICS"] = "analytics";
  HMSSignalMethod["SERVER_ERROR"] = "on-error";
  HMSSignalMethod["SDK_NOTIFICATION"] = "sdk-notification";
  HMSSignalMethod["LEAVE"] = "leave";
  HMSSignalMethod["END_ROOM"] = "end-room";
  HMSSignalMethod["PING"] = "ping";
  HMSSignalMethod["ROLE_CHANGE_REQUEST"] = "role-change-request";
  HMSSignalMethod["ROLE_CHANGE"] = "role-change";
  HMSSignalMethod["TRACK_UPDATE_REQUEST"] = "track-update-request";
  HMSSignalMethod["PEER_LEAVE_REQUEST"] = "peer-leave-request";
  HMSSignalMethod["CHANGE_TRACK_MUTE_STATE_REQUEST"] = "change-track-mute-state-request";
  HMSSignalMethod["START_RTMP_OR_RECORDING_REQUEST"] = "rtmp-start";
  HMSSignalMethod["STOP_RTMP_AND_RECORDING_REQUEST"] = "rtmp-stop";
})(HMSSignalMethod || (HMSSignalMethod = {}));

function convertSignalMethodtoErrorAction(method) {
  switch (method) {
    case HMSSignalMethod.JOIN:
      return HMSAction.JOIN;

    case HMSSignalMethod.OFFER:
      return HMSAction.PUBLISH;

    case HMSSignalMethod.ANSWER:
      return HMSAction.SUBSCRIBE;

    case HMSSignalMethod.TRACK_UPDATE:
      return HMSAction.TRACK;

    default:
      return HMSAction.NONE;
  }
}

var JsonRpcSignal = /*#__PURE__*/function () {
  function JsonRpcSignal(observer) {
    var _this = this;

    this.TAG = '[ SIGNAL ]: ';
    /**
     * Sometimes before [join] is completed, there could be a lot of trickles
     * Sending [HMSTrickle]` before [join] web socket message leads to
     * error: [500] no rtc transport exists for this Peer
     *
     * We keep a list of pending trickles and send them immediately after [join]
     * is done.
     */

    this.isJoinCompleted = false;
    this.pendingTrickle = [];
    this.socket = null;
    this.callbacks = new Map();
    this._isConnected = false;
    this.id = 0;
    this.observer = observer;
    window.addEventListener('offline', function () {
      HMSLogger.d(_this.TAG, 'Window network offline');
      _this.isConnected = false;
    });
    window.addEventListener('online', function () {
      HMSLogger.d(_this.TAG, 'Window network online');
    });
    this.onCloseHandler = this.onCloseHandler.bind(this);
    this.onMessageHandler = this.onMessageHandler.bind(this);
  }

  var _proto = JsonRpcSignal.prototype;

  _proto.call = /*#__PURE__*/function () {
    var _call = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(method, params) {
      var _this2 = this;

      var id, message, response, error;
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              id = uuid.v4();
              message = {
                method: method,
                params: params,
                id: id,
                jsonrpc: '2.0'
              };
              this.socket.send(JSON.stringify(message));
              _context.prev = 3;
              _context.next = 6;
              return new Promise(function (resolve, reject) {
                _this2.callbacks.set(id, {
                  resolve: resolve,
                  reject: reject
                });
              });

            case 6:
              response = _context.sent;
              return _context.abrupt("return", response);

            case 10:
              _context.prev = 10;
              _context.t0 = _context["catch"](3);
              error = _context.t0;
              throw ErrorFactory.WebsocketMethodErrors.ServerErrors(Number(error.code), convertSignalMethodtoErrorAction(method), error.message);

            case 14:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this, [[3, 10]]);
    }));

    function call(_x, _x2) {
      return _call.apply(this, arguments);
    }

    return call;
  }();

  _proto.notify = function notify(method, params) {
    var message = {
      method: method,
      params: params
    };
    this.socket.send(JSON.stringify(message));
  };

  _proto.open = function open(uri) {
    var _this3 = this;

    return new Promise(function (resolve, reject) {
      // cleanup
      if (_this3.socket) {
        _this3.socket.removeEventListener('close', _this3.onCloseHandler);

        _this3.socket.removeEventListener('message', _this3.onMessageHandler);
      }

      _this3.socket = new WebSocket(uri); // @DISCUSS: Inject WebSocket as a dependency so that it can be easier to mock and test

      var errorListener = function errorListener(error) {
        HMSLogger.d(_this3.TAG, 'Error opening socket connection', error);
        reject(ErrorFactory.WebSocketConnectionErrors.GenericConnect(HMSAction.JOIN, 'Error opening socket connection'));
      };

      _this3.socket.addEventListener('error', errorListener);

      var openHandler = function openHandler() {
        resolve();
        _this3.isConnected = true;
        _this3.id++;

        _this3.socket.removeEventListener('open', openHandler);

        _this3.socket.removeEventListener('error', errorListener);

        _this3.pingPongLoop(_this3.id);
      };

      _this3.socket.addEventListener('open', openHandler);

      _this3.socket.addEventListener('close', _this3.onCloseHandler);

      _this3.socket.addEventListener('message', _this3.onMessageHandler);
    });
  };

  _proto.close = /*#__PURE__*/function () {
    var _close = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2() {
      var _this4 = this;

      var p;
      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              p = new Promise(function (resolve) {
                _this4.socket.addEventListener('close', function () {
                  return resolve();
                });
              }); // @TODO: Clean up: Remove event listeners.
              // For `1000` Refer: https://tools.ietf.org/html/rfc6455#section-7.4.1

              this.socket.close(1000, 'Normal Close');
              this.isConnected = false;
              this.socket.removeEventListener('close', this.onCloseHandler);
              this.socket.removeEventListener('message', this.onMessageHandler);
              return _context2.abrupt("return", p);

            case 6:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));

    function close() {
      return _close.apply(this, arguments);
    }

    return close;
  }();

  _proto.join = /*#__PURE__*/function () {
    var _join = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3(name, data, offer, disableVidAutoSub) {
      var _this5 = this;

      var params, response;
      return runtime_1.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              params = {
                name: name,
                disableVidAutoSub: disableVidAutoSub,
                data: data,
                offer: offer
              };
              _context3.next = 3;
              return this.call(HMSSignalMethod.JOIN, params);

            case 3:
              response = _context3.sent;
              this.isJoinCompleted = true;
              this.pendingTrickle.forEach(function (_ref) {
                var target = _ref.target,
                    candidate = _ref.candidate;
                return _this5.trickle(target, candidate);
              });
              this.pendingTrickle.length = 0;
              HMSLogger.d(this.TAG, "join: response=" + JSON.stringify(response, null, 1));
              return _context3.abrupt("return", response);

            case 9:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, this);
    }));

    function join(_x3, _x4, _x5, _x6) {
      return _join.apply(this, arguments);
    }

    return join;
  }();

  _proto.trickle = function trickle(target, candidate) {
    if (this.isJoinCompleted) {
      this.notify(HMSSignalMethod.TRICKLE, {
        target: target,
        candidate: candidate
      });
    } else {
      this.pendingTrickle.push({
        target: target,
        candidate: candidate
      });
    }
  };

  _proto.offer = /*#__PURE__*/function () {
    var _offer = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4(desc, tracks) {
      var response;
      return runtime_1.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              _context4.next = 2;
              return this.call(HMSSignalMethod.OFFER, {
                desc: desc,
                tracks: Object.fromEntries(tracks)
              });

            case 2:
              response = _context4.sent;
              return _context4.abrupt("return", response);

            case 4:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4, this);
    }));

    function offer(_x7, _x8) {
      return _offer.apply(this, arguments);
    }

    return offer;
  }();

  _proto.answer = function answer(desc) {
    this.notify(HMSSignalMethod.ANSWER, {
      desc: desc
    });
  };

  _proto.trackUpdate = function trackUpdate(tracks) {
    this.notify(HMSSignalMethod.TRACK_UPDATE, {
      version: '1.0',
      tracks: Object.fromEntries(tracks)
    });
  };

  _proto.broadcast = /*#__PURE__*/function () {
    var _broadcast = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee5(message) {
      return runtime_1.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              _context5.next = 2;
              return this.call(HMSSignalMethod.BROADCAST, _extends({
                version: '1.0'
              }, message.toSignalParams()));

            case 2:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5, this);
    }));

    function broadcast(_x9) {
      return _broadcast.apply(this, arguments);
    }

    return broadcast;
  }();

  _proto.recordStart = function recordStart() {};

  _proto.recordEnd = function recordEnd() {};

  _proto.leave = function leave() {
    this.notify(HMSSignalMethod.LEAVE, {
      version: '1.0'
    });
  };

  _proto.endRoom = /*#__PURE__*/function () {
    var _endRoom = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee6(lock, reason) {
      return runtime_1.wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              _context6.next = 2;
              return this.call(HMSSignalMethod.END_ROOM, {
                lock: lock,
                reason: reason
              });

            case 2:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6, this);
    }));

    function endRoom(_x10, _x11) {
      return _endRoom.apply(this, arguments);
    }

    return endRoom;
  }();

  _proto.sendEvent = function sendEvent(event) {
    if (!this.isConnected) {
      throw Error(this.TAG + " not connected. Could not send event " + event);
    }

    this.notify(HMSSignalMethod.ANALYTICS, event.toSignalParams());
  };

  _proto.ping = function ping(timeout) {
    var pingTime = Date.now();
    var timer = new Promise(function (resolve) {
      setTimeout(function () {
        resolve(Date.now() - pingTime);
      }, timeout + 1);
    });
    var pongTimeDiff = this.call(HMSSignalMethod.PING, {
      timestamp: pingTime
    }).then(function () {
      return Date.now() - pingTime;
    })["catch"](function () {
      return Date.now() - pingTime;
    });
    return Promise.race([timer, pongTimeDiff]);
  };

  _proto.requestRoleChange = /*#__PURE__*/function () {
    var _requestRoleChange = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee7(params) {
      return runtime_1.wrap(function _callee7$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              _context7.next = 2;
              return this.call(HMSSignalMethod.ROLE_CHANGE_REQUEST, params);

            case 2:
            case "end":
              return _context7.stop();
          }
        }
      }, _callee7, this);
    }));

    function requestRoleChange(_x12) {
      return _requestRoleChange.apply(this, arguments);
    }

    return requestRoleChange;
  }();

  _proto.acceptRoleChangeRequest = /*#__PURE__*/function () {
    var _acceptRoleChangeRequest = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee8(params) {
      return runtime_1.wrap(function _callee8$(_context8) {
        while (1) {
          switch (_context8.prev = _context8.next) {
            case 0:
              _context8.next = 2;
              return this.call(HMSSignalMethod.ROLE_CHANGE, params);

            case 2:
            case "end":
              return _context8.stop();
          }
        }
      }, _callee8, this);
    }));

    function acceptRoleChangeRequest(_x13) {
      return _acceptRoleChangeRequest.apply(this, arguments);
    }

    return acceptRoleChangeRequest;
  }();

  _proto.requestTrackStateChange = /*#__PURE__*/function () {
    var _requestTrackStateChange = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee9(params) {
      return runtime_1.wrap(function _callee9$(_context9) {
        while (1) {
          switch (_context9.prev = _context9.next) {
            case 0:
              _context9.next = 2;
              return this.call(HMSSignalMethod.TRACK_UPDATE_REQUEST, params);

            case 2:
            case "end":
              return _context9.stop();
          }
        }
      }, _callee9, this);
    }));

    function requestTrackStateChange(_x14) {
      return _requestTrackStateChange.apply(this, arguments);
    }

    return requestTrackStateChange;
  }();

  _proto.requestMultiTrackStateChange = /*#__PURE__*/function () {
    var _requestMultiTrackStateChange = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee10(params) {
      return runtime_1.wrap(function _callee10$(_context10) {
        while (1) {
          switch (_context10.prev = _context10.next) {
            case 0:
              _context10.next = 2;
              return this.call(HMSSignalMethod.CHANGE_TRACK_MUTE_STATE_REQUEST, params);

            case 2:
            case "end":
              return _context10.stop();
          }
        }
      }, _callee10, this);
    }));

    function requestMultiTrackStateChange(_x15) {
      return _requestMultiTrackStateChange.apply(this, arguments);
    }

    return requestMultiTrackStateChange;
  }();

  _proto.removePeer = /*#__PURE__*/function () {
    var _removePeer = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee11(params) {
      return runtime_1.wrap(function _callee11$(_context11) {
        while (1) {
          switch (_context11.prev = _context11.next) {
            case 0:
              _context11.next = 2;
              return this.call(HMSSignalMethod.PEER_LEAVE_REQUEST, params);

            case 2:
            case "end":
              return _context11.stop();
          }
        }
      }, _callee11, this);
    }));

    function removePeer(_x16) {
      return _removePeer.apply(this, arguments);
    }

    return removePeer;
  }();

  _proto.startRTMPOrRecording = /*#__PURE__*/function () {
    var _startRTMPOrRecording = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee12(params) {
      return runtime_1.wrap(function _callee12$(_context12) {
        while (1) {
          switch (_context12.prev = _context12.next) {
            case 0:
              _context12.next = 2;
              return this.call(HMSSignalMethod.START_RTMP_OR_RECORDING_REQUEST, _extends({
                version: '1.0'
              }, params));

            case 2:
            case "end":
              return _context12.stop();
          }
        }
      }, _callee12, this);
    }));

    function startRTMPOrRecording(_x17) {
      return _startRTMPOrRecording.apply(this, arguments);
    }

    return startRTMPOrRecording;
  }();

  _proto.stopRTMPAndRecording = /*#__PURE__*/function () {
    var _stopRTMPAndRecording = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee13() {
      return runtime_1.wrap(function _callee13$(_context13) {
        while (1) {
          switch (_context13.prev = _context13.next) {
            case 0:
              _context13.next = 2;
              return this.call(HMSSignalMethod.STOP_RTMP_AND_RECORDING_REQUEST, {
                version: '1.0'
              });

            case 2:
            case "end":
              return _context13.stop();
          }
        }
      }, _callee13, this);
    }));

    function stopRTMPAndRecording() {
      return _stopRTMPAndRecording.apply(this, arguments);
    }

    return stopRTMPAndRecording;
  }();

  _proto.onCloseHandler = function onCloseHandler(event) {
    HMSLogger.d("Websocket closed code=" + event.code);
    this.isConnected = false; // https://stackoverflow.com/questions/18803971/websocket-onerror-how-to-read-error-description
    // @DISCUSS: onOffline would have thrown error already.
    // if (event.code !== 1000) {
    //   HMSLogger.e(`Websocket closed code=${event.code}, reason=${event.reason}`);
    //   // 1000 code indicated `Normal Closure` [https://tools.ietf.org/html/rfc6455#section-7.4.1]
    //   const error = ErrorFactory.WebSocketConnectionErrors.WebSocketConnectionLost(
    //     HMSAction.INIT,
    //     `${event.reason} [${event.code}]`,
    //   );
    //   this.observer.onFailure(error);
    // }
  };

  _proto.onMessageHandler = function onMessageHandler(event) {
    var text = event.data;
    var response = JSON.parse(text);

    if (response.hasOwnProperty('id')) {
      /** This is a response to [call] */
      var typedResponse = response;
      var id = typedResponse.id;

      if (this.callbacks.has(id)) {
        var cb = this.callbacks.get(id);
        this.callbacks["delete"](id);

        if (typedResponse.result) {
          cb.resolve(typedResponse.result);
        } else {
          cb.reject(typedResponse.error);
        }
      } else {
        this.observer.onNotification(typedResponse);
      }
    } else if (response.hasOwnProperty('method')) {
      if (response.method === HMSSignalMethod.OFFER) {
        this.observer.onOffer(response.params);
      } else if (response.method === HMSSignalMethod.TRICKLE) {
        this.observer.onTrickle(response.params);
      } else if (response.method === HMSSignalMethod.SERVER_ERROR) {
        this.observer.onServerError(ErrorFactory.WebsocketMethodErrors.ServerErrors(Number(response.params.code), HMSAction.NONE, response.params.message));
      } else {
        this.observer.onNotification(response);
      }
    } else throw Error("WebSocket message has no 'method' or 'id' field, message=" + response);
  };

  _proto.pingPongLoop = /*#__PURE__*/function () {
    var _pingPongLoop = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee14(id) {
      var _this6 = this;

      var pingTimeout, pongTimeDiff;
      return runtime_1.wrap(function _callee14$(_context14) {
        while (1) {
          switch (_context14.prev = _context14.next) {
            case 0:
              pingTimeout = DEFAULT_SIGNAL_PING_TIMEOUT;

              if (!this.isConnected) {
                _context14.next = 6;
                break;
              }

              _context14.next = 4;
              return this.ping(pingTimeout);

            case 4:
              pongTimeDiff = _context14.sent;

              if (pongTimeDiff > pingTimeout) {
                HMSLogger.d(this.TAG, 'Pong timeout', {
                  id: id
                });

                if (this.id === id) {
                  this.isConnected = false;
                }
              } else {
                setTimeout(function () {
                  return _this6.pingPongLoop(id);
                }, SIGNAL_PING_INTERVAL);
              }

            case 6:
            case "end":
              return _context14.stop();
          }
        }
      }, _callee14, this);
    }));

    function pingPongLoop(_x18) {
      return _pingPongLoop.apply(this, arguments);
    }

    return pingPongLoop;
  }();

  _createClass(JsonRpcSignal, [{
    key: "isConnected",
    get: function get() {
      return this._isConnected;
    },
    set: function set(newValue) {
      HMSLogger.d(this.TAG, 'isConnected set', {
        id: this.id,
        old: this._isConnected,
        "new": newValue
      });
      if (this._isConnected === newValue) return;

      if (this._isConnected && !newValue) {
        // went offline
        this._isConnected = newValue;
        this.observer.onOffline();
      } else if (!this._isConnected && newValue) {
        // went online
        this._isConnected = newValue;
        this.observer.onOnline();
      }
    }
  }]);

  return JsonRpcSignal;
}();

var HMSAudioTrackSettingsBuilder = /*#__PURE__*/function () {
  function HMSAudioTrackSettingsBuilder() {
    this._volume = 1.0;
    this._codec = exports.HMSAudioCodec.OPUS;
    this._maxBitrate = 32;
    this._deviceId = 'default';
    this._advanced = [// @ts-ignore
    {
      googEchoCancellation: {
        exact: true
      }
    }, // @ts-ignore
    {
      googExperimentalEchoCancellation: {
        exact: true
      }
    }, // @ts-ignore
    {
      autoGainControl: {
        exact: true
      }
    }, // @ts-ignore
    {
      noiseSuppression: {
        exact: true
      }
    }, // @ts-ignore
    {
      googHighpassFilter: {
        exact: true
      }
    }, // @ts-ignore
    {
      googAudioMirroring: {
        exact: true
      }
    }];
  }

  var _proto = HMSAudioTrackSettingsBuilder.prototype;

  _proto.volume = function volume(_volume) {
    if (!(0.0 <= _volume && _volume <= 1.0)) throw Error('volume can only be in range [0.0, 1.0]');
    this._volume = _volume;
    return this;
  };

  _proto.codec = function codec(_codec) {
    this._codec = _codec;
    return this;
  };

  _proto.maxBitrate = function maxBitrate(_maxBitrate) {
    if (_maxBitrate <= 0) throw Error('maxBitrate should be >= 1');
    this._maxBitrate = _maxBitrate;
    return this;
  };

  _proto.deviceId = function deviceId(_deviceId) {
    // TODO: Validate if device-id is OK
    this._deviceId = _deviceId;
    return this;
  };

  _proto.advanced = function advanced(_advanced) {
    this._advanced = _advanced;
    return this;
  };

  _proto.build = function build() {
    return new HMSAudioTrackSettings(this._volume, this._codec, this._maxBitrate, this._deviceId, this._advanced);
  };

  return HMSAudioTrackSettingsBuilder;
}();
var HMSAudioTrackSettings = /*#__PURE__*/function () {
  function HMSAudioTrackSettings(volume, codec, maxBitrate, deviceId, advanced) {
    this.volume = volume;
    this.codec = codec;
    this.maxBitrate = maxBitrate;
    this.deviceId = deviceId;
    this.advanced = advanced;
  }

  var _proto2 = HMSAudioTrackSettings.prototype;

  _proto2.toConstraints = function toConstraints() {
    return {
      deviceId: this.deviceId,
      advanced: this.advanced
    };
  };

  _proto2.toAnalyticsProperties = function toAnalyticsProperties() {
    return {
      audio_bitrate: this.maxBitrate,
      audio_codec: this.codec
    };
  };

  return HMSAudioTrackSettings;
}();

var HMSVideoTrackSettingsBuilder = /*#__PURE__*/function () {
  function HMSVideoTrackSettingsBuilder() {
    this._width = 320;
    this._height = 180;
    this._codec = exports.HMSVideoCodec.VP8;
    this._maxFramerate = 30;
    this._maxBitrate = 150;
    this._advanced = [];
  }

  var _proto = HMSVideoTrackSettingsBuilder.prototype;

  _proto.setWidth = function setWidth(width) {
    this._width = width;
    return this;
  };

  _proto.setHeight = function setHeight(height) {
    this._height = height;
    return this;
  };

  _proto.codec = function codec(_codec) {
    this._codec = _codec;
    return this;
  };

  _proto.maxFramerate = function maxFramerate(_maxFramerate) {
    if (_maxFramerate <= 0) throw Error('maxFramerate should be >= 1');
    this._maxFramerate = _maxFramerate;
    return this;
  }
  /**
   * @param useDefault Ignored if maxBitrate is valid.
   * If true and maxBitrate is undefined - sets a default value.
   * If false and maxBitrate is undefined - sets undefined.
   */
  ;

  _proto.maxBitrate = function maxBitrate(_maxBitrate, useDefault) {
    if (useDefault === void 0) {
      useDefault = true;
    }

    if (typeof _maxBitrate === 'number' && _maxBitrate <= 0) throw Error('maxBitrate should be >= 1');
    this._maxBitrate = _maxBitrate;
    if (!this._maxBitrate && useDefault) this._maxBitrate = 150000;
    return this;
  };

  _proto.deviceId = function deviceId(_deviceId) {
    // TODO: Validate if device-id is OK
    this._deviceId = _deviceId;
    return this;
  };

  _proto.advanced = function advanced(_advanced) {
    this._advanced = _advanced;
    return this;
  };

  _proto.build = function build() {
    return new HMSVideoTrackSettings(this._width, this._height, this._codec, this._maxFramerate, this._deviceId, this._advanced, this._maxBitrate);
  };

  return HMSVideoTrackSettingsBuilder;
}();
var HMSVideoTrackSettings = /*#__PURE__*/function () {
  function HMSVideoTrackSettings(width, height, codec, maxFramerate, deviceId, advanced, maxBitrate) {
    this.width = width;
    this.height = height;
    this.codec = codec;
    this.maxFramerate = maxFramerate;
    this.maxBitrate = maxBitrate;
    this.deviceId = deviceId;
    this.advanced = advanced;
  }

  var _proto2 = HMSVideoTrackSettings.prototype;

  _proto2.toConstraints = function toConstraints() {
    return {
      width: this.width,
      height: this.height,
      frameRate: this.maxFramerate,
      deviceId: this.deviceId
    };
  };

  _proto2.toAnalyticsProperties = function toAnalyticsProperties() {
    return {
      width: this.width,
      height: this.height,
      video_bitrate: this.maxBitrate,
      framerate: this.maxFramerate,
      video_codec: this.codec
    };
  };

  return HMSVideoTrackSettings;
}();

var HMSTrackSettingsBuilder = /*#__PURE__*/function () {
  function HMSTrackSettingsBuilder() {
    this._video = new HMSVideoTrackSettingsBuilder().build();
    this._audio = new HMSAudioTrackSettingsBuilder().build();
    this._screen = new HMSVideoTrackSettingsBuilder().build();
    this._simulcast = false;
  }

  var _proto = HMSTrackSettingsBuilder.prototype;

  _proto.video = function video(_video) {
    this._video = _video;
    return this;
  };

  _proto.audio = function audio(_audio) {
    this._audio = _audio;
    return this;
  };

  _proto.screen = function screen(_screen) {
    this._screen = _screen;
    return this;
  };

  _proto.simulcast = function simulcast(enabled) {
    this._simulcast = enabled;
    return this;
  };

  _proto.build = function build() {
    if (this._audio === null && this._video === null) {
      throw ErrorFactory.TracksErrors.NothingToReturn(HMSAction.TRACK);
    }

    if (this._video === null && this._simulcast) {
      throw ErrorFactory.TracksErrors.InvalidVideoSettings(HMSAction.TRACK, 'Cannot enable simulcast when no video settings are provided');
    }

    return new HMSTrackSettings(this._video, this._audio, this._simulcast, this._screen || undefined);
  };

  return HMSTrackSettingsBuilder;
}();
var HMSTrackSettings = /*#__PURE__*/function () {
  function HMSTrackSettings(video, audio, simulcast, screen) {
    if (screen === void 0) {
      screen = null;
    }

    this.video = video;
    this.audio = audio;
    this.simulcast = simulcast;
    this.screen = screen;
  }

  var _proto2 = HMSTrackSettings.prototype;

  _proto2.toAnalyticsProperties = function toAnalyticsProperties() {
    var properties = {
      audio_enabled: this.audio !== null,
      video_enabled: this.video !== null
    };

    if (this.audio) {
      properties = _extends({}, this.audio.toAnalyticsProperties(), properties);
    }

    if (this.video) {
      properties = _extends({}, this.video.toAnalyticsProperties(), properties);
    }

    return properties;
  };

  return HMSTrackSettings;
}();

var HMSGetMediaActions;

(function (HMSGetMediaActions) {
  HMSGetMediaActions["AUDIO"] = "audio";
  HMSGetMediaActions["VIDEO"] = "video";
  HMSGetMediaActions["AV"] = "audio, video";
  HMSGetMediaActions["SCREEN"] = "screen";
})(HMSGetMediaActions || (HMSGetMediaActions = {}));
/**
 * # Edge Cases:
 * - Screenshare error: The problem is when block at OS level, chrome throws NotAllowedError(HMS code - 3001) while firefox throws NotFoundError(HMS code - 3002),
 * we will handle this internally and throw error as User block - 3001 and OS block - 3002 for all browsers.
 * Chrome -
 * User blocked - NotAllowedError - Permission denied
 * System blocked - NotAllowedError - Permission denied by system
 */


function convertMediaErrorToHMSException(err, deviceInfo) {
  var message = err.message.toLowerCase();
  /**
   * Note: Adapter detects all chromium browsers as 'chrome'
   */

  if (deviceInfo === 'screen' && adapter.browserDetails.browser === 'chrome' && err.name === 'NotAllowedError' && err.message.includes('denied by system')) {
    return ErrorFactory.TracksErrors.DeviceNotAvailable(HMSAction.TRACK, deviceInfo, err.message);
  }

  switch (err.name) {
    case 'OverconstrainedError':
      return ErrorFactory.TracksErrors.GenericTrack(HMSAction.TRACK, err.message);

    case 'NotAllowedError':
      return ErrorFactory.TracksErrors.CantAccessCaptureDevice(HMSAction.TRACK, deviceInfo, err.message);

    case 'NotFoundError':
      return ErrorFactory.TracksErrors.DeviceNotAvailable(HMSAction.TRACK, deviceInfo, err.message);

    case 'NotReadableError':
      return ErrorFactory.TracksErrors.DeviceInUse(HMSAction.TRACK, deviceInfo, err.message);

    case 'TypeError':
      return ErrorFactory.TracksErrors.NothingToReturn(HMSAction.TRACK, err.message);

    default:
      if (message.includes('device not found')) {
        return ErrorFactory.TracksErrors.DeviceNotAvailable(HMSAction.TRACK, deviceInfo, err.message);
      } else if (message.includes('permission denied')) {
        return ErrorFactory.TracksErrors.CantAccessCaptureDevice(HMSAction.TRACK, deviceInfo, err.message);
      } else {
        return ErrorFactory.TracksErrors.GenericTrack(HMSAction.TRACK, err.message);
      }

  }
}

function BuildGetMediaError(err, deviceInfo) {
  var exception = convertMediaErrorToHMSException(err, deviceInfo);
  exception.addNativeError(err);
  return exception;
}

function getAudioTrack(_x) {
  return _getAudioTrack.apply(this, arguments);
}

function _getAudioTrack() {
  _getAudioTrack = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(settings) {
    var stream;
    return runtime_1.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.prev = 0;
            _context.next = 3;
            return navigator.mediaDevices.getUserMedia({
              audio: settings ? settings.toConstraints() : false
            });

          case 3:
            stream = _context.sent;
            return _context.abrupt("return", stream.getAudioTracks()[0]);

          case 7:
            _context.prev = 7;
            _context.t0 = _context["catch"](0);
            throw BuildGetMediaError(_context.t0, HMSGetMediaActions.AUDIO);

          case 10:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[0, 7]]);
  }));
  return _getAudioTrack.apply(this, arguments);
}

function getVideoTrack(_x2) {
  return _getVideoTrack.apply(this, arguments);
} // To differentiate between normal track and empty track.

function _getVideoTrack() {
  _getVideoTrack = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(settings) {
    var stream;
    return runtime_1.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.prev = 0;
            _context2.next = 3;
            return navigator.mediaDevices.getUserMedia({
              video: settings ? settings.toConstraints() : false
            });

          case 3:
            stream = _context2.sent;
            return _context2.abrupt("return", stream.getVideoTracks()[0]);

          case 7:
            _context2.prev = 7;
            _context2.t0 = _context2["catch"](0);
            throw BuildGetMediaError(_context2.t0, HMSGetMediaActions.VIDEO);

          case 10:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[0, 7]]);
  }));
  return _getVideoTrack.apply(this, arguments);
}

function isEmptyTrack(track) {
  // Firefox gives '' as label for empty track(created from audio context)
  return 'canvas' in track || track.label === 'MediaStreamAudioDestinationNode' || track.label === '';
}
var blankCanvas; // the dimensions of the passed in track are used to create the empty video track
// a dummy change(toggling a pixel value) is done periodically to keep on sending bytes

function getEmptyVideoTrack(prevTrack) {
  var _prevTrack$getSetting, _prevTrack$getSetting2;

  var width = (prevTrack == null ? void 0 : (_prevTrack$getSetting = prevTrack.getSettings()) == null ? void 0 : _prevTrack$getSetting.width) || 320;
  var height = (prevTrack == null ? void 0 : (_prevTrack$getSetting2 = prevTrack.getSettings()) == null ? void 0 : _prevTrack$getSetting2.height) || 240;
  var frameRate = 10; // fps TODO: experiment, see if this can be reduced

  if (!blankCanvas) {
    var _blankCanvas$getConte;

    blankCanvas = Object.assign(document.createElement('canvas'), {
      width: width,
      height: height
    });
    (_blankCanvas$getConte = blankCanvas.getContext('2d')) == null ? void 0 : _blankCanvas$getConte.fillRect(0, 0, width, height);
  }

  var stream = blankCanvas.captureStream(frameRate);
  var emptyTrack = stream.getVideoTracks()[0];
  var intervalID = setInterval(function () {
    if (emptyTrack.readyState === 'ended') {
      clearInterval(intervalID);
      return;
    }

    var ctx = blankCanvas.getContext('2d');

    if (ctx) {
      var pixel = ctx.getImageData(0, 0, 1, 1).data;
      var red = pixel[0] === 0 ? 1 : 0; // toggle red in pixel

      ctx.fillStyle = "rgb(" + red + ", 0, 0)";
      ctx.fillRect(0, 0, 1, 1);
    }
  }, 1000 / frameRate);

  emptyTrack.onended = function () {
    clearInterval(intervalID);
  };

  emptyTrack.enabled = false;
  return emptyTrack;
}
function getEmptyAudioTrack() {
  var ctx = new AudioContext();
  var oscillator = ctx.createOscillator();
  var dst = oscillator.connect(ctx.createMediaStreamDestination());
  oscillator.start(); // @ts-expect-error

  var emptyTrack = dst.stream.getAudioTracks()[0];
  emptyTrack.enabled = false;
  return emptyTrack;
}

//   on<K extends EventKey<T>>(eventName: K, fn: EventReceiver<T[K]>): void;
//   off<K extends EventKey<T>>(eventName: K, fn: EventReceiver<T[K]>): void;
//   emit<K extends EventKey<T>>(eventName: K, params: T[K]): void;
// }

var TypedEventEmitter = /*#__PURE__*/function (_EventEmitter) {
  _inheritsLoose(TypedEventEmitter, _EventEmitter);

  function TypedEventEmitter() {
    return _EventEmitter.apply(this, arguments) || this;
  }

  var _proto = TypedEventEmitter.prototype;

  _proto.on = function on(eventName, fn) {
    return _EventEmitter.prototype.on.call(this, eventName, fn);
  };

  _proto.off = function off(eventName, fn) {
    return _EventEmitter.prototype.off.call(this, eventName, fn);
  };

  _proto.emit = function emit(eventName, params) {
    return _EventEmitter.prototype.emit.call(this, eventName, params);
  };

  _proto.listeners = function listeners(eventName) {
    return _EventEmitter.prototype.listeners.call(this, eventName);
  };

  return TypedEventEmitter;
}(EventEmitter.EventEmitter);

var THRESHOLD = 35;
var UPDATE_THRESHOLD = 5;
var TrackAudioLevelMonitor = /*#__PURE__*/function (_TypedEventEmitter) {
  _inheritsLoose(TrackAudioLevelMonitor, _TypedEventEmitter);

  function TrackAudioLevelMonitor(track) {
    var _this;

    _this = _TypedEventEmitter.call(this) || this;
    _this.track = track;
    _this.averaging = 0.99;
    _this.audioLevel = 0;
    _this.rawLevel = 0;

    _this.processVolume = function (event) {
      var input = event.inputBuffer.getChannelData(0); // Calculating root mean square

      var sum = 0.0;

      for (var i = 0; i < input.length; ++i) {
        sum += input[i] * input[i];
      }

      var rms = Math.sqrt(sum / input.length);
      _this.rawLevel = Math.max(rms, _this.rawLevel * _this.averaging);
    };

    _this.audioContext = new AudioContext();
    _this.audioSource = _this.audioContext.createMediaStreamSource(new MediaStream([_this.track.nativeTrack]));
    _this.processor = _this.audioContext.createScriptProcessor(512);

    _this.processor.addEventListener('audioprocess', _this.processVolume);

    _this.audioSource.connect(_this.processor);

    _this.processor.connect(_this.audioContext.destination);

    return _this;
  }

  var _proto = TrackAudioLevelMonitor.prototype;

  _proto.updateAudioLevel = function updateAudioLevel(value) {
    var audioLevel = Math.ceil(Math.min(value * 400, 100));

    if (audioLevel < this.audioLevel - UPDATE_THRESHOLD || audioLevel > this.audioLevel + UPDATE_THRESHOLD) {
      this.audioLevel = audioLevel > THRESHOLD ? audioLevel : 0;
      var audioLevelUpdate = this.audioLevel ? {
        track: this.track,
        audioLevel: this.audioLevel
      } : undefined;
      this.emit('AUDIO_LEVEL_UPDATE', audioLevelUpdate);
    }
  };

  _proto.start = function start() {
    var _this2 = this;

    var prev = -1;
    this.interval = window.setTimeout(function () {
      if (_this2.rawLevel !== prev) {
        // only send an update when there is a change
        prev = _this2.rawLevel;

        _this2.updateAudioLevel(_this2.rawLevel);
      }

      _this2.start();
    }, 1000);
  };

  _proto.stop = function stop() {
    this.updateAudioLevel(0);
    window.clearInterval(this.interval);
    this.interval = undefined;
  };

  return TrackAudioLevelMonitor;
}(TypedEventEmitter);

/**
 * A plugin implementing this interface can be registered with HMSLocalAudioTrack to transform, process or
 * analyze the local audio track.These can include applications like background noise removal, speech commands, live
 * analysis of audio etc. The below functions are required for the sdk to properly use the plugin, usually
 * the plugin would also be exposing some public functions of its own for the UI to control its working.
 */

(function (HMSAudioPluginType) {
  HMSAudioPluginType["TRANSFORM"] = "TRANSFORM";
  HMSAudioPluginType["ANALYZE"] = "ANALYZE";
})(exports.HMSAudioPluginType || (exports.HMSAudioPluginType = {}));

var DomainCategory;

(function (DomainCategory) {
  DomainCategory["CUSTOM"] = "CUSTOM";
  DomainCategory["LOCAL"] = "LOCAL";
  DomainCategory["HMS"] = "HMS";
})(DomainCategory || (DomainCategory = {}));

function getDomainCategory() {
  // this function gives us the domain category(sutom, hms , local) of the base url.
  // below if statement checks if it's running in a browser ; or if we can use 'window' safely
  if (isBrowser && window) {
    var baseurl = window.location.hostname;

    if (baseurl === 'localhost' || baseurl === '127.0.0.1') {
      return DomainCategory.LOCAL;
    }

    if (baseurl.includes('app.100ms.live')) {
      return DomainCategory.HMS;
    } else {
      return DomainCategory.CUSTOM;
    }
  }

  return DomainCategory.CUSTOM;
}

var domainCategory = /*#__PURE__*/getDomainCategory();

var AnalyticsEvent = /*#__PURE__*/function () {
  function AnalyticsEvent(_ref) {
    var name = _ref.name,
        level = _ref.level,
        properties = _ref.properties,
        includesPII = _ref.includesPII,
        timestamp = _ref.timestamp;
    this.name = name;
    this.level = level;
    this.includesPII = includesPII || false;
    this.properties = properties || {};
    this.timestamp = timestamp || new Date().getTime(); // Timestamp of generating the event
  }

  var _proto = AnalyticsEvent.prototype;

  _proto.toSignalParams = function toSignalParams() {
    return {
      name: this.name,
      info: _extends({}, this.properties, {
        timestamp: this.timestamp,
        domain: domainCategory
      }),
      timestamp: new Date().getTime()
    };
  };

  return AnalyticsEvent;
}();

var HMSAnalyticsLevel;

(function (HMSAnalyticsLevel) {
  HMSAnalyticsLevel[HMSAnalyticsLevel["VERBOSE"] = 0] = "VERBOSE";
  HMSAnalyticsLevel[HMSAnalyticsLevel["INFO"] = 1] = "INFO";
  HMSAnalyticsLevel[HMSAnalyticsLevel["ERROR"] = 2] = "ERROR";
  HMSAnalyticsLevel[HMSAnalyticsLevel["OFF"] = 3] = "OFF";
})(HMSAnalyticsLevel || (HMSAnalyticsLevel = {}));

var AnalyticsEventLevel;

(function (AnalyticsEventLevel) {
  AnalyticsEventLevel[AnalyticsEventLevel["VERBOSE"] = 0] = "VERBOSE";
  AnalyticsEventLevel[AnalyticsEventLevel["INFO"] = 1] = "INFO";
  AnalyticsEventLevel[AnalyticsEventLevel["ERROR"] = 2] = "ERROR";
  AnalyticsEventLevel[AnalyticsEventLevel["OFF"] = 3] = "OFF";
})(AnalyticsEventLevel || (AnalyticsEventLevel = {}));

var MediaPluginsAnalyticsFactory = /*#__PURE__*/function () {
  function MediaPluginsAnalyticsFactory() {}

  MediaPluginsAnalyticsFactory.failure = function failure(pluginName, error) {
    var name = 'mediaPlugin.failed';
    var level = AnalyticsEventLevel.ERROR;

    var properties = _extends({
      plugin_name: pluginName
    }, error.toAnalyticsProperties());

    return new AnalyticsEvent({
      name: name,
      level: level,
      properties: properties
    });
  };

  MediaPluginsAnalyticsFactory.audioPluginStats = function audioPluginStats(_ref) {
    var pluginName = _ref.pluginName,
        duration = _ref.duration,
        loadTime = _ref.loadTime;
    var name = 'mediaPlugin.stats';
    var level = AnalyticsEventLevel.INFO;
    var properties = {
      plugin_name: pluginName,
      duration: duration,
      load_time: loadTime
    };
    return new AnalyticsEvent({
      name: name,
      level: level,
      properties: properties
    });
  };

  MediaPluginsAnalyticsFactory.stats = function stats(_ref2) {
    var pluginName = _ref2.pluginName,
        duration = _ref2.duration,
        loadTime = _ref2.loadTime,
        avgPreProcessingTime = _ref2.avgPreProcessingTime,
        avgProcessingTime = _ref2.avgProcessingTime,
        inputFrameRate = _ref2.inputFrameRate,
        pluginFrameRate = _ref2.pluginFrameRate;
    var name = 'mediaPlugin.stats';
    var level = AnalyticsEventLevel.INFO;
    var properties = {
      plugin_name: pluginName,
      duration: duration,
      load_time: loadTime,
      avg_preprocessing_time: avgPreProcessingTime,
      avg_processing_time: avgProcessingTime,
      input_frame_rate: inputFrameRate,
      plugin_frame_rate: pluginFrameRate
    };
    return new AnalyticsEvent({
      name: name,
      level: level,
      properties: properties
    });
  };

  return MediaPluginsAnalyticsFactory;
}();

var TAG$3 = 'AnalyticsEventsService';
var AnalyticsEventsService = /*#__PURE__*/function () {
  function AnalyticsEventsService() {
    this.bufferSize = ANALYTICS_BUFFER_SIZE;
    this.transports = [];
    this.pendingEvents = [];
    this.level = HMSAnalyticsLevel.INFO;
  }

  var _proto = AnalyticsEventsService.prototype;

  _proto.addTransport = function addTransport(transport) {
    this.transports.push(transport);
  };

  _proto.removeTransport = function removeTransport(transport) {
    this.transports.splice(this.transports.indexOf(transport), 1);
  };

  _proto.queue = function queue(event) {
    if (event.level >= this.level) {
      this.pendingEvents.push(event);

      if (this.pendingEvents.length > this.bufferSize) {
        var removedEvent = this.pendingEvents.shift();
        HMSLogger.d(TAG$3, 'Max buffer size reached', 'Removed event to accommodate new events', removedEvent);
      }
    }

    return this;
  };

  _proto.flush = function flush() {
    var _this = this;

    if (this.transports.length === 0) {
      HMSLogger.w(TAG$3, 'No valid signalling API found to flush analytics');
      return;
    }

    try {
      var _loop = function _loop() {
        var event = _this.pendingEvents.shift();

        if (event) {
          _this.transports.forEach(function (transport) {
            return transport.sendEvent(event);
          });
        }
      };

      while (this.pendingEvents.length > 0) {
        _loop();
      }
    } catch (error) {
      HMSLogger.w(TAG$3, 'Flush Failed', error);
    }
  };

  return AnalyticsEventsService;
}();
var analyticsEventsService = /*#__PURE__*/new AnalyticsEventsService();

var TAG$4 = 'AudioPluginsAnalytics';
var AudioPluginsAnalytics = /*#__PURE__*/function () {
  function AudioPluginsAnalytics() {
    this.initTime = {};
    this.addedTimestamps = {};
    this.pluginAdded = {};
  }

  var _proto = AudioPluginsAnalytics.prototype;

  _proto.added = function added(name) {
    this.pluginAdded[name] = true;
    this.addedTimestamps[name] = Date.now();
    this.initTime[name] = 0;
  };

  _proto.removed = function removed(name) {
    //send stats
    if (this.pluginAdded[name]) {
      var stats = {
        pluginName: name,
        // duration in seconds
        duration: Math.floor((Date.now() - this.addedTimestamps[name]) / 1000),
        loadTime: this.initTime[name]
      }; //send stats

      analyticsEventsService.queue(MediaPluginsAnalyticsFactory.audioPluginStats(stats)).flush(); //clean the plugin details

      this.clean(name);
    }
  };

  _proto.failure = function failure(name, error) {
    // send failure event
    if (this.pluginAdded[name]) {
      analyticsEventsService.queue(MediaPluginsAnalyticsFactory.failure(name, error)).flush(); //clean the plugin details

      this.clean(name);
    }
  };

  _proto.initWithTime = /*#__PURE__*/function () {
    var _initWithTime = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(name, initFn) {
      var time, err;
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (!this.initTime[name]) {
                _context.next = 3;
                break;
              }

              HMSLogger.i(TAG$4, "Plugin Already loaded " + name + ", time it took: " + this.initTime[name]);
              return _context.abrupt("return");

            case 3:
              time = undefined;
              _context.prev = 4;
              _context.next = 7;
              return this.timeInMs(initFn);

            case 7:
              time = _context.sent;
              HMSLogger.i(TAG$4, "Time taken for Plugin " + name + " initialization : " + time);
              _context.next = 17;
              break;

            case 11:
              _context.prev = 11;
              _context.t0 = _context["catch"](4);
              //Failed during initialization of plugin(model loading etc...)
              err = ErrorFactory.MediaPluginErrors.InitFailed(HMSAction.AUDIO_PLUGINS, 'failed during initialization of plugin' + (_context.t0.message || _context.t0));
              HMSLogger.e(TAG$4, err);
              this.failure(name, err);
              throw err;

            case 17:
              if (time) {
                this.initTime[name] = time;
              }

            case 18:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this, [[4, 11]]);
    }));

    function initWithTime(_x, _x2) {
      return _initWithTime.apply(this, arguments);
    }

    return initWithTime;
  }();

  _proto.timeInMs = /*#__PURE__*/function () {
    var _timeInMs = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(fn) {
      var start;
      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              start = Date.now();
              _context2.next = 3;
              return fn();

            case 3:
              return _context2.abrupt("return", Math.floor(Date.now() - start));

            case 4:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));

    function timeInMs(_x3) {
      return _timeInMs.apply(this, arguments);
    }

    return timeInMs;
  }();

  _proto.clean = function clean(name) {
    delete this.addedTimestamps[name];
    delete this.initTime[name];
    delete this.pluginAdded[name];
  };

  return AudioPluginsAnalytics;
}();

var TAG$5 = 'AudioPluginsManager';
var HMSAudioPluginsManager = /*#__PURE__*/function () {
  function HMSAudioPluginsManager(track) {
    this.pluginAddInProgress = false;
    this.hmsTrack = track;
    this.plugins = [];
    this.pluginsMap = {};
    this.analytics = new AudioPluginsAnalytics();
  }

  var _proto = HMSAudioPluginsManager.prototype;

  _proto.getPlugins = function getPlugins() {
    return [].concat(this.plugins);
  };

  _proto.addPlugin = /*#__PURE__*/function () {
    var _addPlugin = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(plugin) {
      var name, err;
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (!this.pluginAddInProgress) {
                _context.next = 9;
                break;
              }

              name = plugin.getName == null ? void 0 : plugin.getName();

              if (!(!name || name === '')) {
                _context.next = 5;
                break;
              }

              HMSLogger.w('no name provided by the plugin');
              return _context.abrupt("return");

            case 5:
              err = ErrorFactory.MediaPluginErrors.AddAlreadyInProgress(HMSAction.AUDIO_PLUGINS, 'Add Plugin is already in Progress');
              this.analytics.failure(name, err);
              HMSLogger.w("can't add another plugin when previous add is in progress");
              throw err;

            case 9:
              this.pluginAddInProgress = true;
              _context.prev = 10;
              _context.next = 13;
              return this.addPluginInternal(plugin);

            case 13:
              _context.next = 18;
              break;

            case 15:
              _context.prev = 15;
              _context.t0 = _context["catch"](10);
              throw _context.t0;

            case 18:
              _context.prev = 18;
              this.pluginAddInProgress = false;
              return _context.finish(18);

            case 21:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this, [[10, 15, 18, 21]]);
    }));

    function addPlugin(_x) {
      return _addPlugin.apply(this, arguments);
    }

    return addPlugin;
  }();

  _proto.addPluginInternal = /*#__PURE__*/function () {
    var _addPluginInternal = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3(plugin) {
      var name, err;
      return runtime_1.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              name = plugin.getName == null ? void 0 : plugin.getName();

              if (!(!name || name === '')) {
                _context3.next = 4;
                break;
              }

              HMSLogger.w('no name provided by the plugin');
              return _context3.abrupt("return");

            case 4:
              if (!this.pluginsMap[name]) {
                _context3.next = 7;
                break;
              }

              HMSLogger.w(TAG$5, "plugin - " + plugin.getName() + " already added.");
              return _context3.abrupt("return");

            case 7:
              if (!(this.plugins.length > 0)) {
                _context3.next = 10;
                break;
              }

              HMSLogger.w(TAG$5, 'An audio plugin is already added, currently supporting only one plugin at a time'); //TODO: throw err here to notify UI

              return _context3.abrupt("return");

            case 10:
              if (plugin.isSupported()) {
                _context3.next = 15;
                break;
              }

              err = ErrorFactory.MediaPluginErrors.PlatformNotSupported(HMSAction.AUDIO_PLUGINS, 'platform not supported ');
              this.analytics.failure(name, err);
              HMSLogger.i(TAG$5, "Platform is not supported for plugin - " + plugin.getName());
              return _context3.abrupt("return");

            case 15:
              _context3.prev = 15;
              this.analytics.added(name);
              _context3.next = 19;
              return this.analytics.initWithTime(name, /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2() {
                return runtime_1.wrap(function _callee2$(_context2) {
                  while (1) {
                    switch (_context2.prev = _context2.next) {
                      case 0:
                        return _context2.abrupt("return", plugin.init());

                      case 1:
                      case "end":
                        return _context2.stop();
                    }
                  }
                }, _callee2);
              })));

            case 19:
              this.plugins.push(name);
              this.pluginsMap[name] = plugin;
              _context3.next = 23;
              return this.startPluginsProcess();

            case 23:
              _context3.next = 31;
              break;

            case 25:
              _context3.prev = 25;
              _context3.t0 = _context3["catch"](15);
              HMSLogger.e(TAG$5, 'failed to add plugin', _context3.t0);
              _context3.next = 30;
              return this.removePlugin(plugin);

            case 30:
              throw _context3.t0;

            case 31:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, this, [[15, 25]]);
    }));

    function addPluginInternal(_x2) {
      return _addPluginInternal.apply(this, arguments);
    }

    return addPluginInternal;
  }();

  _proto.removePlugin = /*#__PURE__*/function () {
    var _removePlugin = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4(plugin) {
      var name;
      return runtime_1.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              name = plugin.getName();

              if (this.pluginsMap[name]) {
                _context4.next = 4;
                break;
              }

              HMSLogger.w(TAG$5, "plugin - " + name + " not found to remove.");
              return _context4.abrupt("return");

            case 4:
              HMSLogger.i(TAG$5, "removing plugin " + name);
              this.removePluginEntry(name);

              if (!(this.plugins.length === 0)) {
                _context4.next = 10;
                break;
              }

              HMSLogger.i(TAG$5, "No plugins left, stopping plugins loop");
              _context4.next = 10;
              return this.stopPluginsProcess();

            case 10:
              if (this.intermediateNode) {
                this.intermediateNode.disconnect();
                this.intermediateNode = null;
              }

              plugin.stop();
              this.analytics.removed(name);

            case 13:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4, this);
    }));

    function removePlugin(_x3) {
      return _removePlugin.apply(this, arguments);
    }

    return removePlugin;
  }();

  _proto.removePluginEntry = function removePluginEntry(name) {
    var index = this.plugins.indexOf(name);

    if (index !== -1) {
      this.plugins.splice(index, 1);
    }

    if (this.pluginsMap[name]) {
      delete this.pluginsMap[name];
    }
  };

  _proto.cleanup = /*#__PURE__*/function () {
    var _cleanup = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee5() {
      var _this$outputTrack;

      var _iterator, _step, name;

      return runtime_1.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              _iterator = _createForOfIteratorHelperLoose(this.plugins);

            case 1:
              if ((_step = _iterator()).done) {
                _context5.next = 7;
                break;
              }

              name = _step.value;
              _context5.next = 5;
              return this.removePlugin(this.pluginsMap[name]);

            case 5:
              _context5.next = 1;
              break;

            case 7:
              // memory cleanup
              (_this$outputTrack = this.outputTrack) == null ? void 0 : _this$outputTrack.stop();

            case 8:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5, this);
    }));

    function cleanup() {
      return _cleanup.apply(this, arguments);
    }

    return cleanup;
  }();

  _proto.initElementsAndStream = function initElementsAndStream() {
    if (!this.audioContext) {
      this.audioContext = new AudioContext();
    }

    if (!this.sourceNode) {
      var audioStream = new MediaStream([this.hmsTrack.nativeTrack]);
      this.sourceNode = this.audioContext.createMediaStreamSource(audioStream);
    }

    if (!this.destinationNode) {
      this.destinationNode = this.audioContext.createMediaStreamDestination();
      this.outputTrack = this.destinationNode.stream.getAudioTracks()[0];
    }
  };

  _proto.startPluginsProcess = /*#__PURE__*/function () {
    var _startPluginsProcess = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee6() {
      return runtime_1.wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              this.initElementsAndStream();

              if (this.audioContext) {
                _context6.next = 4;
                break;
              }

              HMSLogger.w(TAG$5, "Audio context is not defined");
              return _context6.abrupt("return");

            case 4:
              _context6.prev = 4;
              _context6.next = 7;
              return this.hmsTrack.setProcessedTrack(this.outputTrack);

            case 7:
              _context6.next = 13;
              break;

            case 9:
              _context6.prev = 9;
              _context6.t0 = _context6["catch"](4);
              HMSLogger.e(TAG$5, 'error in setting processed track', _context6.t0);
              throw _context6.t0;

            case 13:
              _context6.prev = 13;
              _context6.next = 16;
              return this.processAudioThroughPlugins();

            case 16:
              _context6.next = 22;
              break;

            case 18:
              _context6.prev = 18;
              _context6.t1 = _context6["catch"](13);
              HMSLogger.e(TAG$5, 'error in processing audio plugins', _context6.t1);
              throw _context6.t1;

            case 22:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6, this, [[4, 9], [13, 18]]);
    }));

    function startPluginsProcess() {
      return _startPluginsProcess.apply(this, arguments);
    }

    return startPluginsProcess;
  }();

  _proto.processAudioThroughPlugins = /*#__PURE__*/function () {
    var _processAudioThroughPlugins = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee7() {
      var _iterator2, _step2, name, plugin;

      return runtime_1.wrap(function _callee7$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              _iterator2 = _createForOfIteratorHelperLoose(this.plugins);

            case 1:
              if ((_step2 = _iterator2()).done) {
                _context7.next = 29;
                break;
              }

              name = _step2.value;
              plugin = this.pluginsMap[name];

              if (plugin) {
                _context7.next = 6;
                break;
              }

              return _context7.abrupt("continue", 27);

            case 6:
              _context7.prev = 6;

              if (!this.audioContext) {
                _context7.next = 11;
                break;
              }

              _context7.next = 10;
              return plugin.processAudioTrack(this.audioContext, this.intermediateNode || this.sourceNode);

            case 10:
              this.intermediateNode = _context7.sent;

            case 11:
              _context7.next = 18;
              break;

            case 13:
              _context7.prev = 13;
              _context7.t0 = _context7["catch"](6);
              //TODO error happened on processing of plugin notify UI
              HMSLogger.e(TAG$5, "error in processing plugin " + name, _context7.t0); //remove plugin from loop and stop analytics for it

              _context7.next = 18;
              return this.removePlugin(plugin);

            case 18:
              _context7.prev = 18;

              if (this.intermediateNode && this.destinationNode && this.intermediateNode.context === this.destinationNode.context) {
                this.intermediateNode.connect(this.destinationNode);
              }

              _context7.next = 27;
              break;

            case 22:
              _context7.prev = 22;
              _context7.t1 = _context7["catch"](18);
              HMSLogger.e(TAG$5, "error in processing plugin " + name, _context7.t1); //remove plugin from loop and stop analytics for it

              _context7.next = 27;
              return this.removePlugin(plugin);

            case 27:
              _context7.next = 1;
              break;

            case 29:
            case "end":
              return _context7.stop();
          }
        }
      }, _callee7, this, [[6, 13], [18, 22]]);
    }));

    function processAudioThroughPlugins() {
      return _processAudioThroughPlugins.apply(this, arguments);
    }

    return processAudioThroughPlugins;
  }();

  _proto.stopPluginsProcess = /*#__PURE__*/function () {
    var _stopPluginsProcess = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee8() {
      return runtime_1.wrap(function _callee8$(_context8) {
        while (1) {
          switch (_context8.prev = _context8.next) {
            case 0:
              _context8.next = 2;
              return this.hmsTrack.setProcessedTrack(undefined);

            case 2:
            case "end":
              return _context8.stop();
          }
        }
      }, _callee8, this);
    }));

    function stopPluginsProcess() {
      return _stopPluginsProcess.apply(this, arguments);
    }

    return stopPluginsProcess;
  }();

  return HMSAudioPluginsManager;
}();

var LocalStorage = /*#__PURE__*/function () {
  function LocalStorage(key) {
    this.key = key;
    this.storage = null;
  }
  /**
   * localstorage is not available in SSR, so get it only at time of use
   */


  var _proto = LocalStorage.prototype;

  _proto.getStorage = function getStorage() {
    if (isBrowser) {
      this.storage = window.localStorage;
    }

    return this.storage;
  };

  _proto.get = function get() {
    var _this$getStorage;

    var stringItem = (_this$getStorage = this.getStorage()) == null ? void 0 : _this$getStorage.getItem(this.key);

    if (!stringItem) {
      return;
    }

    var item = JSON.parse(stringItem);
    return item;
  };

  _proto.set = function set(value) {
    var _this$getStorage2;

    var stringValue = JSON.stringify(value);
    (_this$getStorage2 = this.getStorage()) == null ? void 0 : _this$getStorage2.setItem(this.key, stringValue);
  };

  _proto.clear = function clear() {
    var _this$getStorage3;

    (_this$getStorage3 = this.getStorage()) == null ? void 0 : _this$getStorage3.removeItem(this.key);
  };

  return LocalStorage;
}();

/**
 * This class is to manage storing and retrieving selected devices
 * from localstorage
 * @internal
 */

var DeviceStorage = /*#__PURE__*/function () {
  function DeviceStorage() {
    this.storage = new LocalStorage('hms-device-selection');
    this.remember = false;
  }

  var _proto = DeviceStorage.prototype;

  _proto.setDevices = function setDevices(devices) {
    this.devices = devices;
  };

  _proto.rememberDevices = function rememberDevices(value) {
    this.remember = value;
  }
  /**
   * This will update the passed in type value in storage
   * @param {string} type - One of audioInput | videoInput | audioOutput
   * @param {DeviceInfo} param
   * @returns {void}
   */
  ;

  _proto.updateSelection = function updateSelection(type, _ref) {
    var _this = this;

    var deviceId = _ref.deviceId,
        groupId = _ref.groupId;

    if (!this.devices || !this.remember) {
      return;
    }

    var newSelection = this.devices[type].find(function (device) {
      return _this.isSame({
        deviceId: deviceId,
        groupId: groupId
      }, device);
    });

    if (!newSelection) {
      return;
    }

    var selectedDevices = this.storage.get() || {};

    if (type === 'audioOutput') {
      selectedDevices[type] = newSelection;
    } else {
      selectedDevices[type] = newSelection;
    }

    this.storage.set(selectedDevices);
  };

  _proto.getSelection = function getSelection() {
    if (!this.remember) {
      return undefined;
    }

    return this.storage.get();
  };

  _proto.cleanup = function cleanup() {
    this.remember = false;
    this.devices = undefined;
  };

  _proto.isSame = function isSame(current, device) {
    // Safari doesn't give groupId from nativeTrack. Check if groupId's match or current groupId is not present
    return current.deviceId === device.deviceId && (current.groupId === device.groupId || !current.groupId);
  };

  return DeviceStorage;
}();

var DeviceStorageManager = /*#__PURE__*/new DeviceStorage();

function generateHasPropertyChanged(newSettings, oldSettings) {
  return function hasChanged(prop) {
    return prop in newSettings && newSettings[prop] !== oldSettings[prop];
  };
}

var TAG$6 = 'HMSLocalAudioTrack';
var HMSLocalAudioTrack = /*#__PURE__*/function (_HMSAudioTrack) {
  _inheritsLoose(HMSLocalAudioTrack, _HMSAudioTrack);

  function HMSLocalAudioTrack(stream, track, source, settings) {
    var _this;

    if (settings === void 0) {
      settings = new HMSAudioTrackSettingsBuilder().build();
    }

    _this = _HMSAudioTrack.call(this, stream, track, source) || this;
    stream.tracks.push(_assertThisInitialized(_this));
    _this.settings = settings;
    _this.pluginsManager = new HMSAudioPluginsManager(_assertThisInitialized(_this));
    _this.publishedTrackId = _this.trackId;

    _this.setFirstTrackId(track.id);

    return _this;
  }

  var _proto = HMSLocalAudioTrack.prototype;

  _proto.replaceTrackWith = /*#__PURE__*/function () {
    var _replaceTrackWith = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(settings) {
      var prevTrack, prevState, newTrack, localStream;
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              prevTrack = this.nativeTrack;
              prevState = this.enabled;
              /**
               * Stop has to be called before getting newTrack as it would cause NotReadableError
               */

              prevTrack == null ? void 0 : prevTrack.stop();
              _context.next = 5;
              return getAudioTrack(settings);

            case 5:
              newTrack = _context.sent;
              newTrack.enabled = prevState;
              localStream = this.stream; // change nativeTrack so plugin can start its work

              _context.next = 10;
              return localStream.replaceSenderTrack(prevTrack, this.processedTrack || newTrack);

            case 10:
              _context.next = 12;
              return localStream.replaceStreamTrack(prevTrack, newTrack);

            case 12:
              this.nativeTrack = newTrack;

            case 13:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function replaceTrackWith(_x) {
      return _replaceTrackWith.apply(this, arguments);
    }

    return replaceTrackWith;
  }();

  _proto.setEnabled = /*#__PURE__*/function () {
    var _setEnabled = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(value) {
      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (!(value === this.enabled)) {
                _context2.next = 2;
                break;
              }

              return _context2.abrupt("return");

            case 2:
              if (!(value && isEmptyTrack(this.nativeTrack))) {
                _context2.next = 5;
                break;
              }

              _context2.next = 5;
              return this.replaceTrackWith(this.settings);

            case 5:
              _context2.next = 7;
              return _HMSAudioTrack.prototype.setEnabled.call(this, value);

            case 7:
              this.stream.trackUpdate(this);

            case 8:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));

    function setEnabled(_x2) {
      return _setEnabled.apply(this, arguments);
    }

    return setEnabled;
  }();

  _proto.setSettings = /*#__PURE__*/function () {
    var _setSettings = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3(settings, internal) {
      var _this$settings$settin, volume, codec, maxBitrate, deviceId, advanced, newSettings, stream, hasPropertyChanged, _this$audioLevelMonit, isLevelMonitored, eventListeners;

      return runtime_1.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              if (internal === void 0) {
                internal = false;
              }

              _this$settings$settin = _extends({}, this.settings, settings), volume = _this$settings$settin.volume, codec = _this$settings$settin.codec, maxBitrate = _this$settings$settin.maxBitrate, deviceId = _this$settings$settin.deviceId, advanced = _this$settings$settin.advanced;
              newSettings = new HMSAudioTrackSettings(volume, codec, maxBitrate, deviceId, advanced);

              if (!isEmptyTrack(this.nativeTrack)) {
                _context3.next = 6;
                break;
              }

              // if it is an empty track, cache the settings for when it is unmuted
              this.settings = newSettings;
              return _context3.abrupt("return");

            case 6:
              stream = this.stream;
              hasPropertyChanged = generateHasPropertyChanged(settings, this.settings);

              if (!hasPropertyChanged('deviceId')) {
                _context3.next = 17;
                break;
              }

              isLevelMonitored = Boolean(this.audioLevelMonitor);
              eventListeners = (_this$audioLevelMonit = this.audioLevelMonitor) == null ? void 0 : _this$audioLevelMonit.listeners('AUDIO_LEVEL_UPDATE');
              HMSLogger.d(TAG$6, 'Device change', {
                isLevelMonitored: isLevelMonitored
              });
              isLevelMonitored && this.destroyAudioLevelMonitor();
              _context3.next = 15;
              return this.replaceTrackWith(newSettings);

            case 15:
              isLevelMonitored && this.initAudioLevelMonitor(eventListeners);

              if (!internal) {
                DeviceStorageManager.updateSelection('audioInput', {
                  deviceId: settings.deviceId,
                  groupId: this.nativeTrack.getSettings().groupId
                });
              }

            case 17:
              if (!hasPropertyChanged('maxBitrate')) {
                _context3.next = 20;
                break;
              }

              _context3.next = 20;
              return stream.setMaxBitrate(newSettings.maxBitrate, this);

            case 20:
              if (!hasPropertyChanged('advanced')) {
                _context3.next = 23;
                break;
              }

              _context3.next = 23;
              return this.nativeTrack.applyConstraints(newSettings.toConstraints());

            case 23:
              this.settings = newSettings;

            case 24:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, this);
    }));

    function setSettings(_x3, _x4) {
      return _setSettings.apply(this, arguments);
    }

    return setSettings;
  }()
  /**
   * @see HMSAudioPlugin
   */
  ;

  _proto.getPlugins = function getPlugins() {
    return this.pluginsManager.getPlugins();
  }
  /**
   * @see HMSAudioPlugin
   */
  ;

  _proto.addPlugin =
  /*#__PURE__*/
  function () {
    var _addPlugin = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4(plugin) {
      return runtime_1.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              return _context4.abrupt("return", this.pluginsManager.addPlugin(plugin));

            case 1:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4, this);
    }));

    function addPlugin(_x5) {
      return _addPlugin.apply(this, arguments);
    }

    return addPlugin;
  }()
  /**
   * @see HMSAudioPlugin
   */
  ;

  _proto.removePlugin =
  /*#__PURE__*/
  function () {
    var _removePlugin = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee5(plugin) {
      return runtime_1.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              return _context5.abrupt("return", this.pluginsManager.removePlugin(plugin));

            case 1:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5, this);
    }));

    function removePlugin(_x6) {
      return _removePlugin.apply(this, arguments);
    }

    return removePlugin;
  }()
  /**
   * @internal
   */
  ;

  _proto.setProcessedTrack =
  /*#__PURE__*/
  function () {
    var _setProcessedTrack = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee6(processedTrack) {
      return runtime_1.wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              if (processedTrack) {
                _context6.next = 6;
                break;
              }

              if (!this.processedTrack) {
                _context6.next = 4;
                break;
              }

              _context6.next = 4;
              return this.stream.replaceSenderTrack(this.processedTrack, this.nativeTrack);

            case 4:
              this.processedTrack = undefined;
              return _context6.abrupt("return");

            case 6:
              if (!(processedTrack !== this.processedTrack)) {
                _context6.next = 15;
                break;
              }

              if (!this.processedTrack) {
                _context6.next = 12;
                break;
              }

              _context6.next = 10;
              return this.stream.replaceSenderTrack(this.processedTrack, processedTrack);

            case 10:
              _context6.next = 14;
              break;

            case 12:
              _context6.next = 14;
              return this.stream.replaceSenderTrack(this.nativeTrack, processedTrack);

            case 14:
              this.processedTrack = processedTrack;

            case 15:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6, this);
    }));

    function setProcessedTrack(_x7) {
      return _setProcessedTrack.apply(this, arguments);
    }

    return setProcessedTrack;
  }();

  _proto.initAudioLevelMonitor = function initAudioLevelMonitor(listeners) {
    var _this2 = this;

    HMSLogger.d(TAG$6, 'Monitor Audio Level for', this, this.getMediaTrackSettings().deviceId);
    this.audioLevelMonitor = new TrackAudioLevelMonitor(this);
    listeners == null ? void 0 : listeners.forEach(function (listener) {
      var _this2$audioLevelMoni;

      return (_this2$audioLevelMoni = _this2.audioLevelMonitor) == null ? void 0 : _this2$audioLevelMoni.on('AUDIO_LEVEL_UPDATE', listener);
    });
    this.audioLevelMonitor.start();
  };

  _proto.destroyAudioLevelMonitor = function destroyAudioLevelMonitor() {
    var _this$audioLevelMonit2;

    (_this$audioLevelMonit2 = this.audioLevelMonitor) == null ? void 0 : _this$audioLevelMonit2.stop();
    this.audioLevelMonitor = undefined;
  };

  _proto.cleanup = /*#__PURE__*/function () {
    var _cleanup = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee7() {
      var _this$processedTrack;

      return runtime_1.wrap(function _callee7$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              _HMSAudioTrack.prototype.cleanup.call(this);

              _context7.next = 3;
              return this.pluginsManager.cleanup();

            case 3:
              (_this$processedTrack = this.processedTrack) == null ? void 0 : _this$processedTrack.stop();
              this.destroyAudioLevelMonitor();

            case 5:
            case "end":
              return _context7.stop();
          }
        }
      }, _callee7, this);
    }));

    function cleanup() {
      return _cleanup.apply(this, arguments);
    }

    return cleanup;
  }()
  /**
   * @internal
   * published track id will be different in case there was some processing done using plugins.
   */
  ;

  _proto.getTrackIDBeingSent = function getTrackIDBeingSent() {
    return this.processedTrack ? this.processedTrack.id : this.nativeTrack.id;
  };

  return HMSLocalAudioTrack;
}(HMSAudioTrack);

/**
 * Specifies the type of the plugin a transforming plugin will get an output canvas to give the resulting
 * transformation. While an analyzing plugin will only be passed the input canvas.
 */

(function (HMSVideoPluginType) {
  HMSVideoPluginType["TRANSFORM"] = "TRANSFORM";
  HMSVideoPluginType["ANALYZE"] = "ANALYZE";
})(exports.HMSVideoPluginType || (exports.HMSVideoPluginType = {}));

/**
 * Delay for a @see ms amount of time
 * @param ms -- time in milliseconds
 */
function sleep(ms) {
  if (ms < 0) throw Error('`ms` should be a positive integer');
  return new Promise(function (resolve) {
    return setTimeout(resolve, ms);
  });
}
/**
 * Debounce Fn - Function to limit the number of executions of the passed in
 * function in a given time duration
 * @param fn Function to be called
 * @param delay time by which the function execution has to be delayed
 * @returns {void}
 */

function debounce(fn, delay) {
  if (delay === void 0) {
    delay = 300;
  }

  var timer;
  return function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    clearTimeout(timer);
    timer = undefined; //@ts-ignore

    var context = this;
    timer = setTimeout(function () {
      fn.apply(context, args);
    }, delay);
  };
}

var RunningAverage = /*#__PURE__*/function () {
  function RunningAverage() {
    this.total = 0;
    this.count = 0;
  }

  var _proto = RunningAverage.prototype;

  _proto.add = function add(item) {
    this.count++;
    this.total += item;
  };

  _proto.getAvg = function getAvg() {
    return Math.floor(this.total / this.count);
  };

  _proto.reset = function reset() {
    this.total = 0;
    this.count = 0;
  };

  return RunningAverage;
}();

var TAG$7 = 'VideoPluginsAnalytics';
var VideoPluginsAnalytics = /*#__PURE__*/function () {
  function VideoPluginsAnalytics() {
    this.initTime = {};
    this.preProcessingAvgs = new RunningAverage();
    this.addedTimestamps = {};
    this.processingAvgs = {};
    this.pluginAdded = {};
    this.pluginInputFrameRate = {};
    this.pluginFrameRate = {};
  }

  var _proto = VideoPluginsAnalytics.prototype;

  _proto.added = function added(name, inputFrameRate, pluginFrameRate) {
    this.pluginAdded[name] = true;
    this.addedTimestamps[name] = Date.now();
    this.initTime[name] = 0;
    this.processingAvgs[name] = new RunningAverage();
    this.pluginInputFrameRate[name] = inputFrameRate;
    this.pluginFrameRate[name] = pluginFrameRate || inputFrameRate;
  };

  _proto.removed = function removed(name) {
    //send stats
    if (this.pluginAdded[name]) {
      var _this$processingAvgs$;

      var stats = {
        pluginName: name,
        // duration in seconds
        duration: Math.floor((Date.now() - this.addedTimestamps[name]) / 1000),
        loadTime: this.initTime[name],
        avgPreProcessingTime: this.preProcessingAvgs.getAvg(),
        avgProcessingTime: (_this$processingAvgs$ = this.processingAvgs[name]) == null ? void 0 : _this$processingAvgs$.getAvg(),
        inputFrameRate: this.pluginInputFrameRate[name],
        pluginFrameRate: this.pluginFrameRate[name]
      }; //send stats

      analyticsEventsService.queue(MediaPluginsAnalyticsFactory.stats(stats)).flush(); //clean the plugin details

      this.clean(name);
    }
  };

  _proto.failure = function failure(name, error) {
    // send failure event
    if (this.pluginAdded[name]) {
      analyticsEventsService.queue(MediaPluginsAnalyticsFactory.failure(name, error)).flush(); //clean the plugin details

      this.clean(name);
    }
  };

  _proto.initWithTime = /*#__PURE__*/function () {
    var _initWithTime = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(name, initFn) {
      var time, err;
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (!this.initTime[name]) {
                _context.next = 3;
                break;
              }

              HMSLogger.i(TAG$7, "Plugin Already loaded " + name + ", time it took: " + this.initTime[name]);
              return _context.abrupt("return");

            case 3:
              time = undefined;
              _context.prev = 4;
              _context.next = 7;
              return this.timeInMs(initFn);

            case 7:
              time = _context.sent;
              HMSLogger.i(TAG$7, "Time taken for Plugin " + name + " initialization : " + time);
              _context.next = 17;
              break;

            case 11:
              _context.prev = 11;
              _context.t0 = _context["catch"](4);
              //Failed during initialization of plugin(model loading etc...)
              err = ErrorFactory.MediaPluginErrors.InitFailed(HMSAction.VIDEO_PLUGINS, 'failed during initialization of plugin' + (_context.t0.message || _context.t0));
              HMSLogger.e(TAG$7, err);
              this.failure(name, err);
              throw err;

            case 17:
              if (time) {
                this.initTime[name] = time;
              }

            case 18:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this, [[4, 11]]);
    }));

    function initWithTime(_x, _x2) {
      return _initWithTime.apply(this, arguments);
    }

    return initWithTime;
  }();

  _proto.preProcessWithTime = /*#__PURE__*/function () {
    var _preProcessWithTime = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(preProcessFn) {
      var time;
      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return this.timeInMs(preProcessFn);

            case 2:
              time = _context2.sent;
              this.preProcessingAvgs.add(time);

            case 4:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));

    function preProcessWithTime(_x3) {
      return _preProcessWithTime.apply(this, arguments);
    }

    return preProcessWithTime;
  }();

  _proto.processWithTime = /*#__PURE__*/function () {
    var _processWithTime = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3(name, processFn) {
      var time, err, _this$processingAvgs$2;

      return runtime_1.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              time = undefined;
              _context3.prev = 1;
              _context3.next = 4;
              return this.timeInMs(processFn);

            case 4:
              time = _context3.sent;
              _context3.next = 13;
              break;

            case 7:
              _context3.prev = 7;
              _context3.t0 = _context3["catch"](1);
              //Failed during processing of plugin
              err = ErrorFactory.MediaPluginErrors.ProcessingFailed(HMSAction.VIDEO_PLUGINS, 'Failed during processing of plugin' + (_context3.t0.message || _context3.t0));
              HMSLogger.e(TAG$7, err);
              this.failure(name, err);
              throw err;

            case 13:
              if (time) {
                (_this$processingAvgs$2 = this.processingAvgs[name]) == null ? void 0 : _this$processingAvgs$2.add(time);
              }

            case 14:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, this, [[1, 7]]);
    }));

    function processWithTime(_x4, _x5) {
      return _processWithTime.apply(this, arguments);
    }

    return processWithTime;
  }();

  _proto.timeInMs = /*#__PURE__*/function () {
    var _timeInMs = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4(fn) {
      var start;
      return runtime_1.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              start = Date.now();
              _context4.next = 3;
              return fn();

            case 3:
              return _context4.abrupt("return", Math.floor(Date.now() - start));

            case 4:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    }));

    function timeInMs(_x6) {
      return _timeInMs.apply(this, arguments);
    }

    return timeInMs;
  }();

  _proto.clean = function clean(name) {
    delete this.addedTimestamps[name];
    delete this.initTime[name];
    delete this.processingAvgs[name];
    delete this.pluginAdded[name];
    delete this.pluginInputFrameRate[name];
    delete this.pluginFrameRate[name];
  };

  return VideoPluginsAnalytics;
}();

var DEFAULT_FRAME_RATE = 24;
var TAG$8 = 'VideoPluginsManager';
/**
 * This class manages applying different plugins on a local video track. Plugins which need to modify the video
 * are called in the order they were added. Plugins which do not need to modify the video frames are called
 * with the original input.
 *
 * Concepts -
 * Video Plugin - A module which can take in input video painted on a canvas, do some processing on it and optionally
 * render its output on a passed in output canvas which will be shown in the UI.
 *
 * frameRate - the frame rate of the input video as present in track.getSettings, this is the rate at which new frames
 * are being produced and the rate we need to maintain in output as well.
 *
 * pluginFrameRate - this is the rate at which the plugin is supposed to do its processing. The processing can be an
 * expensive operation and can result in high usage of resources like CPU. This rate would usually be lower than the
 * real frame rate.
 *
 * pluginsLoop - a loop is run at framerate in this class, on each loop if the original track is unmuted all added
 * plugins are called one by one in the order they were called.
 *
 * @see HMSVideoPlugin
 */

var HMSVideoPluginsManager = /*#__PURE__*/function () {
  function HMSVideoPluginsManager(track) {
    /**
     * plugins loop is the loop in which all plugins are applied
     */
    this.pluginsLoopRunning = false;
    this.pluginsLoopState = 'paused';
    this.pluginAddInProgress = false;
    this.hmsTrack = track;
    this.plugins = [];
    this.pluginsMap = {};
    this.pluginNumFramesToSkip = {};
    this.pluginNumFramesSkipped = {};
    this.analytics = new VideoPluginsAnalytics();
  }

  var _proto = HMSVideoPluginsManager.prototype;

  _proto.getPlugins = function getPlugins() {
    return [].concat(this.plugins);
  }
  /**
   * @param plugin
   * @param pluginFrameRate
   */
  ;

  _proto.addPlugin =
  /*#__PURE__*/
  function () {
    var _addPlugin = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(plugin, pluginFrameRate) {
      var name, err;
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (!this.pluginAddInProgress) {
                _context.next = 9;
                break;
              }

              name = plugin.getName == null ? void 0 : plugin.getName();

              if (!(!name || name === '')) {
                _context.next = 5;
                break;
              }

              HMSLogger.w('no name provided by the plugin');
              return _context.abrupt("return");

            case 5:
              err = ErrorFactory.MediaPluginErrors.AddAlreadyInProgress(HMSAction.VIDEO_PLUGINS, 'Add Plugin is already in Progress');
              this.analytics.failure(name, err);
              HMSLogger.w("can't add another plugin when previous add is in progress");
              throw err;

            case 9:
              this.pluginAddInProgress = true;
              _context.prev = 10;
              _context.next = 13;
              return this.addPluginInternal(plugin, pluginFrameRate);

            case 13:
              _context.next = 18;
              break;

            case 15:
              _context.prev = 15;
              _context.t0 = _context["catch"](10);
              throw _context.t0;

            case 18:
              _context.prev = 18;
              this.pluginAddInProgress = false;
              return _context.finish(18);

            case 21:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this, [[10, 15, 18, 21]]);
    }));

    function addPlugin(_x, _x2) {
      return _addPlugin.apply(this, arguments);
    }

    return addPlugin;
  }();

  _proto.addPluginInternal = /*#__PURE__*/function () {
    var _addPluginInternal = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3(plugin, pluginFrameRate) {
      var name, _this$hmsTrack$getMed, width, height, inputFrameRate, numFramesToSkip, err;

      return runtime_1.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              name = plugin.getName == null ? void 0 : plugin.getName();

              if (!(!name || name === '')) {
                _context3.next = 4;
                break;
              }

              HMSLogger.w('no name provided by the plugin');
              return _context3.abrupt("return");

            case 4:
              if (!this.pluginsMap[name]) {
                _context3.next = 7;
                break;
              }

              HMSLogger.w(TAG$8, "plugin - " + plugin.getName() + " already added.");
              return _context3.abrupt("return");

            case 7:
              _this$hmsTrack$getMed = this.hmsTrack.getMediaTrackSettings(), width = _this$hmsTrack$getMed.width, height = _this$hmsTrack$getMed.height;

              if (!(!width || !height || width <= 0 || height <= 0)) {
                _context3.next = 11;
                break;
              }

              HMSLogger.i(TAG$8, 'Track width/height is not valid');
              return _context3.abrupt("return");

            case 11:
              //TODO: assuming this inputFrameRate from getMediaTrackSettings will not change once set
              //TODO: even if it changes will not have the info/params to know the change
              inputFrameRate = this.hmsTrack.getMediaTrackSettings().frameRate || DEFAULT_FRAME_RATE;
              numFramesToSkip = 0;

              if (pluginFrameRate && pluginFrameRate > 0) {
                HMSLogger.i(TAG$8, "adding plugin " + plugin.getName() + " with framerate " + pluginFrameRate);

                if (pluginFrameRate < inputFrameRate) {
                  numFramesToSkip = Math.ceil(inputFrameRate / pluginFrameRate) - 1;
                }

                this.analytics.added(name, inputFrameRate, pluginFrameRate);
              } else {
                HMSLogger.i(TAG$8, "adding plugin " + plugin.getName());
                this.analytics.added(name, inputFrameRate);
              }

              HMSLogger.i(TAG$8, 'numFrames to skip processing', numFramesToSkip);
              this.pluginNumFramesToSkip[name] = numFramesToSkip;
              this.pluginNumFramesSkipped[name] = numFramesToSkip;

              if (plugin.isSupported()) {
                _context3.next = 22;
                break;
              }

              err = ErrorFactory.MediaPluginErrors.PlatformNotSupported(HMSAction.VIDEO_PLUGINS, 'platform not supported ');
              this.analytics.failure(name, err);
              HMSLogger.i(TAG$8, "Platform is not supported for plugin - " + plugin.getName());
              return _context3.abrupt("return");

            case 22:
              _context3.prev = 22;
              _context3.next = 25;
              return this.analytics.initWithTime(name, /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2() {
                return runtime_1.wrap(function _callee2$(_context2) {
                  while (1) {
                    switch (_context2.prev = _context2.next) {
                      case 0:
                        _context2.next = 2;
                        return plugin.init();

                      case 2:
                        return _context2.abrupt("return", _context2.sent);

                      case 3:
                      case "end":
                        return _context2.stop();
                    }
                  }
                }, _callee2);
              })));

            case 25:
              this.plugins.push(name);
              this.pluginsMap[name] = plugin;
              _context3.next = 29;
              return this.startPluginsLoop();

            case 29:
              _context3.next = 37;
              break;

            case 31:
              _context3.prev = 31;
              _context3.t0 = _context3["catch"](22);
              HMSLogger.e(TAG$8, 'failed to add plugin', _context3.t0);
              _context3.next = 36;
              return this.removePlugin(plugin);

            case 36:
              throw _context3.t0;

            case 37:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, this, [[22, 31]]);
    }));

    function addPluginInternal(_x3, _x4) {
      return _addPluginInternal.apply(this, arguments);
    }

    return addPluginInternal;
  }();

  _proto.removePlugin = /*#__PURE__*/function () {
    var _removePlugin = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4(plugin) {
      var name;
      return runtime_1.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              name = plugin.getName();

              if (this.pluginsMap[name]) {
                _context4.next = 4;
                break;
              }

              HMSLogger.w(TAG$8, "plugin - " + name + " not found to remove.");
              return _context4.abrupt("return");

            case 4:
              HMSLogger.i(TAG$8, "removing plugin " + name);
              this.removePluginEntry(name);

              if (!(this.plugins.length === 0)) {
                _context4.next = 10;
                break;
              }

              HMSLogger.i(TAG$8, "No plugins left, stopping plugins loop");
              _context4.next = 10;
              return this.stopPluginsLoop();

            case 10:
              plugin.stop();
              this.analytics.removed(name);

            case 12:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4, this);
    }));

    function removePlugin(_x5) {
      return _removePlugin.apply(this, arguments);
    }

    return removePlugin;
  }();

  _proto.removePluginEntry = function removePluginEntry(name) {
    var index = this.plugins.indexOf(name);

    if (index !== -1) {
      this.plugins.splice(index, 1);
    }

    if (this.pluginsMap[name]) {
      delete this.pluginsMap[name];
    }

    if (this.pluginNumFramesToSkip[name]) {
      delete this.pluginNumFramesToSkip[name];
    }

    if (this.pluginNumFramesSkipped[name]) {
      delete this.pluginNumFramesSkipped[name];
    }
  }
  /**
   * when video is unmuted it takes some time for all the plugins to be re run and an output stream to be
   * produced. It can await on this function to confirm and tell the new unmuted state.
   * If this is not awaited on video will freeze with a frame from past run.
   */
  ;

  _proto.waitForRestart =
  /*#__PURE__*/
  function () {
    var _waitForRestart = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee5() {
      return runtime_1.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              if (!(!this.pluginsLoopRunning || this.pluginsLoopState === 'running')) {
                _context5.next = 2;
                break;
              }

              return _context5.abrupt("return");

            case 2:
              if (!(this.pluginsLoopState === 'paused')) {
                _context5.next = 7;
                break;
              }

              _context5.next = 5;
              return sleep(100);

            case 5:
              _context5.next = 2;
              break;

            case 7:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5, this);
    }));

    function waitForRestart() {
      return _waitForRestart.apply(this, arguments);
    }

    return waitForRestart;
  }()
  /**
   * remove every plugin one by one
   */
  ;

  _proto.cleanup =
  /*#__PURE__*/
  function () {
    var _cleanup = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee6() {
      var _this$outputTrack;

      var _iterator, _step, name;

      return runtime_1.wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              _iterator = _createForOfIteratorHelperLoose(this.plugins);

            case 1:
              if ((_step = _iterator()).done) {
                _context6.next = 7;
                break;
              }

              name = _step.value;
              _context6.next = 5;
              return this.removePlugin(this.pluginsMap[name]);

            case 5:
              _context6.next = 1;
              break;

            case 7:
              // memory cleanup
              (_this$outputTrack = this.outputTrack) == null ? void 0 : _this$outputTrack.stop();

            case 8:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6, this);
    }));

    function cleanup() {
      return _cleanup.apply(this, arguments);
    }

    return cleanup;
  }();

  _proto.initElementsAndStream = function initElementsAndStream() {
    if (!this.inputCanvas) {
      this.inputCanvas = document.createElement('canvas');
    }

    if (!this.outputCanvas) {
      this.outputCanvas = document.createElement('canvas');
    }

    if (!this.inputVideo) {
      this.inputVideo = document.createElement('video');
    } // FF issue https://bugzilla.mozilla.org/show_bug.cgi?id=1388974


    this.inputCanvas.getContext('2d');
    this.outputCanvas.getContext('2d'); // capture stream automatically uses the framerate at which the output canvas is changing

    var outputStream = this.outputCanvas.captureStream();
    this.outputTrack = outputStream.getVideoTracks()[0];
  };

  _proto.startPluginsLoop = /*#__PURE__*/function () {
    var _startPluginsLoop = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee7() {
      return runtime_1.wrap(function _callee7$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              if (!this.pluginsLoopRunning) {
                _context7.next = 2;
                break;
              }

              return _context7.abrupt("return");

            case 2:
              this.initElementsAndStream();
              this.pluginsLoopRunning = true;
              _context7.prev = 4;
              _context7.next = 7;
              return this.hmsTrack.setProcessedTrack(this.outputTrack);

            case 7:
              _context7.next = 14;
              break;

            case 9:
              _context7.prev = 9;
              _context7.t0 = _context7["catch"](4);
              this.pluginsLoopRunning = false;
              HMSLogger.e(TAG$8, 'error in setting processed track', _context7.t0);
              throw _context7.t0;

            case 14:
              // can't await on pluginsLoop as it'll run for a long long time
              this.pluginsLoop().then(function () {
                HMSLogger.d(TAG$8, 'processLoop stopped');
              });

            case 15:
            case "end":
              return _context7.stop();
          }
        }
      }, _callee7, this, [[4, 9]]);
    }));

    function startPluginsLoop() {
      return _startPluginsLoop.apply(this, arguments);
    }

    return startPluginsLoop;
  }();

  _proto.stopPluginsLoop = /*#__PURE__*/function () {
    var _stopPluginsLoop = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee8() {
      var _this$outputTrack2;

      return runtime_1.wrap(function _callee8$(_context8) {
        while (1) {
          switch (_context8.prev = _context8.next) {
            case 0:
              this.pluginsLoopRunning = false;
              _context8.next = 3;
              return this.hmsTrack.setProcessedTrack(undefined);

            case 3:
              this.resetCanvases();
              (_this$outputTrack2 = this.outputTrack) == null ? void 0 : _this$outputTrack2.stop();

              if (this.inputVideo) {
                this.inputVideo.srcObject = null;
                this.inputVideo = undefined;
              }

            case 6:
            case "end":
              return _context8.stop();
          }
        }
      }, _callee8, this);
    }));

    function stopPluginsLoop() {
      return _stopPluginsLoop.apply(this, arguments);
    }

    return stopPluginsLoop;
  }();

  _proto.pluginsLoop = /*#__PURE__*/function () {
    var _pluginsLoop = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee10() {
      var _this = this;

      var inputFrameRate, sleepTimeMs, processingTime, start;
      return runtime_1.wrap(function _callee10$(_context10) {
        while (1) {
          switch (_context10.prev = _context10.next) {
            case 0:
              if (!this.pluginsLoopRunning) {
                _context10.next = 28;
                break;
              }

              inputFrameRate = this.hmsTrack.getMediaTrackSettings().frameRate || DEFAULT_FRAME_RATE;
              sleepTimeMs = Math.floor(1000 / inputFrameRate);

              if (!(!this.hmsTrack.enabled || this.hmsTrack.nativeTrack.readyState === 'ended')) {
                _context10.next = 9;
                break;
              }

              if (this.pluginsLoopState === 'running') {
                // mute just happened, reset canvases to black so even if it is sent to remote, it
                // is a black screen instead of a stucked frame from previous run
                this.resetCanvases();
              }

              this.pluginsLoopState = 'paused';
              _context10.next = 8;
              return sleep(sleepTimeMs);

            case 8:
              return _context10.abrupt("continue", 0);

            case 9:
              processingTime = 0;
              _context10.prev = 10;
              _context10.next = 13;
              return this.analytics.preProcessWithTime( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee9() {
                return runtime_1.wrap(function _callee9$(_context9) {
                  while (1) {
                    switch (_context9.prev = _context9.next) {
                      case 0:
                        _context9.next = 2;
                        return _this.doPreProcessing();

                      case 2:
                        return _context9.abrupt("return", _context9.sent);

                      case 3:
                      case "end":
                        return _context9.stop();
                    }
                  }
                }, _callee9);
              })));

            case 13:
              start = Date.now();
              _context10.next = 16;
              return this.processFramesThroughPlugins();

            case 16:
              processingTime = Math.floor(Date.now() - start);

              if (processingTime > sleepTimeMs) {
                processingTime = sleepTimeMs;
              }

              _context10.next = 23;
              break;

            case 20:
              _context10.prev = 20;
              _context10.t0 = _context10["catch"](10);
              // TODO: handle failures properly, detect which plugin failed, stop it and notify back to the UI
              HMSLogger.e(TAG$8, 'error in plugins loop', _context10.t0);

            case 23:
              this.pluginsLoopState = 'running'; // take into account processing time to decide time to wait for the next loop

              _context10.next = 26;
              return sleep(sleepTimeMs - processingTime);

            case 26:
              _context10.next = 0;
              break;

            case 28:
            case "end":
              return _context10.stop();
          }
        }
      }, _callee10, this, [[10, 20]]);
    }));

    function pluginsLoop() {
      return _pluginsLoop.apply(this, arguments);
    }

    return pluginsLoop;
  }();

  _proto.doPreProcessing = /*#__PURE__*/function () {
    var _doPreProcessing = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee11() {
      return runtime_1.wrap(function _callee11$(_context11) {
        while (1) {
          switch (_context11.prev = _context11.next) {
            case 0:
              _context11.next = 2;
              return this.addTrackToVideo();

            case 2:
              _context11.next = 4;
              return this.updateInputCanvas();

            case 4:
            case "end":
              return _context11.stop();
          }
        }
      }, _callee11, this);
    }));

    function doPreProcessing() {
      return _doPreProcessing.apply(this, arguments);
    }

    return doPreProcessing;
  }()
  /**
   * pass the input canvas through all plugins in a loop
   * @private
   */
  ;

  _proto.processFramesThroughPlugins =
  /*#__PURE__*/
  function () {
    var _processFramesThroughPlugins = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee14() {
      var _this2 = this;

      var _loop, _iterator2, _step2, _ret;

      return runtime_1.wrap(function _callee14$(_context15) {
        while (1) {
          switch (_context15.prev = _context15.next) {
            case 0:
              _loop = /*#__PURE__*/runtime_1.mark(function _loop() {
                var name, plugin, skipProcessing, process;
                return runtime_1.wrap(function _loop$(_context14) {
                  while (1) {
                    switch (_context14.prev = _context14.next) {
                      case 0:
                        name = _step2.value;
                        plugin = _this2.pluginsMap[name];

                        if (plugin) {
                          _context14.next = 4;
                          break;
                        }

                        return _context14.abrupt("return", "continue");

                      case 4:
                        _context14.prev = 4;
                        skipProcessing = _this2.checkIfSkipRequired(name); // TODO: should we use output of previous to pass in to next, instead of passing initial everytime?

                        if (!(plugin.getPluginType() === exports.HMSVideoPluginType.TRANSFORM)) {
                          _context14.next = 17;
                          break;
                        }

                        process = /*#__PURE__*/function () {
                          var _ref3 = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee12() {
                            return runtime_1.wrap(function _callee12$(_context12) {
                              while (1) {
                                switch (_context12.prev = _context12.next) {
                                  case 0:
                                    _context12.next = 2;
                                    return plugin.processVideoFrame(_this2.inputCanvas, _this2.outputCanvas, skipProcessing);

                                  case 2:
                                  case "end":
                                    return _context12.stop();
                                }
                              }
                            }, _callee12);
                          }));

                          return function process() {
                            return _ref3.apply(this, arguments);
                          };
                        }();

                        if (skipProcessing) {
                          _context14.next = 13;
                          break;
                        }

                        _context14.next = 11;
                        return _this2.analytics.processWithTime(name, process);

                      case 11:
                        _context14.next = 15;
                        break;

                      case 13:
                        _context14.next = 15;
                        return process();

                      case 15:
                        _context14.next = 20;
                        break;

                      case 17:
                        if (!(plugin.getPluginType() === exports.HMSVideoPluginType.ANALYZE && !skipProcessing)) {
                          _context14.next = 20;
                          break;
                        }

                        _context14.next = 20;
                        return _this2.analytics.processWithTime(name, /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee13() {
                          return runtime_1.wrap(function _callee13$(_context13) {
                            while (1) {
                              switch (_context13.prev = _context13.next) {
                                case 0:
                                  _context13.next = 2;
                                  return plugin.processVideoFrame(_this2.inputCanvas);

                                case 2:
                                  return _context13.abrupt("return", _context13.sent);

                                case 3:
                                case "end":
                                  return _context13.stop();
                              }
                            }
                          }, _callee13);
                        })));

                      case 20:
                        _context14.next = 27;
                        break;

                      case 22:
                        _context14.prev = 22;
                        _context14.t0 = _context14["catch"](4);
                        //TODO error happened on processing of plugin notify UI
                        HMSLogger.e(TAG$8, "error in processing plugin " + name, _context14.t0); //remove plugin from loop and stop analytics for it

                        _context14.next = 27;
                        return _this2.removePlugin(plugin);

                      case 27:
                      case "end":
                        return _context14.stop();
                    }
                  }
                }, _loop, null, [[4, 22]]);
              });
              _iterator2 = _createForOfIteratorHelperLoose(this.plugins);

            case 2:
              if ((_step2 = _iterator2()).done) {
                _context15.next = 9;
                break;
              }

              return _context15.delegateYield(_loop(), "t0", 4);

            case 4:
              _ret = _context15.t0;

              if (!(_ret === "continue")) {
                _context15.next = 7;
                break;
              }

              return _context15.abrupt("continue", 7);

            case 7:
              _context15.next = 2;
              break;

            case 9:
            case "end":
              return _context15.stop();
          }
        }
      }, _callee14, this);
    }));

    function processFramesThroughPlugins() {
      return _processFramesThroughPlugins.apply(this, arguments);
    }

    return processFramesThroughPlugins;
  }()
  /**
   * add the current native track to the inputVideoElement if it's not already added.
   * @private
   */
  ;

  _proto.addTrackToVideo =
  /*#__PURE__*/
  function () {
    var _addTrackToVideo = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee15() {
      var srcObject, _srcObject$getVideoTr, existingTrackID;

      return runtime_1.wrap(function _callee15$(_context16) {
        while (1) {
          switch (_context16.prev = _context16.next) {
            case 0:
              if (this.inputVideo) {
                _context16.next = 2;
                break;
              }

              return _context16.abrupt("return");

            case 2:
              srcObject = this.inputVideo.srcObject;

              if (!(srcObject !== null && srcObject instanceof MediaStream)) {
                _context16.next = 7;
                break;
              }

              existingTrackID = (_srcObject$getVideoTr = srcObject.getVideoTracks()[0]) == null ? void 0 : _srcObject$getVideoTr.id;

              if (!(existingTrackID === this.hmsTrack.nativeTrack.id)) {
                _context16.next = 7;
                break;
              }

              return _context16.abrupt("return");

            case 7:
              this.inputVideo.pause();
              this.inputVideo.srcObject = new MediaStream([this.hmsTrack.nativeTrack]);
              this.inputVideo.muted = true;
              _context16.next = 12;
              return this.inputVideo.play();

            case 12:
            case "end":
              return _context16.stop();
          }
        }
      }, _callee15, this);
    }));

    function addTrackToVideo() {
      return _addTrackToVideo.apply(this, arguments);
    }

    return addTrackToVideo;
  }()
  /**
   * get the new video frame from input video element and put it on canvas
   * @private
   */
  ;

  _proto.updateInputCanvas =
  /*#__PURE__*/
  function () {
    var _updateInputCanvas = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee16() {
      var _this$hmsTrack$getMed2, width, height, ctx;

      return runtime_1.wrap(function _callee16$(_context17) {
        while (1) {
          switch (_context17.prev = _context17.next) {
            case 0:
              if (!(!this.inputCanvas || !this.inputVideo)) {
                _context17.next = 2;
                break;
              }

              return _context17.abrupt("return");

            case 2:
              _this$hmsTrack$getMed2 = this.hmsTrack.getMediaTrackSettings(), width = _this$hmsTrack$getMed2.width, height = _this$hmsTrack$getMed2.height;

              if (!(!width || !height || width <= 0 || height <= 0)) {
                _context17.next = 6;
                break;
              }

              HMSLogger.w(TAG$8, 'Invalid width/height of videoTrack', width, height);
              return _context17.abrupt("return");

            case 6:
              // TODO: should we reduce height/width to optimize?
              if (this.inputCanvas.height !== height) {
                this.inputCanvas.height = height;
              }

              if (this.inputCanvas.width !== width) {
                this.inputCanvas.width = width;
              }

              ctx = this.inputCanvas.getContext('2d');
              ctx.drawImage(this.inputVideo, 0, 0, width, height);

            case 10:
            case "end":
              return _context17.stop();
          }
        }
      }, _callee16, this);
    }));

    function updateInputCanvas() {
      return _updateInputCanvas.apply(this, arguments);
    }

    return updateInputCanvas;
  }();

  _proto.resetCanvases = function resetCanvases() {
    if (!this.outputCanvas || !this.inputCanvas) {
      return;
    }

    var outputCtx = this.outputCanvas.getContext('2d');

    if (outputCtx) {
      outputCtx.fillStyle = "rgb(0, 0, 0)";
      outputCtx.fillRect(0, 0, this.outputCanvas.width, this.outputCanvas.height);
    }

    var inputCtx = this.inputCanvas.getContext('2d');

    if (inputCtx) {
      inputCtx.fillStyle = "rgb(0, 0, 0)";
      inputCtx.fillRect(0, 0, this.outputCanvas.width, this.outputCanvas.height);
    }
  }
  /**
    N = ceil(inputFrameRate/pluginFrameRate) - 1
    N = this.pluginNumFramesToSkip[name] = frames to skip for every processed frame
    all the frames we are skipping are using the previous frame output
   **/
  ;

  _proto.checkIfSkipRequired = function checkIfSkipRequired(name) {
    var skip = false;

    if (this.pluginNumFramesSkipped[name] < this.pluginNumFramesToSkip[name]) {
      this.pluginNumFramesSkipped[name]++;
      skip = true;
    } else {
      skip = false;
      this.pluginNumFramesSkipped[name] = 0;
    }

    return skip;
  };

  return HMSVideoPluginsManager;
}();

function generateHasPropertyChanged$1(newSettings, oldSettings) {
  return function hasChanged(prop) {
    return prop in newSettings && newSettings[prop] !== oldSettings[prop];
  };
}

var HMSLocalVideoTrack = /*#__PURE__*/function (_HMSVideoTrack) {
  _inheritsLoose(HMSLocalVideoTrack, _HMSVideoTrack);

  function HMSLocalVideoTrack(stream, track, source, settings) {
    var _this;

    if (settings === void 0) {
      settings = new HMSVideoTrackSettingsBuilder().build();
    }

    _this = _HMSVideoTrack.call(this, stream, track, source) || this;
    stream.tracks.push(_assertThisInitialized(_this));
    _this.settings = settings;
    _this.pluginsManager = new HMSVideoPluginsManager(_assertThisInitialized(_this));
    _this.publishedTrackId = _this.trackId;

    _this.setFirstTrackId(_this.trackId);

    return _this;
  }
  /**
   * use this function to set the enabled state of a track. If true the track will be unmuted and muted otherwise.
   * @param value
   */


  var _proto = HMSLocalVideoTrack.prototype;

  _proto.setEnabled =
  /*#__PURE__*/
  function () {
    var _setEnabled = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(value) {
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (!(value === this.enabled)) {
                _context.next = 2;
                break;
              }

              return _context.abrupt("return");

            case 2:
              if (!(this.source === 'regular')) {
                _context.next = 10;
                break;
              }

              if (!value) {
                _context.next = 8;
                break;
              }

              _context.next = 6;
              return this.replaceTrackWith(this.settings);

            case 6:
              _context.next = 10;
              break;

            case 8:
              _context.next = 10;
              return this.replaceTrackWithBlank();

            case 10:
              _context.next = 12;
              return _HMSVideoTrack.prototype.setEnabled.call(this, value);

            case 12:
              this.stream.trackUpdate(this);

            case 13:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function setEnabled(_x) {
      return _setEnabled.apply(this, arguments);
    }

    return setEnabled;
  }()
  /**
   * @see HMSVideoTrack#addSink()
   */
  ;

  _proto.addSink = function addSink(videoElement) {
    this.addSinkInternal(videoElement, this.processedTrack || this.nativeTrack);
  }
  /**
   * This function can be used to set media track settings. Frequent options -
   * deviceID: can be used to change to different input source
   * width, height - can be used to change capture dimensions
   * maxFramerate - can be used to control the capture framerate
   * @param settings
   */
  ;

  _proto.setSettings =
  /*#__PURE__*/
  function () {
    var _setSettings = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(settings, internal) {
      var _this$settings$settin, width, height, codec, maxFramerate, maxBitrate, deviceId, advanced, newSettings, stream, hasPropertyChanged;

      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (internal === void 0) {
                internal = false;
              }

              _this$settings$settin = _extends({}, this.settings, settings), width = _this$settings$settin.width, height = _this$settings$settin.height, codec = _this$settings$settin.codec, maxFramerate = _this$settings$settin.maxFramerate, maxBitrate = _this$settings$settin.maxBitrate, deviceId = _this$settings$settin.deviceId, advanced = _this$settings$settin.advanced;
              newSettings = new HMSVideoTrackSettings(width, height, codec, maxFramerate, deviceId, advanced, maxBitrate);

              if (this.enabled) {
                _context2.next = 6;
                break;
              }

              // if track is muted, we just cache the settings for when it is unmuted
              this.settings = newSettings;
              return _context2.abrupt("return");

            case 6:
              stream = this.stream;
              hasPropertyChanged = generateHasPropertyChanged$1(settings, this.settings);

              if (!(hasPropertyChanged('deviceId') && this.source === 'regular')) {
                _context2.next = 13;
                break;
              }

              if (!this.enabled) {
                _context2.next = 13;
                break;
              }

              _context2.next = 12;
              return this.replaceTrackWith(newSettings);

            case 12:
              if (!internal) {
                DeviceStorageManager.updateSelection('videoInput', {
                  deviceId: settings.deviceId,
                  groupId: this.nativeTrack.getSettings().groupId
                });
              }

            case 13:
              if (!(hasPropertyChanged('maxBitrate') && newSettings.maxBitrate)) {
                _context2.next = 16;
                break;
              }

              _context2.next = 16;
              return stream.setMaxBitrate(newSettings.maxBitrate, this);

            case 16:
              if (!(hasPropertyChanged('width') || hasPropertyChanged('height') || hasPropertyChanged('advanced'))) {
                _context2.next = 19;
                break;
              }

              _context2.next = 19;
              return this.nativeTrack.applyConstraints(newSettings.toConstraints());

            case 19:
              this.settings = newSettings;

            case 20:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));

    function setSettings(_x2, _x3) {
      return _setSettings.apply(this, arguments);
    }

    return setSettings;
  }()
  /**
   * @see HMSVideoPlugin
   */
  ;

  _proto.getPlugins = function getPlugins() {
    return this.pluginsManager.getPlugins();
  }
  /**
   * @see HMSVideoPlugin
   */
  ;

  _proto.addPlugin =
  /*#__PURE__*/
  function () {
    var _addPlugin = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3(plugin, pluginFrameRate) {
      return runtime_1.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              return _context3.abrupt("return", this.pluginsManager.addPlugin(plugin, pluginFrameRate));

            case 1:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, this);
    }));

    function addPlugin(_x4, _x5) {
      return _addPlugin.apply(this, arguments);
    }

    return addPlugin;
  }()
  /**
   * @see HMSVideoPlugin
   */
  ;

  _proto.removePlugin =
  /*#__PURE__*/
  function () {
    var _removePlugin = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4(plugin) {
      return runtime_1.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              return _context4.abrupt("return", this.pluginsManager.removePlugin(plugin));

            case 1:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4, this);
    }));

    function removePlugin(_x6) {
      return _removePlugin.apply(this, arguments);
    }

    return removePlugin;
  }()
  /**
   * @internal
   */
  ;

  _proto.cleanup =
  /*#__PURE__*/
  function () {
    var _cleanup = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee5() {
      var _this$processedTrack;

      return runtime_1.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              _HMSVideoTrack.prototype.cleanup.call(this);

              _context5.next = 3;
              return this.pluginsManager.cleanup();

            case 3:
              (_this$processedTrack = this.processedTrack) == null ? void 0 : _this$processedTrack.stop();

            case 4:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5, this);
    }));

    function cleanup() {
      return _cleanup.apply(this, arguments);
    }

    return cleanup;
  }()
  /**
   * once the plugin manager has done its processing it can set or remove processed track via this method
   * note that replacing sender track only makes sense if the native track is enabled. if it's disabled there is
   * no point in replacing it. We'll update the processed track variable though so next time unmute happens
   * it's set properly.
   * @internal
   */
  ;

  _proto.setProcessedTrack =
  /*#__PURE__*/
  function () {
    var _setProcessedTrack = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee6(processedTrack) {
      return runtime_1.wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              if (this.nativeTrack.enabled) {
                _context6.next = 3;
                break;
              }

              this.processedTrack = processedTrack;
              return _context6.abrupt("return");

            case 3:
              if (processedTrack) {
                _context6.next = 9;
                break;
              }

              if (!this.processedTrack) {
                _context6.next = 7;
                break;
              }

              _context6.next = 7;
              return this.stream.replaceSenderTrack(this.processedTrack, this.nativeTrack);

            case 7:
              this.processedTrack = undefined;
              return _context6.abrupt("return");

            case 9:
              if (!(processedTrack !== this.processedTrack)) {
                _context6.next = 18;
                break;
              }

              if (!this.processedTrack) {
                _context6.next = 15;
                break;
              }

              _context6.next = 13;
              return this.stream.replaceSenderTrack(this.processedTrack, processedTrack);

            case 13:
              _context6.next = 17;
              break;

            case 15:
              _context6.next = 17;
              return this.stream.replaceSenderTrack(this.nativeTrack, processedTrack);

            case 17:
              this.processedTrack = processedTrack;

            case 18:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6, this);
    }));

    function setProcessedTrack(_x7) {
      return _setProcessedTrack.apply(this, arguments);
    }

    return setProcessedTrack;
  }()
  /**
   * @internal
   * sent track id will be different in case there was some processing done using plugins.
   * replace track is used to, start sending data from a new track without un publishing the prior one. There
   * are thus two track ids - the one which was initially published and should be unpublished when required.
   * The one whose data is currently being sent, which will be used when removing from connection senders.
   */
  ;

  _proto.getTrackIDBeingSent = function getTrackIDBeingSent() {
    return this.processedTrack ? this.processedTrack.id : this.nativeTrack.id;
  }
  /**
   * called when the video is unmuted
   * @private
   */
  ;

  _proto.replaceTrackWith =
  /*#__PURE__*/
  function () {
    var _replaceTrackWith = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee7(settings) {
      var prevTrack, newTrack, localStream;
      return runtime_1.wrap(function _callee7$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              prevTrack = this.nativeTrack;
              prevTrack == null ? void 0 : prevTrack.stop();
              _context7.next = 4;
              return getVideoTrack(settings);

            case 4:
              newTrack = _context7.sent;
              localStream = this.stream; // change nativeTrack so plugin can start its work

              _context7.next = 8;
              return localStream.replaceSenderTrack(prevTrack, this.processedTrack || newTrack);

            case 8:
              _context7.next = 10;
              return localStream.replaceStreamTrack(prevTrack, newTrack);

            case 10:
              this.nativeTrack = newTrack;
              _context7.next = 13;
              return this.pluginsManager.waitForRestart();

            case 13:
            case "end":
              return _context7.stop();
          }
        }
      }, _callee7, this);
    }));

    function replaceTrackWith(_x8) {
      return _replaceTrackWith.apply(this, arguments);
    }

    return replaceTrackWith;
  }()
  /**
   * called when the video is muted. A blank track is used to replace the original track. This is in order to
   * turn off the camera light and keep the bytes flowing to avoid av sync, timestamp issues.
   * @private
   */
  ;

  _proto.replaceTrackWithBlank =
  /*#__PURE__*/
  function () {
    var _replaceTrackWithBlank = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee8() {
      var prevTrack, newTrack, localStream;
      return runtime_1.wrap(function _callee8$(_context8) {
        while (1) {
          switch (_context8.prev = _context8.next) {
            case 0:
              prevTrack = this.nativeTrack;
              prevTrack == null ? void 0 : prevTrack.stop();
              newTrack = getEmptyVideoTrack(prevTrack);
              localStream = this.stream;
              _context8.next = 6;
              return localStream.replaceSenderTrack(this.processedTrack || this.nativeTrack, newTrack);

            case 6:
              _context8.next = 8;
              return localStream.replaceStreamTrack(this.nativeTrack, newTrack);

            case 8:
              this.nativeTrack = newTrack;

            case 9:
            case "end":
              return _context8.stop();
          }
        }
      }, _callee8, this);
    }));

    function replaceTrackWithBlank() {
      return _replaceTrackWithBlank.apply(this, arguments);
    }

    return replaceTrackWithBlank;
  }();

  return HMSLocalVideoTrack;
}(HMSVideoTrack);

var TAG$9 = 'HMSLocalStream';

var HMSLocalStream = /*#__PURE__*/function (_HMSMediaStream) {
  _inheritsLoose(HMSLocalStream, _HMSMediaStream);

  function HMSLocalStream() {
    var _this;

    _this = _HMSMediaStream.apply(this, arguments) || this;
    /** Connection set when publish is called for the first track */

    _this.connection = null;
    return _this;
  }

  var _proto = HMSLocalStream.prototype;

  _proto.setConnection = function setConnection(connection) {
    this.connection = connection;
  };

  HMSLocalStream.getLocalScreen = /*#__PURE__*/function () {
    var _getLocalScreen = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(videosettings, audioSettings) {
      var audioConstraints, constraints, stream, tracks, local, nativeVideoTrack, videoTrack, nativeAudioTrack, audioTrack;
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              audioConstraints = audioSettings.toConstraints(); // remove advanced constraints as it not supported for screenshare audio

              delete audioConstraints.advanced;
              constraints = {
                video: videosettings.toConstraints(),
                audio: _extends({}, audioConstraints, {
                  autoGainControl: false,
                  noiseSuppression: false,
                  googAutoGainControl: false,
                  echoCancellation: false
                })
              };
              _context.prev = 3;
              _context.next = 6;
              return navigator.mediaDevices.getDisplayMedia(constraints);

            case 6:
              stream = _context.sent;
              _context.next = 12;
              break;

            case 9:
              _context.prev = 9;
              _context.t0 = _context["catch"](3);
              throw BuildGetMediaError(_context.t0, HMSGetMediaActions.SCREEN);

            case 12:
              tracks = [];
              local = new HMSLocalStream(stream);
              nativeVideoTrack = stream.getVideoTracks()[0];
              videoTrack = new HMSLocalVideoTrack(local, nativeVideoTrack, 'screen', videosettings);
              tracks.push(videoTrack);
              nativeAudioTrack = stream.getAudioTracks()[0];

              if (nativeAudioTrack) {
                audioTrack = new HMSLocalAudioTrack(local, nativeAudioTrack, 'screen', audioSettings);
                tracks.push(audioTrack);
              }

              HMSLogger.v(TAG$9, 'getLocalScreen', tracks);
              return _context.abrupt("return", tracks);

            case 21:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, null, [[3, 9]]);
    }));

    function getLocalScreen(_x, _x2) {
      return _getLocalScreen.apply(this, arguments);
    }

    return getLocalScreen;
  }();

  HMSLocalStream.getLocalTracks = /*#__PURE__*/function () {
    var _getLocalTracks = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(settings) {
      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return this.getEmptyLocalTracks({
                audio: true,
                video: true
              }, settings);

            case 2:
              return _context2.abrupt("return", _context2.sent);

            case 3:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));

    function getLocalTracks(_x3) {
      return _getLocalTracks.apply(this, arguments);
    }

    return getLocalTracks;
  }();

  HMSLocalStream.getEmptyLocalTracks = /*#__PURE__*/function () {
    var _getEmptyLocalTracks = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3(fetchTrackOptions, settings) {
      var nativeTracks, nativeVideoTrack, nativeAudioTrack, local, tracks, audioTrack, videoTrack;
      return runtime_1.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              if (fetchTrackOptions === void 0) {
                fetchTrackOptions = {
                  audio: true,
                  video: true
                };
              }

              _context3.next = 3;
              return this.getNativeLocalTracks(fetchTrackOptions, settings);

            case 3:
              nativeTracks = _context3.sent;
              nativeVideoTrack = nativeTracks.find(function (track) {
                return track.kind === 'video';
              });
              nativeAudioTrack = nativeTracks.find(function (track) {
                return track.kind === 'audio';
              });
              local = new HMSLocalStream(new MediaStream(nativeTracks));
              tracks = [];

              if (nativeAudioTrack && settings != null && settings.audio) {
                audioTrack = new HMSLocalAudioTrack(local, nativeAudioTrack, 'regular', settings.audio);
                tracks.push(audioTrack);
              }

              if (nativeVideoTrack && settings != null && settings.video) {
                videoTrack = new HMSLocalVideoTrack(local, nativeVideoTrack, 'regular', settings.video);
                tracks.push(videoTrack);
              }

              HMSLogger.v(TAG$9, 'getEmptyLocalTracks', tracks);
              return _context3.abrupt("return", tracks);

            case 12:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, this);
    }));

    function getEmptyLocalTracks(_x4, _x5) {
      return _getEmptyLocalTracks.apply(this, arguments);
    }

    return getEmptyLocalTracks;
  }();

  _proto.addTransceiver = function addTransceiver(track, simulcastLayers) {
    var trackEncodings = [];

    if (track instanceof HMSLocalVideoTrack) {
      if (simulcastLayers.length > 0) {
        HMSLogger.v(TAG$9, 'Simulcast enabled with layers', simulcastLayers);
        trackEncodings.push.apply(trackEncodings, simulcastLayers);
      } else {
        var encodings = {
          active: this.nativeStream.active
        };

        if (track.settings.maxBitrate && !isNode) {
          encodings.maxBitrate = track.settings.maxBitrate;
        }

        trackEncodings.push(encodings);
      }
    }

    var transceiver = this.connection.addTransceiver(track.nativeTrack, {
      streams: [this.nativeStream],
      direction: 'sendonly',
      sendEncodings: trackEncodings
    });
    this.setPreferredCodec(transceiver, track.nativeTrack.kind);
    return transceiver;
  };

  _proto.setMaxBitrate = /*#__PURE__*/function () {
    var _setMaxBitrate = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4(maxBitrate, track) {
      var _this$connection;

      return runtime_1.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              _context4.next = 2;
              return (_this$connection = this.connection) == null ? void 0 : _this$connection.setMaxBitrate(maxBitrate, track);

            case 2:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4, this);
    }));

    function setMaxBitrate(_x6, _x7) {
      return _setMaxBitrate.apply(this, arguments);
    }

    return setMaxBitrate;
  }() // @ts-ignore
  ;

  _proto.setPreferredCodec = function setPreferredCodec(transceiver, kind) {// TODO: Some browsers don't support setCodecPreferences, resort to SDPMunging?
  }
  /**
   * On mute and unmute of video tracks as well as for changing cameras, we replace the track using replaceTrack api
   * so as to avoid a renegotiation with the backend and reflect changes faster.
   * @param track - the current track
   * @param withTrack - the track to replace it with
   */
  ;

  _proto.replaceTrack =
  /*#__PURE__*/
  function () {
    var _replaceTrack = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee5(track, withTrack) {
      return runtime_1.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              _context5.next = 2;
              return this.replaceSenderTrack(track, withTrack);

            case 2:
              track.stop(); // If the track is already stopped, this does not throw any error. 😉

              this.replaceStreamTrack(track, withTrack);

            case 4:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5, this);
    }));

    function replaceTrack(_x8, _x9) {
      return _replaceTrack.apply(this, arguments);
    }

    return replaceTrack;
  }();

  _proto.replaceStreamTrack = function replaceStreamTrack(track, withTrack) {
    this.nativeStream.addTrack(withTrack);
    this.nativeStream.removeTrack(track);
  }
  /**
   * In case of video plugins we need to replace the track sent to remote without stopping the original one. As
   * if the original is stopped, plugin would stop getting input frames to process. So only the track in the
   * sender needs to be replaced.
   */
  ;

  _proto.replaceSenderTrack =
  /*#__PURE__*/
  function () {
    var _replaceSenderTrack = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee6(track, withTrack) {
      var _this$connection2;

      var sender;
      return runtime_1.wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              sender = (_this$connection2 = this.connection) == null ? void 0 : _this$connection2.getSenders().find(function (sender) {
                return sender.track && sender.track.id === track.id;
              });

              if (!(sender === undefined)) {
                _context6.next = 4;
                break;
              }

              HMSLogger.w(TAG$9, "No sender found for trackId=" + track.id);
              return _context6.abrupt("return");

            case 4:
              _context6.next = 6;
              return sender.replaceTrack(withTrack);

            case 6:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6, this);
    }));

    function replaceSenderTrack(_x10, _x11) {
      return _replaceSenderTrack.apply(this, arguments);
    }

    return replaceSenderTrack;
  }();

  _proto.removeSender = function removeSender(track) {
    var _this2 = this;

    var removedSenderCount = 0;
    this.connection.getSenders().forEach(function (sender) {
      var _sender$track, _sender$track2;

      if (((_sender$track = sender.track) == null ? void 0 : _sender$track.id) === track.trackId || ((_sender$track2 = sender.track) == null ? void 0 : _sender$track2.id) === track.getTrackIDBeingSent()) {
        _this2.connection.removeTrack(sender);

        removedSenderCount += 1; // Remove the local reference as well

        var toRemoveLocalTrackIdx = _this2.tracks.indexOf(track);

        if (toRemoveLocalTrackIdx !== -1) {
          _this2.tracks.splice(toRemoveLocalTrackIdx, 1);
        } else {
          HMSLogger.e(TAG$9, "Cannot find " + track.trackId + " in locally stored tracks");
        }
      }
    });

    if (removedSenderCount !== 1) {
      HMSLogger.e(TAG$9, "Removed " + removedSenderCount + " sender's, expected to remove 1");
    }
  };

  _proto.trackUpdate = function trackUpdate(track) {
    var _this$connection3;

    (_this$connection3 = this.connection) == null ? void 0 : _this$connection3.trackUpdate(track);
  };

  HMSLocalStream.getNativeLocalTracks = /*#__PURE__*/function () {
    var _getNativeLocalTracks = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee7(fetchTrackOptions, settings) {
      var nativeVideoTrack, nativeAudioTrack, nativeTracks;
      return runtime_1.wrap(function _callee7$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              if (fetchTrackOptions === void 0) {
                fetchTrackOptions = {
                  audio: false,
                  video: false
                };
              }

              if (!(fetchTrackOptions.video === 'empty')) {
                _context7.next = 5;
                break;
              }

              _context7.t0 = getEmptyVideoTrack();
              _context7.next = 11;
              break;

            case 5:
              _context7.t1 = fetchTrackOptions.video && (settings == null ? void 0 : settings.video);

              if (!_context7.t1) {
                _context7.next = 10;
                break;
              }

              _context7.next = 9;
              return getVideoTrack(settings.video);

            case 9:
              _context7.t1 = _context7.sent;

            case 10:
              _context7.t0 = _context7.t1;

            case 11:
              nativeVideoTrack = _context7.t0;

              if (!(fetchTrackOptions.audio === 'empty')) {
                _context7.next = 16;
                break;
              }

              _context7.t2 = getEmptyAudioTrack();
              _context7.next = 22;
              break;

            case 16:
              _context7.t3 = fetchTrackOptions.audio && (settings == null ? void 0 : settings.audio);

              if (!_context7.t3) {
                _context7.next = 21;
                break;
              }

              _context7.next = 20;
              return getAudioTrack(settings.audio);

            case 20:
              _context7.t3 = _context7.sent;

            case 21:
              _context7.t2 = _context7.t3;

            case 22:
              nativeAudioTrack = _context7.t2;
              nativeTracks = [];
              if (nativeAudioTrack) nativeTracks.push(nativeAudioTrack);
              if (nativeVideoTrack) nativeTracks.push(nativeVideoTrack);
              return _context7.abrupt("return", nativeTracks);

            case 27:
            case "end":
              return _context7.stop();
          }
        }
      }, _callee7);
    }));

    function getNativeLocalTracks(_x12, _x13) {
      return _getNativeLocalTracks.apply(this, arguments);
    }

    return getNativeLocalTracks;
  }();

  return HMSLocalStream;
}(HMSMediaStream);

/**
 * Method names for incoming RPC messages from BIZ Signal through Websocket.
 * Used to call the corresponding handler/manager in NotificationManager
 * which will call the corresponding HMSUpdateListener callbacks.
 */
var HMSNotificationMethod;

(function (HMSNotificationMethod) {
  HMSNotificationMethod["PEER_JOIN"] = "on-peer-join";
  HMSNotificationMethod["PEER_LEAVE"] = "on-peer-leave";
  HMSNotificationMethod["PEER_LIST"] = "peer-list";
  HMSNotificationMethod["TRACK_METADATA_ADD"] = "on-track-add";
  HMSNotificationMethod["TRACK_UPDATE"] = "on-track-update";
  HMSNotificationMethod["CHANGE_TRACK_MUTE_STATE_UPDATE"] = "on-change-track-mute-state-request";
  HMSNotificationMethod["ACTIVE_SPEAKERS"] = "active-speakers";
  HMSNotificationMethod["BROADCAST"] = "on-broadcast";
  HMSNotificationMethod["ROLE_CHANGE"] = "on-role-change";
  HMSNotificationMethod["POLICY_CHANGE"] = "on-policy-change";
  HMSNotificationMethod["ROLE_CHANGE_REQUEST"] = "on-role-change-request";
  HMSNotificationMethod["TRACK_UPDATE_REQUEST"] = "on-track-update-request";
  HMSNotificationMethod["PEER_UPDATE"] = "on-peer-update";
  HMSNotificationMethod["PEER_LEAVE_REQUEST"] = "on-peer-leave-request";
  HMSNotificationMethod["UNSUPPORTED"] = "unsupported";
  HMSNotificationMethod["RTMP_START"] = "on-rtmp-start";
  HMSNotificationMethod["RTMP_STOP"] = "on-rtmp-stop";
  HMSNotificationMethod["RECORDING_START"] = "on-record-start";
  HMSNotificationMethod["RECORDING_STOP"] = "on-record-stop";
})(HMSNotificationMethod || (HMSNotificationMethod = {}));

var ActiveSpeakerManager = /*#__PURE__*/function () {
  function ActiveSpeakerManager(store, listener, audioListener) {
    this.store = store;
    this.listener = listener;
    this.audioListener = audioListener;
  }

  var _proto = ActiveSpeakerManager.prototype;

  _proto.handleActiveSpeakers = function handleActiveSpeakers(speakerList) {
    var _this = this,
        _this$audioListener;

    var speakers = speakerList['speaker-list'];
    var hmsSpeakers = speakers.map(function (speaker) {
      return {
        audioLevel: speaker.level,
        peer: _this.store.getPeerById(speaker.peer_id),
        track: _this.store.getTrackById(speaker.track_id)
      };
    });
    (_this$audioListener = this.audioListener) == null ? void 0 : _this$audioListener.onAudioLevelUpdate(hmsSpeakers);
    this.store.updateSpeakers(hmsSpeakers);
    var dominantSpeaker = speakers[0];

    if (dominantSpeaker) {
      var _this$listener;

      var dominantSpeakerPeer = this.store.getPeerById(dominantSpeaker.peer_id);
      (_this$listener = this.listener) == null ? void 0 : _this$listener.onPeerUpdate(exports.HMSPeerUpdate.BECAME_DOMINANT_SPEAKER, dominantSpeakerPeer);
    } else {
      var _this$listener2;

      (_this$listener2 = this.listener) == null ? void 0 : _this$listener2.onPeerUpdate(exports.HMSPeerUpdate.RESIGNED_DOMINANT_SPEAKER, null);
    }
  };

  return ActiveSpeakerManager;
}();

var Message = /*#__PURE__*/function () {
  function Message(_ref) {
    var sender = _ref.sender,
        message = _ref.message,
        _ref$type = _ref.type,
        type = _ref$type === void 0 ? 'chat' : _ref$type,
        recipientPeer = _ref.recipientPeer,
        recipientRoles = _ref.recipientRoles,
        time = _ref.time;
    this.sender = sender;
    this.message = message;
    this.type = type;
    this.recipientPeer = recipientPeer;
    this.recipientRoles = recipientRoles;
    this.time = time;
  }

  var _proto = Message.prototype;

  _proto.toSignalParams = function toSignalParams() {
    var _this$recipientRoles, _this$recipientPeer;

    var roles = (_this$recipientRoles = this.recipientRoles) == null ? void 0 : _this$recipientRoles.map(function (role) {
      return role.name;
    });
    var peer = (_this$recipientPeer = this.recipientPeer) == null ? void 0 : _this$recipientPeer.peerId;
    var sendParams = {
      info: {
        sender: this.sender.peerId,
        message: this.message,
        type: this.type
      }
    };

    if (roles != null && roles.length) {
      sendParams.roles = roles;
    }

    if (peer) {
      sendParams.peer_id = peer;
    }

    return sendParams;
  };

  return Message;
}();

var HMSPeer = /*#__PURE__*/function () {
  function HMSPeer(_ref) {
    var peerId = _ref.peerId,
        name = _ref.name,
        isLocal = _ref.isLocal,
        customerUserId = _ref.customerUserId,
        customerDescription = _ref.customerDescription,
        role = _ref.role;
    this.customerUserId = '';
    this.customerDescription = '';
    this.auxiliaryTracks = [];
    this.name = name;
    this.peerId = peerId;
    this.isLocal = isLocal;
    this.customerUserId = customerUserId;
    this.customerDescription = customerDescription;

    if (role) {
      this.role = role;
    }
  }

  var _proto = HMSPeer.prototype;

  _proto.updateRole = function updateRole(newRole) {
    this.role = newRole;
  };

  return HMSPeer;
}();

var HMSIdFactory = function HMSIdFactory() {};

HMSIdFactory.makePeerId = function () {
  return uuid.v4();
};

var HMSLocalPeer = /*#__PURE__*/function (_HMSPeer) {
  _inheritsLoose(HMSLocalPeer, _HMSPeer);

  function HMSLocalPeer(peerData) {
    var _this;

    _this = _HMSPeer.call(this, _extends({}, peerData, {
      peerId: HMSIdFactory.makePeerId(),
      isLocal: true
    })) || this;
    _this.isLocal = true;
    _this.auxiliaryTracks = [];
    return _this;
  }

  return HMSLocalPeer;
}(HMSPeer);

var HMSRemotePeer = /*#__PURE__*/function (_HMSPeer) {
  _inheritsLoose(HMSRemotePeer, _HMSPeer);

  function HMSRemotePeer(peerData) {
    var _this;

    _this = _HMSPeer.call(this, _extends({}, peerData, {
      isLocal: false
    })) || this;
    _this.isLocal = false;
    _this.auxiliaryTracks = [];
    return _this;
  }

  return HMSRemotePeer;
}(HMSPeer);

var BroadcastManager = /*#__PURE__*/function () {
  function BroadcastManager(store, listener) {
    this.store = store;
    this.listener = listener;
  }

  var _proto = BroadcastManager.prototype;

  _proto.handleBroadcast = function handleBroadcast(messageNotification) {
    var _this$listener;

    var notifPeer = messageNotification.peer;
    var notifMessage = messageNotification.info;
    var notifRoles = messageNotification.roles; // If sender peerId is available in store, use that peer.

    var sender = this.store.getPeerById(notifPeer.peer_id); // If not available in store, use peer data from received broadcast message from Biz

    if (!sender) {
      sender = new HMSPeer({
        peerId: notifPeer.peer_id,
        name: notifPeer.info.name,
        isLocal: false,
        customerUserId: notifPeer.info.user_id,
        customerDescription: notifPeer.info.data
      });
    }

    var recipientPeer;
    var recipientRoles = [];

    if (notifRoles != null && notifRoles.length) {
      var knownRoles = this.store.getKnownRoles();

      for (var _iterator = _createForOfIteratorHelperLoose(notifRoles), _step; !(_step = _iterator()).done;) {
        var role = _step.value;

        if (knownRoles[role]) {
          recipientRoles.push(knownRoles[role]);
        }
      }
    }

    if (messageNotification["private"]) {
      var peer = this.store.getLocalPeer();
      recipientPeer = peer;
    }

    var hmsMessage = new Message(_extends({}, notifMessage, {
      sender: sender,
      recipientRoles: recipientRoles,
      recipientPeer: recipientPeer,
      time: new Date(messageNotification.timestamp)
    }));
    HMSLogger.d(this.TAG, "Received Message:: ", hmsMessage);
    (_this$listener = this.listener) == null ? void 0 : _this$listener.onMessageReceived(hmsMessage);
  };

  _createClass(BroadcastManager, [{
    key: "TAG",
    get: function get() {
      return "[" + this.constructor.name + "]";
    }
  }]);

  return BroadcastManager;
}();

/**
 * Handles:
 * - Initial Peer List - get peer and track meta-data for peers who are already in the room when you join
 * - Reconnect Peer List - Handle peer and track changes in the room missed out due to reconnection
 *
 * Cases to handle in reconnect peer list:
 * - Add additional peers as peer join
 * - Remove missing peers as peer leave
 * - For existing peers:
 *    - Add new tracks as track add
 *    - Remove missing tracks as track remove
 *    - Track state change(enabled) as track update
 */

var PeerListManager = /*#__PURE__*/function () {
  function PeerListManager(store, peerManager, trackManager, listener) {
    var _this = this;

    this.store = store;
    this.peerManager = peerManager;
    this.trackManager = trackManager;
    this.listener = listener;

    this.handleInitialPeerList = function (peerList) {
      var peers = Object.values(peerList.peers);

      _this.peerManager.handlePeerList(peers);
    };

    this.handleReconnectPeerList = function (peerList) {
      var currentPeerList = _this.store.getRemotePeers();

      var peers = Object.values(peerList.peers);
      var peersToRemove = currentPeerList.filter(function (hmsPeer) {
        return !peerList.peers.hasOwnProperty(hmsPeer.peerId);
      });
      HMSLogger.d(_this.TAG, {
        peersToRemove: peersToRemove
      }); // Send peer-leave updates to all the missing peers

      peersToRemove.forEach(function (peer) {
        var _peer$role;

        var peerNotification = {
          peer_id: peer.peerId,
          role: ((_peer$role = peer.role) == null ? void 0 : _peer$role.name) || '',
          info: {
            name: peer.name,
            data: peer.customerDescription || '',
            user_id: peer.customerUserId || ''
          },
          tracks: {}
        };

        _this.peerManager.handlePeerLeave(peerNotification);
      }); // Check for any tracks which are added/removed

      peers.forEach(function (newPeerNotification) {
        var oldPeer = _this.store.getPeerById(newPeerNotification.peer_id);

        var newPeerTrackStates = Object.values(newPeerNotification.tracks);

        if (oldPeer) {
          // Peer already present in room, we take diff between the tracks
          var tracks = _this.store.getPeerTracks(oldPeer.peerId); // Remove all the tracks which are not present in the peer.tracks


          tracks.forEach(function (track) {
            if (!newPeerNotification.tracks.hasOwnProperty(track.trackId)) {
              var _this$listener;

              _this.removePeerTrack(oldPeer, track.trackId);

              (_this$listener = _this.listener) == null ? void 0 : _this$listener.onTrackUpdate(exports.HMSTrackUpdate.TRACK_REMOVED, track, oldPeer);
            }
          }); // Add track-metadata for all the new tracks

          newPeerTrackStates.forEach(function (trackData) {
            if (!_this.store.getTrackById(trackData.track_id)) {
              // NOTE: We assume that, once the connection is re-established,
              //  transport layer will send a native onTrackAdd
              _this.store.setTrackState({
                peerId: oldPeer.peerId,
                trackInfo: trackData
              });
            }
          }); // Handle RTC track add and track state change.

          _this.trackManager.handleTrackUpdate({
            peer: {
              info: newPeerNotification.info,
              peer_id: newPeerNotification.peer_id
            },
            tracks: newPeerNotification.tracks
          });
        } else {
          // New peer joined while reconnecting
          _this.peerManager.handlePeerJoin(newPeerNotification);
        }
      });
    };
  }

  var _proto = PeerListManager.prototype;

  _proto.removePeerTrack = function removePeerTrack(peer, trackId) {
    var _peer$audioTrack, _peer$videoTrack;

    if (((_peer$audioTrack = peer.audioTrack) == null ? void 0 : _peer$audioTrack.trackId) === trackId) {
      peer.audioTrack = undefined;
    } else if (((_peer$videoTrack = peer.videoTrack) == null ? void 0 : _peer$videoTrack.trackId) === trackId) {
      peer.videoTrack = undefined;
    } else {
      var trackIndex = peer.auxiliaryTracks.findIndex(function (track) {
        return track.trackId === trackId;
      });
      trackIndex >= 0 && peer.auxiliaryTracks.splice(trackIndex, 1);
    }
  };

  _createClass(PeerListManager, [{
    key: "TAG",
    get: function get() {
      return "[" + this.constructor.name + "]";
    }
  }]);

  return PeerListManager;
}();

/**
 * Handles:
 * - New peer join
 * - Peer Leave
 * - Role update for peer
 *
 * Notes:
 * - Peer join comes with track meta-data,
 * we add it to the store and call TrackManager to process it when RTC Track comes in.
 */

var PeerManager = /*#__PURE__*/function () {
  function PeerManager(store, trackManager, listener) {
    var _this = this;

    this.store = store;
    this.trackManager = trackManager;
    this.listener = listener;

    this.handlePeerList = function (peers) {
      var _this$listener;

      if (peers.length === 0) return;
      var hmsPeers = [];

      for (var _iterator = _createForOfIteratorHelperLoose(peers), _step; !(_step = _iterator()).done;) {
        var peer = _step.value;
        hmsPeers.push(_this.makePeer(peer));
      }

      (_this$listener = _this.listener) == null ? void 0 : _this$listener.onPeerUpdate(exports.HMSPeerUpdate.PEER_LIST, hmsPeers);

      _this.trackManager.processPendingTracks();
    };

    this.handlePeerJoin = function (peer) {
      var _this$listener2;

      var hmsPeer = _this.makePeer(peer);

      (_this$listener2 = _this.listener) == null ? void 0 : _this$listener2.onPeerUpdate(exports.HMSPeerUpdate.PEER_JOINED, hmsPeer);

      _this.trackManager.processPendingTracks();
    };

    this.handlePeerLeave = function (peer) {
      var _hmsPeer$auxiliaryTra, _this$listener6;

      var hmsPeer = _this.store.getPeerById(peer.peer_id);

      _this.store.removePeer(peer.peer_id);

      HMSLogger.d(_this.TAG, "PEER_LEAVE event", peer, _this.store.getPeers());

      if (!hmsPeer) {
        return;
      }

      if (hmsPeer.audioTrack) {
        var _this$listener3;

        (_this$listener3 = _this.listener) == null ? void 0 : _this$listener3.onTrackUpdate(exports.HMSTrackUpdate.TRACK_REMOVED, hmsPeer.audioTrack, hmsPeer);
      }

      if (hmsPeer.videoTrack) {
        var _this$listener4;

        (_this$listener4 = _this.listener) == null ? void 0 : _this$listener4.onTrackUpdate(exports.HMSTrackUpdate.TRACK_REMOVED, hmsPeer.videoTrack, hmsPeer);
      }

      (_hmsPeer$auxiliaryTra = hmsPeer.auxiliaryTracks) == null ? void 0 : _hmsPeer$auxiliaryTra.forEach(function (track) {
        var _this$listener5;

        (_this$listener5 = _this.listener) == null ? void 0 : _this$listener5.onTrackUpdate(exports.HMSTrackUpdate.TRACK_REMOVED, track, hmsPeer);
      });
      (_this$listener6 = _this.listener) == null ? void 0 : _this$listener6.onPeerUpdate(exports.HMSPeerUpdate.PEER_LEFT, hmsPeer);
    };
  }

  var _proto = PeerManager.prototype;

  _proto.handlePeerUpdate = function handlePeerUpdate(notification) {
    var peer = this.store.getPeerById(notification.peer_id);

    if (!peer) {
      return;
    }

    if (peer.role && peer.role.name !== notification.role) {
      var _this$listener7;

      var newRole = this.store.getPolicyForRole(notification.role);
      peer.updateRole(newRole);
      (_this$listener7 = this.listener) == null ? void 0 : _this$listener7.onPeerUpdate(exports.HMSPeerUpdate.ROLE_UPDATED, peer);
    }
  };

  _proto.makePeer = function makePeer(peer) {
    var hmsPeer = new HMSRemotePeer({
      peerId: peer.peer_id,
      name: peer.info.name,
      customerUserId: peer.info.user_id,
      customerDescription: peer.info.data,
      role: this.store.getPolicyForRole(peer.role)
    });
    this.store.addPeer(hmsPeer);
    HMSLogger.d(this.TAG, "adding to the peerList", hmsPeer);

    for (var trackId in peer.tracks) {
      this.store.setTrackState({
        peerId: peer.peer_id,
        trackInfo: peer.tracks[trackId]
      });
    }

    return hmsPeer;
  };

  _createClass(PeerManager, [{
    key: "TAG",
    get: function get() {
      return "[" + this.constructor.name + "]";
    }
  }]);

  return PeerManager;
}();

/**
 * Handles:
 * - Set policy with publishParams, simulcast layers to store
 * - Emit 'local-peer-role-update' to trigger RoleChangeManager to publish/unpublish local tracks
 * - Emit 'policy-change' to finish preview before calling listener.onPreview
 */
var PolicyChangeManager = /*#__PURE__*/function () {
  function PolicyChangeManager(store, eventEmitter) {
    this.store = store;
    this.eventEmitter = eventEmitter;
  }

  var _proto = PolicyChangeManager.prototype;

  _proto.handlePolicyChange = function handlePolicyChange(params) {
    var _params$known_roles$p;

    var localPeer = this.store.getLocalPeer();

    if (localPeer && !localPeer.role) {
      var newRole = params.known_roles[params.name];
      localPeer.updateRole(newRole);
    }

    this.store.setKnownRoles(params.known_roles); // handle when role is not present in known_roles

    var publishParams = (_params$known_roles$p = params.known_roles[params.name]) == null ? void 0 : _params$known_roles$p.publishParams;
    this.store.setPublishParams(publishParams);

    if (publishParams && Object.keys(publishParams).length > 0) {
      var videoSimulcastLayers = publishParams.videoSimulcastLayers,
          screenSimulcastLayers = publishParams.screenSimulcastLayers;
      this.store.setVideoSimulcastLayers(videoSimulcastLayers);
      this.store.setScreenshareSimulcastLayers(screenSimulcastLayers);
    }

    if (localPeer != null && localPeer.role && localPeer.role.name !== params.name) {
      var _newRole = this.store.getPolicyForRole(params.name);

      var oldRole = localPeer.role;
      localPeer.updateRole(_newRole);
      this.eventEmitter.emit('local-peer-role-update', {
        detail: {
          oldRole: oldRole,
          newRole: _newRole
        }
      });
    }

    this.eventEmitter.emit('policy-change', {
      detail: {
        params: params
      }
    });
  };

  return PolicyChangeManager;
}();

/**
 * Handles request from remote peers to change something on the local side. For eg. role change, track mute/unmute.
 */
var RequestManager = /*#__PURE__*/function () {
  function RequestManager(store, listener) {
    this.store = store;
    this.listener = listener;
  }

  var _proto = RequestManager.prototype;

  _proto.handleRoleChangeRequest = function handleRoleChangeRequest(notification) {
    var _this$listener;

    var request = {
      requestedBy: this.store.getPeerById(notification.requested_by),
      role: this.store.getPolicyForRole(notification.role),
      token: notification.token
    };
    (_this$listener = this.listener) == null ? void 0 : _this$listener.onRoleChangeRequest(request);
  };

  _proto.handleTrackUpdateRequest = function handleTrackUpdateRequest(trackUpdateRequest) {
    var _this = this;

    var requested_by = trackUpdateRequest.requested_by,
        track_id = trackUpdateRequest.track_id,
        mute = trackUpdateRequest.mute;
    var peer = this.store.getPeerById(requested_by);
    var track = this.store.getLocalPeerTracks().find(function (track) {
      return track.publishedTrackId === track_id;
    });

    if (!peer || peer.isLocal || !track) {
      return;
    }

    var sendNotification = function sendNotification() {
      var _this$listener2;

      (_this$listener2 = _this.listener) == null ? void 0 : _this$listener2.onChangeTrackStateRequest({
        requestedBy: peer,
        track: track,
        enabled: !mute
      });
    };

    if (mute) {
      // if track is already in the same state as change state, do nothing
      if (track.enabled === !mute) {
        return;
      }
      /**
       * Directly mute track when request arrives
       */


      track.setEnabled(!mute).then(sendNotification);
    } else {
      /**
       * Notify UI to unmute for requesting consent
       */
      sendNotification();
    }
  };

  _proto.handleChangeTrackStateRequest = function handleChangeTrackStateRequest(request) {
    var _this2 = this;

    var type = request.type,
        source = request.source,
        value = request.value,
        requested_by = request.requested_by;
    var peer = this.store.getPeerById(requested_by);

    if (!peer) {
      return;
    } // value true means the track has to be muted


    var enabled = !value;
    var localPeerTracks = this.store.getLocalPeerTracks();
    var tracks = localPeerTracks;

    if (type) {
      tracks = tracks.filter(function (track) {
        return track.type === type;
      });
    }

    if (source) {
      tracks = tracks.filter(function (track) {
        return track.source === source;
      });
    }

    var tracksToBeUpdated = tracks.filter(function (track) {
      return track.enabled !== enabled;
    }); //Do nothing if all tracks are already in same state as the request

    if (tracksToBeUpdated.length === 0) {
      return;
    } // if track is to be muted, mute and send the notification, otherwise send notification


    if (!enabled) {
      var promises = [];

      for (var _iterator = _createForOfIteratorHelperLoose(tracksToBeUpdated), _step; !(_step = _iterator()).done;) {
        var track = _step.value;
        promises.push(track.setEnabled(false));
      }

      Promise.all(promises).then(function () {
        var _this2$listener;

        (_this2$listener = _this2.listener) == null ? void 0 : _this2$listener.onChangeMultiTrackStateRequest({
          requestedBy: peer,
          tracks: tracksToBeUpdated,
          enabled: false
        });
      });
    } else {
      var _this$listener3;

      (_this$listener3 = this.listener) == null ? void 0 : _this$listener3.onChangeMultiTrackStateRequest({
        requestedBy: peer,
        tracks: tracksToBeUpdated,
        type: type,
        source: source,
        enabled: true
      });
    }
  };

  return RequestManager;
}();

var RoomUpdateManager = /*#__PURE__*/function () {
  function RoomUpdateManager(store, listener) {
    this.store = store;
    this.listener = listener;
  }

  var _proto = RoomUpdateManager.prototype;

  _proto.onPeerList = function onPeerList(notification) {
    var _this$listener;

    var _notification$room = notification.room,
        recording = _notification$room.recording,
        streaming = _notification$room.streaming;
    var room = this.store.getRoom();

    if (!room.recording) {
      room.recording = this.getDefaultRecordingState();
    }

    if (!room.rtmp) {
      room.rtmp = {
        running: false
      };
    }

    room.recording.server.running = recording.sfu.enabled;
    room.recording.browser.running = recording.beam.enabled;
    room.rtmp.running = streaming.enabled;
    (_this$listener = this.listener) == null ? void 0 : _this$listener.onRoomUpdate(exports.HMSRoomUpdate.RECORDING_STATE_UPDATED, room);
  };

  _proto.onRTMPStart = function onRTMPStart() {
    this.setRTMPStatus(true);
  };

  _proto.onRTMPStop = function onRTMPStop() {
    this.setRTMPStatus(false);
  };

  _proto.onRecordingStart = function onRecordingStart(notification) {
    this.setRecordingStatus(notification.type, true);
  };

  _proto.onRecordingStop = function onRecordingStop(notification) {
    this.setRecordingStatus(notification.type, false);
  };

  _proto.setRecordingStatus = function setRecordingStatus(type, running) {
    var _this$listener2;

    var room = this.store.getRoom();

    if (!room.recording) {
      room.recording = this.getDefaultRecordingState();
    }

    var action = -1;

    if (type === 'sfu') {
      room.recording.server.running = running;
      action = exports.HMSRoomUpdate.SERVER_RECORDING_STATE_UPDATED;
    } else {
      room.recording.browser.running = running;
      action = exports.HMSRoomUpdate.BROWSER_RECORDING_STATE_UPDATED;
    }

    (_this$listener2 = this.listener) == null ? void 0 : _this$listener2.onRoomUpdate(action, room);
  };

  _proto.setRTMPStatus = function setRTMPStatus(running) {
    var _this$listener3;

    var room = this.store.getRoom();

    if (!room.rtmp) {
      room.rtmp = {
        running: false
      };
    }

    room.rtmp.running = running;
    (_this$listener3 = this.listener) == null ? void 0 : _this$listener3.onRoomUpdate(exports.HMSRoomUpdate.RTMP_STREAMING_STATE_UPDATED, room);
  };

  _proto.getDefaultRecordingState = function getDefaultRecordingState() {
    return {
      browser: {
        running: false
      },
      server: {
        running: false
      }
    };
  };

  return RoomUpdateManager;
}();

/**
 * Handles:
 * - Incoming track meta-data from BIZ(signal) to match a track to a peer.
 * - Incoming MediaStreamTracks(wrapped in HMSTracks) from RTCMediaChannel.
 * - Mute/unmute track meta-data updates from BIZ.
 *
 * Since track meta-data and RTC tracks come in asynchronously,
 * we store the track meta-data(TrackState) in SDK Store and tracks temporarily here in tracksToProcess.
 *
 * Once we have both TrackState and track,
 * we add it to peer, send listener.onTrackUpdate and remove it from tracksToProcess.
 *
 * Gotchas:
 * - TRACK_UPDATE comes before TRACK_ADD -> update state, process pending tracks when TRACK_ADD arrives.
 */

var TrackManager = /*#__PURE__*/function () {
  function TrackManager(store, eventEmitter, listener) {
    var _this = this;

    this.store = store;
    this.eventEmitter = eventEmitter;
    this.listener = listener;
    this.tracksToProcess = new Map();
    /**
     * Sets the tracks to peer and returns the peer
     */

    this.handleTrackAdd = function (track) {
      HMSLogger.d(_this.TAG, "ONTRACKADD", track, track.nativeTrack);

      _this.store.addTrack(track);

      _this.tracksToProcess.set(track.trackId, track);

      _this.processPendingTracks();
    };
    /**
     * Sets the track of corresponding peer to null and returns the peer
     */


    this.handleTrackRemove = function (track) {
      var _this$listener;

      HMSLogger.d(_this.TAG, "ONTRACKREMOVE", track, track.nativeTrack);

      var trackStateEntry = _this.store.getTrackState(track.trackId);

      if (!trackStateEntry) return; // emit this event here as peer will already be removed(if left the room) by the time this event is received

      track.type === exports.HMSTrackType.AUDIO && _this.eventEmitter.emit('track-removed', {
        detail: track
      });

      var hmsPeer = _this.store.getPeerById(trackStateEntry.peerId);

      if (!hmsPeer) {
        return;
      }

      var removeAuxiliaryTrack = function removeAuxiliaryTrack() {
        var auxiliaryTrackIndex = hmsPeer.auxiliaryTracks.indexOf(track);

        if (auxiliaryTrackIndex > -1) {
          hmsPeer.auxiliaryTracks.splice(auxiliaryTrackIndex, 1);
        }
      };

      switch (track.type) {
        case exports.HMSTrackType.AUDIO:
          if (track.source !== 'regular') {
            removeAuxiliaryTrack();
          } else {
            hmsPeer.audioTrack = undefined;
          }

          break;

        case exports.HMSTrackType.VIDEO:
          {
            if (track.source !== 'regular') {
              removeAuxiliaryTrack();
            } else {
              hmsPeer.videoTrack = undefined;
            }
          }
      }

      _this.store.removeTrack(track.trackId);

      (_this$listener = _this.listener) == null ? void 0 : _this$listener.onTrackUpdate(exports.HMSTrackUpdate.TRACK_REMOVED, track, hmsPeer);
    };

    this.handleTrackUpdate = function (params) {
      HMSLogger.d(_this.TAG, "TRACK_UPDATE", params);

      var hmsPeer = _this.store.getPeerById(params.peer.peer_id);

      if (!hmsPeer) {
        return;
      }

      for (var trackId in params.tracks) {
        var _this$store$getTrackS;

        var currentTrackStateInfo = Object.assign({}, (_this$store$getTrackS = _this.store.getTrackState(trackId)) == null ? void 0 : _this$store$getTrackS.trackInfo);
        var trackEntry = params.tracks[trackId];

        var track = _this.store.getTrackById(trackId);

        _this.store.setTrackState({
          peerId: params.peer.peer_id,
          trackInfo: _extends({}, currentTrackStateInfo, trackEntry)
        }); // TRACK_UPDATE came before TRACK_ADD -> update state, process pending tracks when TRACK_ADD arrives.


        if (!track || _this.tracksToProcess.has(trackId)) {
          _this.processPendingTracks();
        } else {
          track.setEnabled(!trackEntry.mute);

          if (currentTrackStateInfo.mute !== trackEntry.mute) {
            if (trackEntry.mute) {
              var _this$listener2;

              (_this$listener2 = _this.listener) == null ? void 0 : _this$listener2.onTrackUpdate(exports.HMSTrackUpdate.TRACK_MUTED, track, hmsPeer);
            } else {
              var _this$listener3;

              (_this$listener3 = _this.listener) == null ? void 0 : _this$listener3.onTrackUpdate(exports.HMSTrackUpdate.TRACK_UNMUTED, track, hmsPeer);
            }

            track.type === exports.HMSTrackType.AUDIO && _this.eventEmitter.emit('track-updated', {
              detail: {
                track: track,
                enabled: !trackEntry.mute
              }
            });
          } else if (currentTrackStateInfo.description !== trackEntry.description) {
            var _this$listener4;

            (_this$listener4 = _this.listener) == null ? void 0 : _this$listener4.onTrackUpdate(exports.HMSTrackUpdate.TRACK_DESCRIPTION_CHANGED, track, hmsPeer);
          }
        }
      }
    };
  }

  var _proto = TrackManager.prototype;

  _proto.handleTrackMetadataAdd = function handleTrackMetadataAdd(params) {
    HMSLogger.d(this.TAG, "TRACK_METADATA_ADD", params);

    for (var trackId in params.tracks) {
      this.store.setTrackState({
        peerId: params.peer.peer_id,
        trackInfo: params.tracks[trackId]
      });
    }

    this.processPendingTracks();
  };

  _proto.processPendingTracks = function processPendingTracks() {
    var _this2 = this;

    var tracksCopy = new Map(this.tracksToProcess);
    tracksCopy.forEach(function (track) {
      var _this2$listener;

      var state = _this2.store.getTrackState(track.trackId);

      if (!state) {
        return;
      }

      var hmsPeer = _this2.store.getPeerById(state.peerId);

      if (!hmsPeer) {
        return;
      }

      track.source = state.trackInfo.source;
      track.peerId = hmsPeer.peerId;
      track.setEnabled(!state.trackInfo.mute);

      switch (track.type) {
        case exports.HMSTrackType.AUDIO:
          if (!hmsPeer.audioTrack && track.source === 'regular') {
            hmsPeer.audioTrack = track;
          } else {
            hmsPeer.auxiliaryTracks.push(track);
          }

          break;

        case exports.HMSTrackType.VIDEO:
          var remoteTrack = track;

          var simulcastDefinitions = _this2.store.getSimulcastDefinitionsForPeer(hmsPeer, remoteTrack.source);

          remoteTrack.setSimulcastDefinitons(simulcastDefinitions);

          if (!hmsPeer.videoTrack && track.source === 'regular') {
            hmsPeer.videoTrack = remoteTrack;
          } else {
            hmsPeer.auxiliaryTracks.push(remoteTrack);
          }

      }
      /**
       * Don't call onTrackUpdate for audio elements immediately because the operations(eg: setVolume) performed
       * on onTrackUpdate can be overriden in AudioSinkManager when audio element is created
       **/


      track.type === exports.HMSTrackType.AUDIO ? _this2.eventEmitter.emit('track-added', {
        detail: {
          track: track,
          peer: hmsPeer
        }
      }) : (_this2$listener = _this2.listener) == null ? void 0 : _this2$listener.onTrackUpdate(exports.HMSTrackUpdate.TRACK_ADDED, track, hmsPeer);

      _this2.tracksToProcess["delete"](track.trackId);
    });
  };

  _createClass(TrackManager, [{
    key: "TAG",
    get: function get() {
      return "[" + this.constructor.name + "]";
    }
  }]);

  return TrackManager;
}();

var NotificationManager = /*#__PURE__*/function () {
  function NotificationManager(store, listener, audioListener) {
    var _this = this;

    this.store = store;
    this.listener = listener;
    this.audioListener = audioListener;
    this.TAG = '[HMSNotificationManager]';
    this.eventEmitter = new EventEmitter__default();

    this.handleTrackAdd = function (track) {
      _this.trackManager.handleTrackAdd(track);
    };

    this.handleTrackRemove = function (track) {
      _this.trackManager.handleTrackRemove(track);
    };

    this.trackManager = new TrackManager(this.store, this.eventEmitter, this.listener);
    this.peerManager = new PeerManager(this.store, this.trackManager, this.listener);
    this.peerListManager = new PeerListManager(this.store, this.peerManager, this.trackManager, this.listener);
    this.broadcastManager = new BroadcastManager(this.store, this.listener);
    this.policyChangeManager = new PolicyChangeManager(this.store, this.eventEmitter);
    this.requestManager = new RequestManager(this.store, this.listener);
    this.activeSpeakerManager = new ActiveSpeakerManager(this.store, this.listener, this.audioListener);
    this.roomUpdateManager = new RoomUpdateManager(this.store, this.listener);
  }

  var _proto = NotificationManager.prototype;

  _proto.setListener = function setListener(listener) {
    this.listener = listener;
    this.trackManager.listener = listener;
    this.peerManager.listener = listener;
    this.peerListManager.listener = listener;
    this.broadcastManager.listener = listener;
    this.requestManager.listener = listener;
    this.activeSpeakerManager.listener = listener;
    this.roomUpdateManager.listener = listener;
  };

  _proto.setAudioListener = function setAudioListener(audioListener) {
    this.audioListener = audioListener;
    this.activeSpeakerManager.audioListener = audioListener;
  };

  _proto.addEventListener = function addEventListener(event, listener) {
    this.eventEmitter.addListener(event, listener);
  };

  _proto.removeEventListener = function removeEventListener(event, listener) {
    this.eventEmitter.removeListener(event, listener);
  };

  _proto.once = function once(event, listener) {
    this.eventEmitter.once(event, listener);
  };

  _proto.handleNotification = function handleNotification(message, isReconnecting) {
    if (isReconnecting === void 0) {
      isReconnecting = false;
    }

    var method = message.method;
    var notification = message.params;

    if (method !== HMSNotificationMethod.ACTIVE_SPEAKERS) {
      HMSLogger.d(this.TAG, 'Received notification', {
        method: method,
        notification: notification
      });
    }

    switch (method) {
      case HMSNotificationMethod.PEER_JOIN:
        {
          var peer = notification;
          this.peerManager.handlePeerJoin(peer);
          break;
        }

      case HMSNotificationMethod.PEER_LEAVE:
        {
          var _peer = notification;
          this.peerManager.handlePeerLeave(_peer);
          break;
        }

      case HMSNotificationMethod.PEER_LIST:
        {
          var peerList = notification;

          if (isReconnecting) {
            HMSLogger.d(this.TAG, "RECONNECT_PEER_LIST event", peerList);
            this.peerListManager.handleReconnectPeerList(peerList);
          } else {
            HMSLogger.d(this.TAG, "PEER_LIST event", peerList);
            this.peerListManager.handleInitialPeerList(peerList);
          }

          this.roomUpdateManager.onPeerList(peerList);
          break;
        }

      case HMSNotificationMethod.TRACK_METADATA_ADD:
        {
          this.trackManager.handleTrackMetadataAdd(notification);
          break;
        }

      case HMSNotificationMethod.TRACK_UPDATE:
        {
          this.trackManager.handleTrackUpdate(notification);
          break;
        }

      case HMSNotificationMethod.ACTIVE_SPEAKERS:
        this.activeSpeakerManager.handleActiveSpeakers(notification);
        break;

      case HMSNotificationMethod.BROADCAST:
        this.broadcastManager.handleBroadcast(notification);
        break;

      case HMSNotificationMethod.POLICY_CHANGE:
        this.policyChangeManager.handlePolicyChange(notification);
        break;

      case HMSNotificationMethod.ROLE_CHANGE_REQUEST:
        this.requestManager.handleRoleChangeRequest(notification);
        break;

      case HMSNotificationMethod.TRACK_UPDATE_REQUEST:
        this.requestManager.handleTrackUpdateRequest(notification);
        break;

      case HMSNotificationMethod.CHANGE_TRACK_MUTE_STATE_UPDATE:
        this.requestManager.handleChangeTrackStateRequest(notification);
        break;

      case HMSNotificationMethod.PEER_UPDATE:
        this.peerManager.handlePeerUpdate(notification);
        break;

      case HMSNotificationMethod.RTMP_START:
        this.roomUpdateManager.onRTMPStart();
        break;

      case HMSNotificationMethod.RTMP_STOP:
        this.roomUpdateManager.onRTMPStop();
        break;

      case HMSNotificationMethod.RECORDING_START:
        this.roomUpdateManager.onRecordingStart(notification);
        break;

      case HMSNotificationMethod.RECORDING_STOP:
        this.roomUpdateManager.onRecordingStop(notification);
        break;

      default:
        return;
    }
  };

  return NotificationManager;
}();

/**
 * This is in a format biz sends/received the track metadata
 */

var TrackState = function TrackState(track) {
  this.type = track.type;
  this.source = track.source || 'regular';
  this.description = '';

  if (track instanceof HMSTrack) {
    this.mute = !track.enabled;
    this.track_id = track.publishedTrackId;
    this.stream_id = track.stream.id;
  } else {
    this.mute = track.mute;
    this.track_id = track.track_id;
    this.stream_id = track.stream_id;
  }
};

var TransportState;

(function (TransportState) {
  TransportState[TransportState["Disconnected"] = 0] = "Disconnected";
  TransportState[TransportState["Connecting"] = 1] = "Connecting";
  TransportState[TransportState["Joined"] = 2] = "Joined";
  TransportState[TransportState["Failed"] = 3] = "Failed";
  TransportState[TransportState["Reconnecting"] = 4] = "Reconnecting";
  TransportState[TransportState["Leaving"] = 5] = "Leaving";
})(TransportState || (TransportState = {}));

var AnalyticsEventFactory = /*#__PURE__*/function () {
  function AnalyticsEventFactory() {}

  AnalyticsEventFactory.connect = function connect(error, requestedAt, respondedAt, endpoint) {
    var _requestedAt, _respondedAt, _this$getPropertiesWi;

    if (requestedAt === void 0) {
      requestedAt = new Date();
    }

    if (respondedAt === void 0) {
      respondedAt = new Date();
    }

    var name = this.eventNameFor('connect', error === undefined);
    var level = error ? AnalyticsEventLevel.ERROR : AnalyticsEventLevel.INFO;
    var properties = this.getPropertiesWithError((_this$getPropertiesWi = {}, _this$getPropertiesWi[this.KEY_REQUESTED_AT] = (_requestedAt = requestedAt) == null ? void 0 : _requestedAt.getTime(), _this$getPropertiesWi[this.KEY_RESPONDED_AT] = (_respondedAt = respondedAt) == null ? void 0 : _respondedAt.getTime(), _this$getPropertiesWi.endpoint = endpoint, _this$getPropertiesWi), error);
    return new AnalyticsEvent({
      name: name,
      level: level,
      properties: properties
    });
  };

  AnalyticsEventFactory.disconnect = function disconnect(error) {
    var name = 'disconnected';
    var level = error ? AnalyticsEventLevel.ERROR : AnalyticsEventLevel.INFO;
    var properties = this.getPropertiesWithError({}, error);
    return new AnalyticsEvent({
      name: name,
      level: level,
      properties: properties
    });
  };

  AnalyticsEventFactory.join = function join(requestedAt, respondedAt, error) {
    var _this$getPropertiesWi2;

    var name = this.eventNameFor('join', error === undefined);
    var level = error ? AnalyticsEventLevel.ERROR : AnalyticsEventLevel.INFO;
    var properties = this.getPropertiesWithError((_this$getPropertiesWi2 = {}, _this$getPropertiesWi2[this.KEY_REQUESTED_AT] = requestedAt.getTime(), _this$getPropertiesWi2[this.KEY_RESPONDED_AT] = respondedAt.getTime(), _this$getPropertiesWi2), error);
    return new AnalyticsEvent({
      name: name,
      level: level,
      properties: properties
    });
  };

  AnalyticsEventFactory.publish = function publish(_ref) {
    var devices = _ref.devices,
        settings = _ref.settings,
        error = _ref.error;
    var name = this.eventNameFor('publish', error === undefined);
    var level = error ? AnalyticsEventLevel.ERROR : AnalyticsEventLevel.INFO;
    var properties = this.getPropertiesWithError({
      devices: devices,
      audio: settings == null ? void 0 : settings.audio,
      video: settings == null ? void 0 : settings.video
    }, error);
    return new AnalyticsEvent({
      name: name,
      level: level,
      properties: properties
    });
  };

  AnalyticsEventFactory.subscribeFail = function subscribeFail(error) {
    var name = this.eventNameFor('subscribe', false);
    var level = AnalyticsEventLevel.ERROR;
    var properties = error.toAnalyticsProperties();
    return new AnalyticsEvent({
      name: name,
      level: level,
      properties: properties
    });
  };

  AnalyticsEventFactory.leave = function leave() {
    return new AnalyticsEvent({
      name: 'leave',
      level: AnalyticsEventLevel.INFO
    });
  };

  AnalyticsEventFactory.deviceChange = function deviceChange(_ref2) {
    var selection = _ref2.selection,
        type = _ref2.type,
        devices = _ref2.devices,
        error = _ref2.error;
    var name = this.eventNameFor(error ? 'publish' : "device." + type, error === undefined);
    var level = error ? AnalyticsEventLevel.ERROR : AnalyticsEventLevel.INFO;
    var properties = this.getPropertiesWithError({
      selection: selection,
      devices: devices
    }, error);
    return new AnalyticsEvent({
      name: name,
      level: level,
      properties: properties
    });
  };

  AnalyticsEventFactory.performance = function performance(stats) {
    var name = 'perf.stats';
    var level = AnalyticsEventLevel.INFO;
    var properties = stats.toAnalyticsProperties();
    return new AnalyticsEvent({
      name: name,
      level: level,
      properties: properties
    });
  };

  AnalyticsEventFactory.rtcStats = function rtcStats(stats) {
    var name = 'rtc.stats';
    var level = AnalyticsEventLevel.INFO;
    var properties = stats.toAnalyticsProperties();
    return new AnalyticsEvent({
      name: name,
      level: level,
      properties: properties
    });
  };

  AnalyticsEventFactory.eventNameFor = function eventNameFor(name, ok) {
    var suffix = ok ? 'success' : 'failed';
    return name + "." + suffix;
  };

  AnalyticsEventFactory.getPropertiesWithError = function getPropertiesWithError(initialProperties, error) {
    if (error) {
      initialProperties = _extends({}, error.toAnalyticsProperties(), initialProperties);
    }

    return initialProperties;
  };

  return AnalyticsEventFactory;
}();
AnalyticsEventFactory.KEY_REQUESTED_AT = 'requested_at';
AnalyticsEventFactory.KEY_RESPONDED_AT = 'responded_at';

var JoinParameters = function JoinParameters(authToken, peerId, peerName, data, endpoint, autoSubscribeVideo) {
  this.authToken = authToken;
  this.peerId = peerId;
  this.peerName = peerName;
  this.data = data;
  this.endpoint = endpoint;
  this.autoSubscribeVideo = autoSubscribeVideo;
};

var _Dependencies;

var TransportFailureCategory;

(function (TransportFailureCategory) {
  TransportFailureCategory[TransportFailureCategory["ConnectFailed"] = 0] = "ConnectFailed";
  TransportFailureCategory[TransportFailureCategory["SignalDisconnect"] = 1] = "SignalDisconnect";
  TransportFailureCategory[TransportFailureCategory["PublishIceConnectionFailed"] = 2] = "PublishIceConnectionFailed";
  TransportFailureCategory[TransportFailureCategory["SubscribeIceConnectionFailed"] = 3] = "SubscribeIceConnectionFailed";
})(TransportFailureCategory || (TransportFailureCategory = {}));

var Dependencies = (_Dependencies = {}, _Dependencies[TransportFailureCategory.ConnectFailed] = [], _Dependencies[TransportFailureCategory.SignalDisconnect] = [], _Dependencies[TransportFailureCategory.PublishIceConnectionFailed] = [TransportFailureCategory.SignalDisconnect], _Dependencies[TransportFailureCategory.SubscribeIceConnectionFailed] = [TransportFailureCategory.SignalDisconnect], _Dependencies);

var PromiseWithCallbacks = function PromiseWithCallbacks(cb) {
  var _this = this;

  this.promise = new Promise(function (resolve, reject) {
    _this.resolve = resolve;
    _this.reject = reject;
    cb(resolve, reject);
  });
};

var TAG$a = '[RetryScheduler]';
var RetryScheduler = /*#__PURE__*/function () {
  function RetryScheduler(analyticsEventsService, onStateChange) {
    this.inProgress = new Map();
    this.retryTaskIds = [];
    this.analyticsEventsService = analyticsEventsService;
    this.onStateChange = onStateChange;
  }

  var _proto = RetryScheduler.prototype;

  _proto.schedule = /*#__PURE__*/function () {
    var _schedule = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(category, error, task, maxFailedRetries, changeState) {
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (maxFailedRetries === void 0) {
                maxFailedRetries = MAX_TRANSPORT_RETRIES;
              }

              if (changeState === void 0) {
                changeState = true;
              }

              _context.next = 4;
              return this.scheduleTask(category, error, changeState, task, maxFailedRetries);

            case 4:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function schedule(_x, _x2, _x3, _x4, _x5) {
      return _schedule.apply(this, arguments);
    }

    return schedule;
  }();

  _proto.reset = function reset() {
    this.retryTaskIds.forEach(function (future) {
      return clearTimeout(future);
    });
    this.retryTaskIds = [];
    this.inProgress.clear();
  };

  _proto.scheduleTask = /*#__PURE__*/function () {
    var _scheduleTask = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(category, error, changeState, task, maxFailedRetries, failedRetryCount) {
      var inProgressTask, taskPromise, hasFailedDependency, dependencies, dependencyIndexString, dependency, dependencyTask, delay, taskSucceeded, _taskPromise;

      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (maxFailedRetries === void 0) {
                maxFailedRetries = MAX_TRANSPORT_RETRIES;
              }

              if (failedRetryCount === void 0) {
                failedRetryCount = 0;
              }

              HMSLogger.d(TAG$a, 'schedule: ', {
                category: TransportFailureCategory[category],
                error: error
              }); // First schedule call

              if (!(failedRetryCount === 0)) {
                _context2.next = 13;
                break;
              }

              inProgressTask = this.inProgress.get(category);

              if (!inProgressTask) {
                _context2.next = 10;
                break;
              }

              HMSLogger.d(TAG$a, "schedule: Already a task for " + TransportFailureCategory[category] + " scheduled, waiting for its completion");
              _context2.next = 9;
              return inProgressTask.promise;

            case 9:
              return _context2.abrupt("return");

            case 10:
              taskPromise = new PromiseWithCallbacks(function (_, __) {});
              this.inProgress.set(category, taskPromise);
              this.sendEvent(error, category);

            case 13:
              hasFailedDependency = false;
              dependencies = Dependencies[category];
              _context2.t0 = runtime_1.keys(dependencies);

            case 16:
              if ((_context2.t1 = _context2.t0()).done) {
                _context2.next = 35;
                break;
              }

              dependencyIndexString = _context2.t1.value;
              dependency = dependencies[parseInt(dependencyIndexString)];
              _context2.prev = 19;
              dependencyTask = this.inProgress.get(dependency);

              if (!dependencyTask) {
                _context2.next = 26;
                break;
              }

              HMSLogger.d(TAG$a, "schedule: Suspending retry task of " + TransportFailureCategory[category] + ", waiting for " + TransportFailureCategory[dependency] + " to recover");
              _context2.next = 25;
              return dependencyTask.promise;

            case 25:
              HMSLogger.d(TAG$a, "schedule: Resuming retry task " + TransportFailureCategory[category] + " as it's dependency " + TransportFailureCategory[dependency] + " is recovered");

            case 26:
              _context2.next = 33;
              break;

            case 28:
              _context2.prev = 28;
              _context2.t2 = _context2["catch"](19);
              HMSLogger.d(TAG$a, "schedule: Stopping retry task of " + TransportFailureCategory[category] + " as it's dependency " + TransportFailureCategory[dependency] + " failed to recover");
              hasFailedDependency = true;
              return _context2.abrupt("break", 35);

            case 33:
              _context2.next = 16;
              break;

            case 35:
              if (!(failedRetryCount >= maxFailedRetries || hasFailedDependency)) {
                _context2.next = 48;
                break;
              }

              error.description += ". [" + TransportFailureCategory[category] + "] Could not recover after " + failedRetryCount + " tries";

              if (hasFailedDependency) {
                error.description += " Could not recover all of it's required dependencies - [" + dependencies.map(function (dep) {
                  return TransportFailureCategory[dep];
                }).toString() + "]";
              }

              error.isTerminal = true; // @NOTE: Don't reject to throw error for dependencies, use onStateChange
              // const taskPromise = this.inProgress.get(category);

              this.inProgress["delete"](category); // taskPromise?.reject(error);

              this.sendEvent(error, category);
              this.reset();

              if (!changeState) {
                _context2.next = 46;
                break;
              }

              this.onStateChange(TransportState.Failed, error);
              _context2.next = 47;
              break;

            case 46:
              throw error;

            case 47:
              return _context2.abrupt("return");

            case 48:
              if (changeState) {
                this.onStateChange(TransportState.Reconnecting, error);
              }

              delay = this.getDelayForRetryCount(failedRetryCount);
              HMSLogger.i(TAG$a, "schedule: [" + TransportFailureCategory[category] + "] [failedRetryCount=" + failedRetryCount + "] Scheduling retry task in " + delay + "ms");
              _context2.prev = 51;
              _context2.next = 54;
              return this.setTimeoutPromise(task, delay);

            case 54:
              taskSucceeded = _context2.sent;
              _context2.next = 61;
              break;

            case 57:
              _context2.prev = 57;
              _context2.t3 = _context2["catch"](51);
              taskSucceeded = false;
              HMSLogger.w(TAG$a, "[" + TransportFailureCategory[category] + "] Un-caught exception " + _context2.t3.name + " in retry-task, initiating retry", _context2.t3);

            case 61:
              if (!taskSucceeded) {
                _context2.next = 69;
                break;
              }

              _taskPromise = this.inProgress.get(category);
              this.inProgress["delete"](category);
              _taskPromise == null ? void 0 : _taskPromise.resolve(failedRetryCount);

              if (changeState && this.inProgress.size === 0) {
                this.onStateChange(TransportState.Joined);
              }

              HMSLogger.i(TAG$a, "schedule: [" + TransportFailureCategory[category] + "] [failedRetryCount=" + failedRetryCount + "] Recovered \u267B\uFE0F");
              _context2.next = 71;
              break;

            case 69:
              _context2.next = 71;
              return this.scheduleTask(category, error, changeState, task, maxFailedRetries, failedRetryCount + 1);

            case 71:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this, [[19, 28], [51, 57]]);
    }));

    function scheduleTask(_x6, _x7, _x8, _x9, _x10, _x11) {
      return _scheduleTask.apply(this, arguments);
    }

    return scheduleTask;
  }();

  _proto.sendEvent = function sendEvent(error, category) {
    var event;

    switch (category) {
      case TransportFailureCategory.ConnectFailed:
        event = AnalyticsEventFactory.connect(error);
        break;

      case TransportFailureCategory.SignalDisconnect:
        event = AnalyticsEventFactory.disconnect(error);
        break;

      case TransportFailureCategory.PublishIceConnectionFailed:
        event = AnalyticsEventFactory.publish({
          error: error
        });
        break;

      case TransportFailureCategory.SubscribeIceConnectionFailed:
        event = AnalyticsEventFactory.subscribeFail(error);
        break;
    }

    this.analyticsEventsService.queue(event).flush();
  };

  _proto.getDelayForRetryCount = function getDelayForRetryCount(n) {
    var delay = Math.pow(2, n);
    var jitter = Math.random();
    return Math.round(Math.min(delay + jitter, MAX_TRANSPORT_RETRY_DELAY) * 1000);
  };

  _proto.setTimeoutPromise = /*#__PURE__*/function () {
    var _setTimeoutPromise = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4(task, delay) {
      var _this = this;

      return runtime_1.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              return _context4.abrupt("return", new Promise(function (resolve, reject) {
                var timeoutId = window.setTimeout( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3() {
                  var value;
                  return runtime_1.wrap(function _callee3$(_context3) {
                    while (1) {
                      switch (_context3.prev = _context3.next) {
                        case 0:
                          _context3.prev = 0;
                          _context3.next = 3;
                          return task();

                        case 3:
                          value = _context3.sent;
                          value && _this.retryTaskIds.splice(_this.retryTaskIds.indexOf(timeoutId), 1);
                          resolve(value);
                          _context3.next = 11;
                          break;

                        case 8:
                          _context3.prev = 8;
                          _context3.t0 = _context3["catch"](0);
                          reject(_context3.t0);

                        case 11:
                        case "end":
                          return _context3.stop();
                      }
                    }
                  }, _callee3, null, [[0, 8]]);
                })), delay);

                _this.retryTaskIds.push(timeoutId);
              }));

            case 1:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    }));

    function setTimeoutPromise(_x12, _x13) {
      return _setTimeoutPromise.apply(this, arguments);
    }

    return setTimeoutPromise;
  }();

  return RetryScheduler;
}();

var AnalyticsTransport = /*#__PURE__*/function () {
  function AnalyticsTransport() {}

  var _proto = AnalyticsTransport.prototype;

  _proto.sendEvent = function sendEvent(event) {
    try {
      this.sendSingleEvent(event);
      this.flushFailedEvents();
    } catch (error) {}
  };

  _proto.flushFailedEvents = function flushFailedEvents() {
    try {
      HMSLogger.d(this.TAG, 'Flushing failed events', this.failedEvents);

      while (this.failedEvents.size() > 0) {
        var event = this.failedEvents.dequeue();
        if (event) this.sendSingleEvent(event);
      }
    } catch (error) {
      HMSLogger.w(this.TAG, 'flushFailedEvents failed', error);
    }
  };

  _proto.sendSingleEvent = function sendSingleEvent(event) {
    try {
      HMSLogger.d(this.TAG, 'Sending event', {
        event: event
      });
      this.transportProvider.sendEvent(event);
    } catch (error) {
      HMSLogger.w(this.TAG, this.transportProvider.constructor.name + ".sendEvent failed, adding to local storage events", {
        event: event,
        error: error
      });
      this.failedEvents.enqueue(event);
      throw error;
    }
  };

  _createClass(AnalyticsTransport, [{
    key: "TAG",
    get: function get() {
      return "[" + this.constructor.name + "]";
    }
  }]);

  return AnalyticsTransport;
}();

var Queue = /*#__PURE__*/function () {
  function Queue(capacity) {
    if (capacity === void 0) {
      capacity = Infinity;
    }

    this.capacity = capacity;
    this.storage = [];
  }

  var _proto = Queue.prototype;

  _proto.size = function size() {
    return this.storage.length;
  };

  _proto.enqueue = function enqueue(item) {
    if (this.size() === this.capacity) {
      throw Error('Queue has reached max capacity, cannot add more items');
    }

    this.storage.push(item);
  };

  _proto.dequeue = function dequeue() {
    return this.storage.shift();
  };

  return Queue;
}();

var LocalStorageEvents = /*#__PURE__*/function (_Queue) {
  _inheritsLoose(LocalStorageEvents, _Queue);

  function LocalStorageEvents() {
    var _this;

    _this = _Queue.call(this, ANALYTICS_BUFFER_SIZE) || this;
    _this.localStorage = new LocalStorage('hms-analytics'); // @TODO: Currently we don't send failed events of old sessions. So reset localstorage for every session.
    // Once support for failed events from old sessions is added, remove clear and init queue from localstorage.

    _this.localStorage.clear();

    _this.initLocalStorageQueue();

    return _this;
  }

  var _proto = LocalStorageEvents.prototype;

  _proto.enqueue = function enqueue(event) {
    _Queue.prototype.enqueue.call(this, event);

    this.localStorage.set(this.storage);
  };

  _proto.dequeue = function dequeue() {
    var removedEvent = _Queue.prototype.dequeue.call(this);

    this.localStorage.set(this.storage);
    return removedEvent;
  };

  _proto.initLocalStorageQueue = function initLocalStorageQueue() {
    var _this$localStorage$ge,
        _this2 = this;

    (_this$localStorage$ge = this.localStorage.get()) == null ? void 0 : _this$localStorage$ge.forEach(function (event) {
      var eventInstance = new AnalyticsEvent(event);

      _Queue.prototype.enqueue.call(_this2, eventInstance);
    });
  };

  return LocalStorageEvents;
}(Queue);

var SignalAnalyticsTransport = /*#__PURE__*/function (_AnalyticsTransport) {
  _inheritsLoose(SignalAnalyticsTransport, _AnalyticsTransport);

  function SignalAnalyticsTransport(transportProvider) {
    var _this;

    _this = _AnalyticsTransport.call(this) || this;
    _this.transportProvider = transportProvider;
    _this.failedEvents = new LocalStorageEvents();
    return _this;
  }

  return SignalAnalyticsTransport;
}(AnalyticsTransport);

var RTCStatsMonitor = /*#__PURE__*/function (_TypedEventEmitter) {
  _inheritsLoose(RTCStatsMonitor, _TypedEventEmitter);

  function RTCStatsMonitor(connections, interval) {
    var _this;

    if (interval === void 0) {
      interval = RTC_STATS_MONITOR_INTERVAL;
    }

    _this = _TypedEventEmitter.call(this) || this;
    _this.connections = connections;
    _this.interval = interval;
    _this.isMonitored = false;
    return _this;
  }

  var _proto = RTCStatsMonitor.prototype;

  _proto.start = /*#__PURE__*/function () {
    var _start = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee() {
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              this.stop();
              this.isMonitored = true;
              HMSLogger.d('Starting RTCStatsMonitor');
              this.startLoop().then(function () {
                return HMSLogger.d('Stopping RTCStatsMonitor');
              });

            case 4:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function start() {
      return _start.apply(this, arguments);
    }

    return start;
  }();

  _proto.stop = function stop() {
    this.isMonitored = false;
  };

  _proto.startLoop = /*#__PURE__*/function () {
    var _startLoop = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2() {
      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (!this.isMonitored) {
                _context2.next = 7;
                break;
              }

              _context2.next = 3;
              return this.handleConnectionsStats();

            case 3:
              _context2.next = 5;
              return sleep(this.interval);

            case 5:
              _context2.next = 0;
              break;

            case 7:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));

    function startLoop() {
      return _startLoop.apply(this, arguments);
    }

    return startLoop;
  }();

  _proto.handleConnectionsStats = /*#__PURE__*/function () {
    var _handleConnectionsStats = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3() {
      var totalPacketsLost, availableIncomingBitrate, availableOutgoingBitrate, _iterator, _step, conn, stats;

      return runtime_1.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              totalPacketsLost = 0;
              availableIncomingBitrate = 0;
              availableOutgoingBitrate = 0;
              _iterator = _createForOfIteratorHelperLoose(this.connections);

            case 4:
              if ((_step = _iterator()).done) {
                _context3.next = 12;
                break;
              }

              conn = _step.value;
              _context3.next = 8;
              return conn.getStats();

            case 8:
              stats = _context3.sent;
              stats.forEach(function (stat) {
                if (stat.packetsLost) totalPacketsLost += stat.packetsLost;
                if (stat.availableIncomingBitrate) availableIncomingBitrate = Number(stat.availableIncomingBitrate);
                if (stat.availableOutgoingBitrate) availableOutgoingBitrate = Number(stat.availableOutgoingBitrate);
              });

            case 10:
              _context3.next = 4;
              break;

            case 12:
              this.emit('RTC_STATS_CHANGE', {
                packetsLost: totalPacketsLost,
                availableIncomingBitrate: availableIncomingBitrate,
                availableOutgoingBitrate: availableOutgoingBitrate
              });

            case 13:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, this);
    }));

    function handleConnectionsStats() {
      return _handleConnectionsStats.apply(this, arguments);
    }

    return handleConnectionsStats;
  }();

  return RTCStatsMonitor;
}(TypedEventEmitter);

/** @see docs/Subscribe-Degradation.md */

var TrackDegradationController = /*#__PURE__*/function (_TypedEventEmitter) {
  _inheritsLoose(TrackDegradationController, _TypedEventEmitter);

  function TrackDegradationController(store) {
    var _this;

    _this = _TypedEventEmitter.call(this) || this;
    _this.store = store;
    _this.TAG = '[TrackDegradationController]';
    _this.MAX_RECOVER_GRACE_PERIOD = 120;
    _this.recoverAttemptCount = 0;
    _this.packetsLost = 0;

    var storeParams = _this.store.getSubscribeDegradationParams();

    _this.PACKETS_LOST_THRESHOLD = storeParams.packetLossThreshold;
    _this.MIN_DEGRADE_GRACE_PERIOD = storeParams.degradeGracePeriodSeconds;
    _this.MIN_RECOVER_GRACE_PERIOD = storeParams.recoverGracePeriodSeconds;
    _this.degradeGracePeriod = _this.MIN_DEGRADE_GRACE_PERIOD;
    _this.recoverGracePeriod = _this.MIN_RECOVER_GRACE_PERIOD;
    return _this;
  }

  var _proto = TrackDegradationController.prototype;

  _proto.handleRtcStatsChange = function handleRtcStatsChange(rtcStats) {
    /**
     * rtcStats.packetLost is a running counter
     * Degrade if packetsLost increase is greater than threshold
     */
    var shouldDegrade = rtcStats.packetsLost > this.packetsLost + this.PACKETS_LOST_THRESHOLD;
    this.packetsLost = rtcStats.packetsLost;
    shouldDegrade ? this.degrade() : this.recover();
  };

  _proto.degrade = function degrade() {
    if (this.degradeGracePeriod > 0) {
      this.degradeGracePeriod--;
      return;
    }

    if (this.isAttemptingRecover) {
      return this.cancelRecovery();
    }

    HMSLogger.d(this.TAG, 'Packet loss increased, Degrading', {
      packetsLost: this.packetsLost
    });
    this.degradeActiveTracksByHalf();
    this.degradeGracePeriod = this.MIN_DEGRADE_GRACE_PERIOD;
    this.recoverGracePeriod = this.MIN_RECOVER_GRACE_PERIOD;
  };

  _proto.recover = function recover() {
    this.degradeGracePeriod = this.MIN_DEGRADE_GRACE_PERIOD;

    if (this.recoverGracePeriod > 0) {
      this.recoverGracePeriod--;
      return;
    }

    this.recoveringTrack = this.getActiveTracks(true).find(function (track) {
      return track.degraded;
    });

    if (!this.recoveringTrack) {
      return;
    }

    HMSLogger.d(this.TAG, 'Packet lost stable, recovering track', this.recoveringTrack);
    this.recoveringTrack.setDegraded(false);
    this.emit('TRACK_RESTORED', this.recoveringTrack);
    this.recoverGracePeriod = this.MIN_RECOVER_GRACE_PERIOD;
  };

  _proto.degradeActiveTracksByHalf = function degradeActiveTracksByHalf() {
    var activeTracks = this.getActiveTracks(false);
    if (!activeTracks.length) return;
    HMSLogger.d(this.TAG, {
      activeTracks: [].concat(activeTracks)
    });
    var halfCount = Math.ceil(activeTracks.length / 2);

    while (halfCount--) {
      var track = activeTracks.pop();
      track.setDegraded(true);
      this.emit('TRACK_DEGRADED', track);
    }
  };

  _proto.getActiveTracks = function getActiveTracks(includeDegraded) {
    var _this2 = this;

    return this.store.getRemoteVideoTracks().filter(function (track) {
      return track.hasSinks() && (!track.degraded || includeDegraded);
    }).sort(function (trackA, trackB) {
      var comparators = _this2.store.getComparator().getTrackComparators();
      /**
       * Sort in descending order of importance.
       * Importance: Screenshare > Role Priority > Speaker > TrackId
       */


      return -1 * (comparators.screenShare(trackA, trackB) || comparators.rolePriority(trackA, trackB) || comparators.peerAudioLevel(trackA, trackB) || _this2.store.getComparator().stringComparator(trackA.trackId, trackB.trackId));
    }).slice(0); // Shallow copy - clone array, keep track references
  };

  _proto.cancelRecovery = function cancelRecovery() {
    if (this.recoveringTrack) {
      this.recoveringTrack.setDegraded(true);
      this.emit('TRACK_DEGRADED', this.recoveringTrack);
    }

    this.recoveringTrack = undefined;
    this.recoverAttemptCount++;
    this.recoverGracePeriod = this.getDelayForRecoverCount(this.recoverAttemptCount);
    this.degradeGracePeriod = this.MIN_DEGRADE_GRACE_PERIOD;
    HMSLogger.d(this.TAG, 'Recover Attempt Failed', {
      count: this.recoverAttemptCount,
      delay: this.recoverGracePeriod
    });
  };

  _proto.getDelayForRecoverCount = function getDelayForRecoverCount(count) {
    var delay = this.MIN_RECOVER_GRACE_PERIOD + this.MIN_RECOVER_GRACE_PERIOD * count;
    return Math.min(delay, this.MAX_RECOVER_GRACE_PERIOD);
  };

  _createClass(TrackDegradationController, [{
    key: "isAttemptingRecover",
    get: function get() {
      return Boolean(this.recoveringTrack);
    }
  }]);

  return TrackDegradationController;
}(TypedEventEmitter);

var TAG$b = '[HMSTransport]:';

var HMSTransport = /*#__PURE__*/function () {
  function HMSTransport(observer, deviceManager, store) {
    var _this = this;

    this.observer = observer;
    this.deviceManager = deviceManager;
    this.store = store;
    this.state = TransportState.Disconnected;
    this.trackStates = new Map();
    this.publishConnection = null;
    this.subscribeConnection = null;
    this.retryScheduler = new RetryScheduler(analyticsEventsService, /*#__PURE__*/function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(state, error) {
        return runtime_1.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(state !== _this.state)) {
                  _context.next = 4;
                  break;
                }

                _this.state = state;
                _context.next = 4;
                return _this.observer.onStateChange(_this.state, error);

              case 4:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      return function (_x, _x2) {
        return _ref.apply(this, arguments);
      };
    }());
    /**
     * Map of callbacks used to wait for an event to fire.
     * Used here for:
     *  1. publish/unpublish waits for [IPublishConnectionObserver.onRenegotiationNeeded] to complete
     */

    this.callbacks = new Map();
    this.signalObserver = {
      onOffer: function () {
        var _onOffer = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(jsep) {
          var _iterator, _step, candidate, answer, ex;

          return runtime_1.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  _context2.prev = 0;
                  _context2.next = 3;
                  return _this.subscribeConnection.setRemoteDescription(jsep);

                case 3:
                  HMSLogger.d(TAG$b, "[SUBSCRIBE] Adding " + _this.subscribeConnection.candidates.length + " ice-candidates", _this.subscribeConnection.candidates);
                  _iterator = _createForOfIteratorHelperLoose(_this.subscribeConnection.candidates);

                case 5:
                  if ((_step = _iterator()).done) {
                    _context2.next = 11;
                    break;
                  }

                  candidate = _step.value;
                  _context2.next = 9;
                  return _this.subscribeConnection.addIceCandidate(candidate);

                case 9:
                  _context2.next = 5;
                  break;

                case 11:
                  _this.subscribeConnection.candidates.length = 0;
                  _context2.next = 14;
                  return _this.subscribeConnection.createAnswer();

                case 14:
                  answer = _context2.sent;
                  _context2.next = 17;
                  return _this.subscribeConnection.setLocalDescription(answer);

                case 17:
                  _this.signal.answer(answer);

                  HMSLogger.d(TAG$b, '[role=SUBSCRIBE] onOffer renegotiation DONE ✅');
                  _context2.next = 28;
                  break;

                case 21:
                  _context2.prev = 21;
                  _context2.t0 = _context2["catch"](0);
                  HMSLogger.d(TAG$b, '[role=SUBSCRIBE] onOffer renegotiation FAILED ❌');
                  _this.state = TransportState.Failed;

                  if (_context2.t0 instanceof HMSException) {
                    ex = _context2.t0;
                  } else {
                    ex = ErrorFactory.GenericErrors.Unknown(HMSAction.PUBLISH, _context2.t0.message);
                  }

                  analyticsEventsService.queue(AnalyticsEventFactory.subscribeFail(ex)).flush();
                  throw ex;

                case 28:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2, null, [[0, 21]]);
        }));

        function onOffer(_x3) {
          return _onOffer.apply(this, arguments);
        }

        return onOffer;
      }(),
      onTrickle: function () {
        var _onTrickle = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3(trickle) {
          var connection;
          return runtime_1.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  connection = trickle.target === HMSConnectionRole.Publish ? _this.publishConnection : _this.subscribeConnection;

                  if (!(connection.remoteDescription === null)) {
                    _context3.next = 5;
                    break;
                  }

                  // ICE candidates can't be added without any remote session description
                  connection.candidates.push(trickle.candidate);
                  _context3.next = 7;
                  break;

                case 5:
                  _context3.next = 7;
                  return connection.addIceCandidate(trickle.candidate);

                case 7:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3);
        }));

        function onTrickle(_x4) {
          return _onTrickle.apply(this, arguments);
        }

        return onTrickle;
      }(),
      onNotification: function onNotification(message) {
        return _this.observer.onNotification(message);
      },
      onServerError: function () {
        var _onServerError = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4(error) {
          return runtime_1.wrap(function _callee4$(_context4) {
            while (1) {
              switch (_context4.prev = _context4.next) {
                case 0:
                  _context4.next = 2;
                  return _this.leave();

                case 2:
                  _context4.next = 4;
                  return _this.observer.onStateChange(TransportState.Failed, error);

                case 4:
                case "end":
                  return _context4.stop();
              }
            }
          }, _callee4);
        }));

        function onServerError(_x5) {
          return _onServerError.apply(this, arguments);
        }

        return onServerError;
      }(),
      onFailure: function onFailure(exception) {
        // @DISCUSS: Should we remove this? Pong failure would have already scheduled signal retry.
        if (_this.joinParameters) {
          _this.retryScheduler.schedule(TransportFailureCategory.SignalDisconnect, exception, _this.retrySignalDisconnectTask);
        }
      },
      onOffline: function () {
        var _onOffline = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee5() {
          return runtime_1.wrap(function _callee5$(_context5) {
            while (1) {
              switch (_context5.prev = _context5.next) {
                case 0:
                  HMSLogger.d(TAG$b, 'socket offline', TransportState[_this.state]);

                  try {
                    if (_this.state !== TransportState.Leaving && _this.joinParameters) {
                      _this.retryScheduler.schedule(TransportFailureCategory.SignalDisconnect, ErrorFactory.WebSocketConnectionErrors.WebSocketConnectionLost(HMSAction.RECONNECT_SIGNAL, 'Network offline'), _this.retrySignalDisconnectTask);
                    }
                  } catch (e) {
                    console.error(e);
                  }

                case 2:
                case "end":
                  return _context5.stop();
              }
            }
          }, _callee5);
        }));

        function onOffline() {
          return _onOffline.apply(this, arguments);
        }

        return onOffline;
      }(),
      onOnline: function onOnline() {
        HMSLogger.d(TAG$b, 'socket online', TransportState[_this.state]);

        _this.analyticsSignalTransport.flushFailedEvents();
      }
    };
    this.signal = new JsonRpcSignal(this.signalObserver);
    this.analyticsSignalTransport = new SignalAnalyticsTransport(this.signal);
    this.publishConnectionObserver = {
      onRenegotiationNeeded: function () {
        var _onRenegotiationNeeded = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee6() {
          return runtime_1.wrap(function _callee6$(_context6) {
            while (1) {
              switch (_context6.prev = _context6.next) {
                case 0:
                  _context6.next = 2;
                  return _this.performPublishRenegotiation();

                case 2:
                case "end":
                  return _context6.stop();
              }
            }
          }, _callee6);
        }));

        function onRenegotiationNeeded() {
          return _onRenegotiationNeeded.apply(this, arguments);
        }

        return onRenegotiationNeeded;
      }(),
      onIceConnectionChange: function () {
        var _onIceConnectionChange = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee7(newState) {
          return runtime_1.wrap(function _callee7$(_context7) {
            while (1) {
              switch (_context7.prev = _context7.next) {
                case 0:
                  HMSLogger.d('publisher ice connection state change, ', newState); // @TODO: Uncomment this and remove connectionstatechange

                case 2:
                case "end":
                  return _context7.stop();
              }
            }
          }, _callee7);
        }));

        function onIceConnectionChange(_x6) {
          return _onIceConnectionChange.apply(this, arguments);
        }

        return onIceConnectionChange;
      }(),
      // @TODO(eswar): Remove this. Use iceconnectionstate change with interval and threshold.
      onConnectionStateChange: function () {
        var _onConnectionStateChange = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee8(newState) {
          return runtime_1.wrap(function _callee8$(_context8) {
            while (1) {
              switch (_context8.prev = _context8.next) {
                case 0:
                  HMSLogger.d('publisher connection state change, ', newState);

                  if (!(newState === 'failed')) {
                    _context8.next = 4;
                    break;
                  }

                  _context8.next = 4;
                  return _this.handleIceConnectionFailure(HMSConnectionRole.Publish);

                case 4:
                case "end":
                  return _context8.stop();
              }
            }
          }, _callee8);
        }));

        function onConnectionStateChange(_x7) {
          return _onConnectionStateChange.apply(this, arguments);
        }

        return onConnectionStateChange;
      }()
    };
    this.subscribeConnectionObserver = {
      onApiChannelMessage: function onApiChannelMessage(message) {
        _this.observer.onNotification(JSON.parse(message));
      },
      onTrackAdd: function onTrackAdd(track) {
        HMSLogger.d(TAG$b, '[Subscribe] onTrackAdd', track);

        _this.observer.onTrackAdd(track);
      },
      onTrackRemove: function onTrackRemove(track) {
        HMSLogger.d(TAG$b, '[Subscribe] onTrackRemove', track);

        _this.observer.onTrackRemove(track);
      },
      onIceConnectionChange: function () {
        var _onIceConnectionChange2 = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee9(newState) {
          var callback;
          return runtime_1.wrap(function _callee9$(_context9) {
            while (1) {
              switch (_context9.prev = _context9.next) {
                case 0:
                  HMSLogger.d('subscriber ice connection state change, ', newState);

                  if (newState === 'connected') {
                    callback = _this.callbacks.get(SUBSCRIBE_ICE_CONNECTION_CALLBACK_ID);

                    _this.callbacks["delete"](SUBSCRIBE_ICE_CONNECTION_CALLBACK_ID);

                    if (callback) {
                      callback.promise.resolve(true);
                    }
                  }

                case 3:
                case "end":
                  return _context9.stop();
              }
            }
          }, _callee9);
        }));

        function onIceConnectionChange(_x8) {
          return _onIceConnectionChange2.apply(this, arguments);
        }

        return onIceConnectionChange;
      }(),
      // @TODO(eswar): Remove this. Use iceconnectionstate change with interval and threshold.
      onConnectionStateChange: function () {
        var _onConnectionStateChange2 = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee10(newState) {
          var callback;
          return runtime_1.wrap(function _callee10$(_context10) {
            while (1) {
              switch (_context10.prev = _context10.next) {
                case 0:
                  HMSLogger.d('subscriber connection state change, ', newState);

                  if (!(newState === 'failed')) {
                    _context10.next = 4;
                    break;
                  }

                  _context10.next = 4;
                  return _this.handleIceConnectionFailure(HMSConnectionRole.Subscribe);

                case 4:
                  if (newState === 'connected') {
                    callback = _this.callbacks.get(SUBSCRIBE_ICE_CONNECTION_CALLBACK_ID);

                    _this.callbacks["delete"](SUBSCRIBE_ICE_CONNECTION_CALLBACK_ID);

                    if (callback) {
                      callback.promise.resolve(true);
                    }
                  }

                case 5:
                case "end":
                  return _context10.stop();
              }
            }
          }, _callee10);
        }));

        function onConnectionStateChange(_x9) {
          return _onConnectionStateChange2.apply(this, arguments);
        }

        return onConnectionStateChange;
      }()
    };
    this.retryPublishIceFailedTask = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee11() {
      var p;
      return runtime_1.wrap(function _callee11$(_context11) {
        while (1) {
          switch (_context11.prev = _context11.next) {
            case 0:
              if (!(_this.publishConnection.iceConnectionState !== 'connected' || _this.publishConnection.connectionState !== 'connected')) {
                _context11.next = 6;
                break;
              }

              p = new Promise(function (resolve, reject) {
                _this.callbacks.set(RENEGOTIATION_CALLBACK_ID, {
                  promise: {
                    resolve: resolve,
                    reject: reject
                  },
                  action: HMSAction.RESTART_ICE,
                  extra: {}
                });
              });
              _context11.next = 4;
              return _this.performPublishRenegotiation({
                iceRestart: true
              });

            case 4:
              _context11.next = 6;
              return p;

            case 6:
              return _context11.abrupt("return", true);

            case 7:
            case "end":
              return _context11.stop();
          }
        }
      }, _callee11);
    }));
    this.retrySubscribeIceFailedTask = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee12() {
      var p, timeout;
      return runtime_1.wrap(function _callee12$(_context12) {
        while (1) {
          switch (_context12.prev = _context12.next) {
            case 0:
              if (!(_this.subscribeConnection.iceConnectionState !== 'connected' || _this.subscribeConnection.connectionState !== 'connected')) {
                _context12.next = 4;
                break;
              }

              p = new Promise(function (resolve, reject) {
                // Use subscribe constant string
                _this.callbacks.set(SUBSCRIBE_ICE_CONNECTION_CALLBACK_ID, {
                  promise: {
                    resolve: resolve,
                    reject: reject
                  },
                  action: HMSAction.RESTART_ICE,
                  extra: {}
                });
              });
              timeout = new Promise(function (resolve) {
                setTimeout(resolve, SUBSCRIBE_TIMEOUT, false);
              });
              return _context12.abrupt("return", Promise.race([p, timeout]));

            case 4:
              return _context12.abrupt("return", true);

            case 5:
            case "end":
              return _context12.stop();
          }
        }
      }, _callee12);
    }));
    this.retrySignalDisconnectTask = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee13() {
      var ok;
      return runtime_1.wrap(function _callee13$(_context13) {
        while (1) {
          switch (_context13.prev = _context13.next) {
            case 0:
              ok = _this.signal.isConnected;
              HMSLogger.d(TAG$b, 'retrySignalDisconnectTask', {
                signalConnected: _this.signal.isConnected
              }); // Check if ws is disconnected - otherwise if only publishIce fails
              // and ws connect is success then we don't need to reconnect to WebSocket

              if (_this.signal.isConnected) {
                _context13.next = 12;
                break;
              }

              _context13.prev = 3;
              _context13.next = 6;
              return _this.internalConnect(_this.joinParameters.authToken, _this.joinParameters.endpoint, _this.joinParameters.peerId);

            case 6:
              ok = true;
              _context13.next = 12;
              break;

            case 9:
              _context13.prev = 9;
              _context13.t0 = _context13["catch"](3);
              ok = false;

            case 12:
              _context13.t1 = _this.signal.isConnected;

              if (!_context13.t1) {
                _context13.next = 17;
                break;
              }

              _context13.next = 16;
              return _this.retryPublishIceFailedTask();

            case 16:
              _context13.t1 = _context13.sent;

            case 17:
              ok = _context13.t1;

              // Send track update to sync local track state changes during reconnection
              _this.signal.trackUpdate(_this.trackStates);

              return _context13.abrupt("return", ok);

            case 20:
            case "end":
              return _context13.stop();
          }
        }
      }, _callee13, null, [[3, 9]]);
    }));
  }

  var _proto = HMSTransport.prototype;

  _proto.getLocalScreen = /*#__PURE__*/function () {
    var _getLocalScreen = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee14(videoSettings, audioSettings) {
      return runtime_1.wrap(function _callee14$(_context14) {
        while (1) {
          switch (_context14.prev = _context14.next) {
            case 0:
              _context14.prev = 0;
              _context14.next = 3;
              return HMSLocalStream.getLocalScreen(videoSettings, audioSettings);

            case 3:
              return _context14.abrupt("return", _context14.sent);

            case 6:
              _context14.prev = 6;
              _context14.t0 = _context14["catch"](0);

              if (_context14.t0 instanceof HMSException) {
                analyticsEventsService.queue(AnalyticsEventFactory.publish({
                  error: _context14.t0,
                  devices: this.deviceManager.getDevices(),
                  settings: new HMSTrackSettings(videoSettings, audioSettings, false)
                })).flush();
              }

              throw _context14.t0;

            case 10:
            case "end":
              return _context14.stop();
          }
        }
      }, _callee14, this, [[0, 6]]);
    }));

    function getLocalScreen(_x10, _x11) {
      return _getLocalScreen.apply(this, arguments);
    }

    return getLocalScreen;
  }();

  _proto.getLocalTracks = /*#__PURE__*/function () {
    var _getLocalTracks = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee15(settings) {
      return runtime_1.wrap(function _callee15$(_context15) {
        while (1) {
          switch (_context15.prev = _context15.next) {
            case 0:
              _context15.prev = 0;
              _context15.next = 3;
              return HMSLocalStream.getLocalTracks(settings);

            case 3:
              return _context15.abrupt("return", _context15.sent);

            case 6:
              _context15.prev = 6;
              _context15.t0 = _context15["catch"](0);

              if (_context15.t0 instanceof HMSException) {
                analyticsEventsService.queue(AnalyticsEventFactory.publish({
                  devices: this.deviceManager.getDevices(),
                  error: _context15.t0,
                  settings: settings
                })).flush();
              }

              throw _context15.t0;

            case 10:
            case "end":
              return _context15.stop();
          }
        }
      }, _callee15, this, [[0, 6]]);
    }));

    function getLocalTracks(_x12) {
      return _getLocalTracks.apply(this, arguments);
    }

    return getLocalTracks;
  }();

  _proto.getEmptyLocalTracks = /*#__PURE__*/function () {
    var _getEmptyLocalTracks = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee16(fetchTrackOptions, settings) {
      var tracks;
      return runtime_1.wrap(function _callee16$(_context16) {
        while (1) {
          switch (_context16.prev = _context16.next) {
            case 0:
              if (fetchTrackOptions === void 0) {
                fetchTrackOptions = {
                  audio: true,
                  video: true
                };
              }

              _context16.prev = 1;
              _context16.next = 4;
              return HMSLocalStream.getEmptyLocalTracks(fetchTrackOptions, settings);

            case 4:
              tracks = _context16.sent;
              return _context16.abrupt("return", tracks);

            case 8:
              _context16.prev = 8;
              _context16.t0 = _context16["catch"](1);

              if (_context16.t0 instanceof HMSException) {
                analyticsEventsService.queue(AnalyticsEventFactory.publish({
                  devices: this.deviceManager.getDevices(),
                  error: _context16.t0,
                  settings: settings
                })).flush();
              }

              throw _context16.t0;

            case 12:
            case "end":
              return _context16.stop();
          }
        }
      }, _callee16, this, [[1, 8]]);
    }));

    function getEmptyLocalTracks(_x13, _x14) {
      return _getEmptyLocalTracks.apply(this, arguments);
    }

    return getEmptyLocalTracks;
  }();

  _proto.join = /*#__PURE__*/function () {
    var _join = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee17(authToken, peerId, customData, initEndpoint, autoSubscribeVideo) {
      var joinRequestedAt, ex;
      return runtime_1.wrap(function _callee17$(_context17) {
        while (1) {
          switch (_context17.prev = _context17.next) {
            case 0:
              if (initEndpoint === void 0) {
                initEndpoint = 'https://prod-init.100ms.live/init';
              }

              if (autoSubscribeVideo === void 0) {
                autoSubscribeVideo = false;
              }

              if (this.state === TransportState.Failed) {
                this.state = TransportState.Disconnected;
              }

              if (!(this.state !== TransportState.Disconnected && this.state !== TransportState.Reconnecting)) {
                _context17.next = 5;
                break;
              }

              throw ErrorFactory.WebsocketMethodErrors.AlreadyJoined(HMSAction.JOIN, "Cannot join a meeting in " + this.state);

            case 5:
              if (this.state === TransportState.Disconnected) {
                this.state = TransportState.Connecting;
                this.observer.onStateChange(this.state);
              }

              this.joinParameters = new JoinParameters(authToken, peerId, customData.name, customData.metaData, initEndpoint, autoSubscribeVideo);
              HMSLogger.d(TAG$b, 'join: started ⏰');
              joinRequestedAt = new Date();
              _context17.prev = 9;

              if (!(!this.signal.isConnected || !this.initConfig)) {
                _context17.next = 13;
                break;
              }

              _context17.next = 13;
              return this.connect(authToken, initEndpoint, peerId);

            case 13:
              if (!this.initConfig) {
                _context17.next = 16;
                break;
              }

              _context17.next = 16;
              return this.connectionJoin(customData.name, customData.metaData, this.initConfig.rtcConfiguration, autoSubscribeVideo);

            case 16:
              _context17.next = 28;
              break;

            case 18:
              _context17.prev = 18;
              _context17.t0 = _context17["catch"](9);
              HMSLogger.e(TAG$b, "join: failed \u274C [token=" + authToken + "]", _context17.t0);
              this.state = TransportState.Failed;

              if (_context17.t0 instanceof HMSException) {
                analyticsEventsService.queue(AnalyticsEventFactory.join(joinRequestedAt, new Date(), _context17.t0)).flush();
              }

              ex = _context17.t0;
              ex.isTerminal = ex.code === 500;
              _context17.next = 27;
              return this.observer.onStateChange(this.state, ex);

            case 27:
              throw ex;

            case 28:
              HMSLogger.d(TAG$b, '✅ join: successful');
              this.state = TransportState.Joined;
              this.observer.onStateChange(this.state);

            case 31:
            case "end":
              return _context17.stop();
          }
        }
      }, _callee17, this, [[9, 18]]);
    }));

    function join(_x15, _x16, _x17, _x18, _x19) {
      return _join.apply(this, arguments);
    }

    return join;
  }();

  _proto.connect = /*#__PURE__*/function () {
    var _connect = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee19(token, endpoint, peerId) {
      var _this2 = this;

      var shouldRetry, task;
      return runtime_1.wrap(function _callee19$(_context19) {
        while (1) {
          switch (_context19.prev = _context19.next) {
            case 0:
              _context19.prev = 0;
              _context19.next = 3;
              return this.internalConnect(token, endpoint, peerId);

            case 3:
              return _context19.abrupt("return", _context19.sent);

            case 6:
              _context19.prev = 6;
              _context19.t0 = _context19["catch"](0);
              shouldRetry = _context19.t0 instanceof HMSException && ([ErrorCodes.WebSocketConnectionErrors.WEBSOCKET_CONNECTION_LOST, ErrorCodes.InitAPIErrors.ENDPOINT_UNREACHABLE, ErrorCodes.InitAPIErrors.CONNECTION_LOST, ErrorCodes.InitAPIErrors.HTTP_ERROR].includes(_context19.t0.code) || _context19.t0.code.toString().startsWith('5') || _context19.t0.code.toString().startsWith('429'));

              if (!shouldRetry) {
                _context19.next = 15;
                break;
              }

              task = /*#__PURE__*/function () {
                var _ref5 = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee18() {
                  return runtime_1.wrap(function _callee18$(_context18) {
                    while (1) {
                      switch (_context18.prev = _context18.next) {
                        case 0:
                          _context18.next = 2;
                          return _this2.internalConnect(token, endpoint, peerId);

                        case 2:
                          return _context18.abrupt("return", Boolean(_this2.initConfig && _this2.initConfig.endpoint));

                        case 3:
                        case "end":
                          return _context18.stop();
                      }
                    }
                  }, _callee18);
                }));

                return function task() {
                  return _ref5.apply(this, arguments);
                };
              }();

              _context19.next = 13;
              return this.retryScheduler.schedule(TransportFailureCategory.ConnectFailed, _context19.t0, task, MAX_TRANSPORT_RETRIES, false);

            case 13:
              _context19.next = 16;
              break;

            case 15:
              throw _context19.t0;

            case 16:
            case "end":
              return _context19.stop();
          }
        }
      }, _callee19, this, [[0, 6]]);
    }));

    function connect(_x20, _x21, _x22) {
      return _connect.apply(this, arguments);
    }

    return connect;
  }();

  _proto.leave = /*#__PURE__*/function () {
    var _leave = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee20() {
      var _this$subscribeConnSt, _this$subscribeConnSt2, _this$trackDegradatio, _this$publishConnecti, _this$subscribeConnec;

      return runtime_1.wrap(function _callee20$(_context20) {
        while (1) {
          switch (_context20.prev = _context20.next) {
            case 0:
              analyticsEventsService.removeTransport(this.analyticsSignalTransport);
              this.retryScheduler.reset();
              this.joinParameters = undefined;
              _context20.prev = 3;
              this.state = TransportState.Leaving;
              (_this$subscribeConnSt = this.subscribeConnStatsMonitor) == null ? void 0 : _this$subscribeConnSt.stop();
              (_this$subscribeConnSt2 = this.subscribeConnStatsMonitor) == null ? void 0 : _this$subscribeConnSt2.removeAllListeners();
              (_this$trackDegradatio = this.trackDegradationController) == null ? void 0 : _this$trackDegradatio.removeAllListeners();
              _context20.next = 10;
              return (_this$publishConnecti = this.publishConnection) == null ? void 0 : _this$publishConnecti.close();

            case 10:
              _context20.next = 12;
              return (_this$subscribeConnec = this.subscribeConnection) == null ? void 0 : _this$subscribeConnec.close();

            case 12:
              if (!this.signal.isConnected) {
                _context20.next = 16;
                break;
              }

              this.signal.leave();
              _context20.next = 16;
              return this.signal.close();

            case 16:
              _context20.next = 22;
              break;

            case 18:
              _context20.prev = 18;
              _context20.t0 = _context20["catch"](3);

              if (_context20.t0 instanceof HMSException) {
                analyticsEventsService.queue(AnalyticsEventFactory.disconnect(_context20.t0)).flush();
              }

              HMSLogger.e(TAG$b, 'leave: FAILED ❌', _context20.t0);

            case 22:
              _context20.prev = 22;
              this.state = TransportState.Disconnected;
              this.observer.onStateChange(this.state);
              return _context20.finish(22);

            case 26:
            case "end":
              return _context20.stop();
          }
        }
      }, _callee20, this, [[3, 18, 22, 26]]);
    }));

    function leave() {
      return _leave.apply(this, arguments);
    }

    return leave;
  }();

  _proto.publish = /*#__PURE__*/function () {
    var _publish = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee21(tracks) {
      var _iterator2, _step2, track;

      return runtime_1.wrap(function _callee21$(_context21) {
        while (1) {
          switch (_context21.prev = _context21.next) {
            case 0:
              _iterator2 = _createForOfIteratorHelperLoose(tracks);

            case 1:
              if ((_step2 = _iterator2()).done) {
                _context21.next = 13;
                break;
              }

              track = _step2.value;
              _context21.prev = 3;
              _context21.next = 6;
              return this.publishTrack(track);

            case 6:
              _context21.next = 11;
              break;

            case 8:
              _context21.prev = 8;
              _context21.t0 = _context21["catch"](3);

              if (_context21.t0 instanceof HMSException) {
                analyticsEventsService.queue(AnalyticsEventFactory.publish({
                  devices: this.deviceManager.getDevices(),
                  error: _context21.t0
                })).flush();
              }

            case 11:
              _context21.next = 1;
              break;

            case 13:
            case "end":
              return _context21.stop();
          }
        }
      }, _callee21, this, [[3, 8]]);
    }));

    function publish(_x23) {
      return _publish.apply(this, arguments);
    }

    return publish;
  }();

  _proto.unpublish = /*#__PURE__*/function () {
    var _unpublish = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee22(tracks) {
      var _iterator3, _step3, track;

      return runtime_1.wrap(function _callee22$(_context22) {
        while (1) {
          switch (_context22.prev = _context22.next) {
            case 0:
              _iterator3 = _createForOfIteratorHelperLoose(tracks);

            case 1:
              if ((_step3 = _iterator3()).done) {
                _context22.next = 7;
                break;
              }

              track = _step3.value;
              _context22.next = 5;
              return this.unpublishTrack(track);

            case 5:
              _context22.next = 1;
              break;

            case 7:
            case "end":
              return _context22.stop();
          }
        }
      }, _callee22, this);
    }));

    function unpublish(_x24) {
      return _unpublish.apply(this, arguments);
    }

    return unpublish;
  }();

  _proto.sendMessage = /*#__PURE__*/function () {
    var _sendMessage = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee23(message) {
      return runtime_1.wrap(function _callee23$(_context23) {
        while (1) {
          switch (_context23.prev = _context23.next) {
            case 0:
              _context23.next = 2;
              return this.signal.broadcast(message);

            case 2:
            case "end":
              return _context23.stop();
          }
        }
      }, _callee23, this);
    }));

    function sendMessage(_x25) {
      return _sendMessage.apply(this, arguments);
    }

    return sendMessage;
  }()
  /**
   * TODO: check if track.publishedTrackId be used instead of the hack to match with track with same type and
   * source. The hack won't work if there are multiple tracks with same source and type.
   */
  ;

  _proto.trackUpdate = function trackUpdate(track) {
    var currentTrackStates = Array.from(this.trackStates.values());
    var originalTrackState = currentTrackStates.find(function (trackState) {
      return track.type === trackState.type && track.source === trackState.source;
    });

    if (originalTrackState) {
      var newTrackState = new TrackState(_extends({}, originalTrackState, {
        mute: !track.enabled
      }));
      this.trackStates.set(originalTrackState.track_id, newTrackState);
      HMSLogger.d(TAG$b, 'Track Update', this.trackStates, track);
      this.signal.trackUpdate(new Map([[originalTrackState.track_id, newTrackState]]));
    }
  };

  _proto.changeRole = /*#__PURE__*/function () {
    var _changeRole = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee24(forPeer, toRole, force) {
      return runtime_1.wrap(function _callee24$(_context24) {
        while (1) {
          switch (_context24.prev = _context24.next) {
            case 0:
              if (force === void 0) {
                force = false;
              }

              _context24.next = 3;
              return this.signal.requestRoleChange({
                requested_for: forPeer.peerId,
                role: toRole,
                force: force
              });

            case 3:
            case "end":
              return _context24.stop();
          }
        }
      }, _callee24, this);
    }));

    function changeRole(_x26, _x27, _x28) {
      return _changeRole.apply(this, arguments);
    }

    return changeRole;
  }();

  _proto.acceptRoleChange = /*#__PURE__*/function () {
    var _acceptRoleChange = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee25(request) {
      return runtime_1.wrap(function _callee25$(_context25) {
        while (1) {
          switch (_context25.prev = _context25.next) {
            case 0:
              _context25.next = 2;
              return this.signal.acceptRoleChangeRequest({
                role: request.role.name,
                token: request.token
              });

            case 2:
            case "end":
              return _context25.stop();
          }
        }
      }, _callee25, this);
    }));

    function acceptRoleChange(_x29) {
      return _acceptRoleChange.apply(this, arguments);
    }

    return acceptRoleChange;
  }();

  _proto.endRoom = /*#__PURE__*/function () {
    var _endRoom = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee26(lock, reason) {
      return runtime_1.wrap(function _callee26$(_context26) {
        while (1) {
          switch (_context26.prev = _context26.next) {
            case 0:
              _context26.next = 2;
              return this.signal.endRoom(lock, reason);

            case 2:
            case "end":
              return _context26.stop();
          }
        }
      }, _callee26, this);
    }));

    function endRoom(_x30, _x31) {
      return _endRoom.apply(this, arguments);
    }

    return endRoom;
  }();

  _proto.removePeer = /*#__PURE__*/function () {
    var _removePeer = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee27(peerId, reason) {
      return runtime_1.wrap(function _callee27$(_context27) {
        while (1) {
          switch (_context27.prev = _context27.next) {
            case 0:
              _context27.next = 2;
              return this.signal.removePeer({
                requested_for: peerId,
                reason: reason
              });

            case 2:
            case "end":
              return _context27.stop();
          }
        }
      }, _callee27, this);
    }));

    function removePeer(_x32, _x33) {
      return _removePeer.apply(this, arguments);
    }

    return removePeer;
  }();

  _proto.startRTMPOrRecording = /*#__PURE__*/function () {
    var _startRTMPOrRecording = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee28(params) {
      var _params$rtmpURLs;

      return runtime_1.wrap(function _callee28$(_context28) {
        while (1) {
          switch (_context28.prev = _context28.next) {
            case 0:
              if (!((_params$rtmpURLs = params.rtmpURLs) != null && _params$rtmpURLs.length)) {
                _context28.next = 5;
                break;
              }

              _context28.next = 3;
              return this.signal.startRTMPOrRecording({
                meeting_url: params.meetingURL,
                record: params.record,
                rtmp_urls: params.rtmpURLs
              });

            case 3:
              _context28.next = 7;
              break;

            case 5:
              _context28.next = 7;
              return this.signal.startRTMPOrRecording({
                meeting_url: params.meetingURL,
                record: params.record
              });

            case 7:
            case "end":
              return _context28.stop();
          }
        }
      }, _callee28, this);
    }));

    function startRTMPOrRecording(_x34) {
      return _startRTMPOrRecording.apply(this, arguments);
    }

    return startRTMPOrRecording;
  }();

  _proto.stopRTMPOrRecording = /*#__PURE__*/function () {
    var _stopRTMPOrRecording = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee29() {
      return runtime_1.wrap(function _callee29$(_context29) {
        while (1) {
          switch (_context29.prev = _context29.next) {
            case 0:
              _context29.next = 2;
              return this.signal.stopRTMPAndRecording();

            case 2:
            case "end":
              return _context29.stop();
          }
        }
      }, _callee29, this);
    }));

    function stopRTMPOrRecording() {
      return _stopRTMPOrRecording.apply(this, arguments);
    }

    return stopRTMPOrRecording;
  }();

  _proto.changeTrackState = /*#__PURE__*/function () {
    var _changeTrackState = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee30(trackUpdateRequest) {
      return runtime_1.wrap(function _callee30$(_context30) {
        while (1) {
          switch (_context30.prev = _context30.next) {
            case 0:
              _context30.next = 2;
              return this.signal.requestTrackStateChange(trackUpdateRequest);

            case 2:
            case "end":
              return _context30.stop();
          }
        }
      }, _callee30, this);
    }));

    function changeTrackState(_x35) {
      return _changeTrackState.apply(this, arguments);
    }

    return changeTrackState;
  }();

  _proto.changeMultiTrackState = /*#__PURE__*/function () {
    var _changeMultiTrackState = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee31(trackUpdateRequest) {
      return runtime_1.wrap(function _callee31$(_context31) {
        while (1) {
          switch (_context31.prev = _context31.next) {
            case 0:
              _context31.next = 2;
              return this.signal.requestMultiTrackStateChange(trackUpdateRequest);

            case 2:
            case "end":
              return _context31.stop();
          }
        }
      }, _callee31, this);
    }));

    function changeMultiTrackState(_x36) {
      return _changeMultiTrackState.apply(this, arguments);
    }

    return changeMultiTrackState;
  }();

  _proto.publishTrack = /*#__PURE__*/function () {
    var _publishTrack = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee32(track) {
      var _this3 = this;

      var p, stream, simulcastLayers, maxBitrate;
      return runtime_1.wrap(function _callee32$(_context32) {
        while (1) {
          switch (_context32.prev = _context32.next) {
            case 0:
              track.publishedTrackId = track.nativeTrack.id;
              HMSLogger.d(TAG$b, "\u23F3 publishTrack: trackId=" + track.trackId + ", toPublishTrackId=" + track.publishedTrackId, track);
              this.trackStates.set(track.publishedTrackId, new TrackState(track));
              p = new Promise(function (resolve, reject) {
                _this3.callbacks.set(RENEGOTIATION_CALLBACK_ID, {
                  promise: {
                    resolve: resolve,
                    reject: reject
                  },
                  action: HMSAction.PUBLISH,
                  extra: {}
                });
              });
              stream = track.stream;
              stream.setConnection(this.publishConnection);
              simulcastLayers = this.store.getSimulcastLayers(track.source);
              stream.addTransceiver(track, simulcastLayers);
              HMSLogger.time("publish-" + track.trackId + "-" + track.type);
              _context32.next = 11;
              return p;

            case 11:
              HMSLogger.timeEnd("publish-" + track.trackId + "-" + track.type); // add track to store after publish

              this.store.addTrack(track); // @ts-ignore

              maxBitrate = track.settings.maxBitrate;

              if (!maxBitrate) {
                _context32.next = 17;
                break;
              }

              _context32.next = 17;
              return stream.setMaxBitrate(maxBitrate, track).then(function () {
                HMSLogger.i(TAG$b, "Setting maxBitrate for " + track.source + " " + track.type + " to " + maxBitrate + " kpbs");
              })["catch"](function (error) {
                return HMSLogger.e(TAG$b, 'Failed setting maxBitrate', error);
              });

            case 17:
              HMSLogger.d(TAG$b, "\u2705 publishTrack: trackId=" + track.trackId, track, this.callbacks);

            case 18:
            case "end":
              return _context32.stop();
          }
        }
      }, _callee32, this);
    }));

    function publishTrack(_x37) {
      return _publishTrack.apply(this, arguments);
    }

    return publishTrack;
  }();

  _proto.unpublishTrack = /*#__PURE__*/function () {
    var _unpublishTrack = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee33(track) {
      var _this4 = this;

      var currentTrackStates, originalTrackState, p, stream;
      return runtime_1.wrap(function _callee33$(_context33) {
        while (1) {
          switch (_context33.prev = _context33.next) {
            case 0:
              HMSLogger.d(TAG$b, "\u23F3 unpublishTrack: trackId=" + track.trackId, track);

              if (this.trackStates.has(track.publishedTrackId)) {
                this.trackStates["delete"](track.publishedTrackId);
              } else {
                // TODO: hotfix to unpublish replaced video track id, solve it properly
                // it won't work when there are multiple regular video tracks, hmslocalvideotrack can store
                // the original initial track id for a proper fix
                currentTrackStates = Array.from(this.trackStates.values());
                originalTrackState = currentTrackStates.find(function (trackState) {
                  return track.type === trackState.type && track.source === trackState.source;
                });

                if (originalTrackState) {
                  this.trackStates["delete"](originalTrackState.track_id);
                }
              }

              p = new Promise(function (resolve, reject) {
                _this4.callbacks.set(RENEGOTIATION_CALLBACK_ID, {
                  promise: {
                    resolve: resolve,
                    reject: reject
                  },
                  action: HMSAction.UNPUBLISH,
                  extra: {}
                });
              });
              stream = track.stream;
              stream.removeSender(track);
              _context33.next = 7;
              return p;

            case 7:
              _context33.next = 9;
              return track.cleanup();

            case 9:
              // remove track from store on unpublish
              this.store.removeTrack(track.trackId);
              HMSLogger.d(TAG$b, "\u2705 unpublishTrack: trackId=" + track.trackId, this.callbacks);

            case 11:
            case "end":
              return _context33.stop();
          }
        }
      }, _callee33, this);
    }));

    function unpublishTrack(_x38) {
      return _unpublishTrack.apply(this, arguments);
    }

    return unpublishTrack;
  }();

  _proto.connectionJoin = /*#__PURE__*/function () {
    var _connectionJoin = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee34(name, data, config, autoSubscribeVideo, constraints) {
      var offer, answer, _iterator4, _step4, candidate;

      return runtime_1.wrap(function _callee34$(_context34) {
        while (1) {
          switch (_context34.prev = _context34.next) {
            case 0:
              if (constraints === void 0) {
                constraints = {
                  offerToReceiveAudio: false,
                  offerToReceiveVideo: false
                };
              }

              this.publishConnection = new HMSPublishConnection(this.signal, config, this.publishConnectionObserver, this);
              this.subscribeConnection = new HMSSubscribeConnection(this.signal, config, this.subscribeConnectionObserver);
              _context34.prev = 3;
              HMSLogger.d(TAG$b, '⏳ join: Negotiating over PUBLISH connection');
              _context34.next = 7;
              return this.publishConnection.createOffer(constraints, new Map());

            case 7:
              offer = _context34.sent;
              _context34.next = 10;
              return this.publishConnection.setLocalDescription(offer);

            case 10:
              _context34.next = 12;
              return this.signal.join(name, data, offer, !autoSubscribeVideo);

            case 12:
              answer = _context34.sent;
              _context34.next = 15;
              return this.publishConnection.setRemoteDescription(answer);

            case 15:
              _iterator4 = _createForOfIteratorHelperLoose(this.publishConnection.candidates || []);

            case 16:
              if ((_step4 = _iterator4()).done) {
                _context34.next = 22;
                break;
              }

              candidate = _step4.value;
              _context34.next = 20;
              return this.publishConnection.addIceCandidate(candidate);

            case 20:
              _context34.next = 16;
              break;

            case 22:
              this.publishConnection.initAfterJoin();
              _context34.next = 25;
              return this.initRtcStatsMonitor();

            case 25:
              HMSLogger.d(TAG$b, '✅ join: Negotiated over PUBLISH connection');
              _context34.next = 32;
              break;

            case 28:
              _context34.prev = 28;
              _context34.t0 = _context34["catch"](3);
              this.state = TransportState.Failed;
              throw _context34.t0;

            case 32:
            case "end":
              return _context34.stop();
          }
        }
      }, _callee34, this, [[3, 28]]);
    }));

    function connectionJoin(_x39, _x40, _x41, _x42, _x43) {
      return _connectionJoin.apply(this, arguments);
    }

    return connectionJoin;
  }();

  _proto.performPublishRenegotiation = /*#__PURE__*/function () {
    var _performPublishRenegotiation = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee35(constraints) {
      var callback, offer, answer, ex;
      return runtime_1.wrap(function _callee35$(_context35) {
        while (1) {
          switch (_context35.prev = _context35.next) {
            case 0:
              HMSLogger.d(TAG$b, "\u23F3 [role=PUBLISH] onRenegotiationNeeded START", this.trackStates);
              callback = this.callbacks.get(RENEGOTIATION_CALLBACK_ID);
              this.callbacks["delete"](RENEGOTIATION_CALLBACK_ID);
              _context35.prev = 3;
              _context35.next = 6;
              return this.publishConnection.createOffer(constraints, this.trackStates);

            case 6:
              offer = _context35.sent;
              _context35.next = 9;
              return this.publishConnection.setLocalDescription(offer);

            case 9:
              HMSLogger.time("renegotiation-offer-exchange");
              _context35.next = 12;
              return this.signal.offer(offer, this.trackStates);

            case 12:
              answer = _context35.sent;
              HMSLogger.timeEnd("renegotiation-offer-exchange");
              _context35.next = 16;
              return this.publishConnection.setRemoteDescription(answer);

            case 16:
              callback.promise.resolve(true);
              HMSLogger.d(TAG$b, "[role=PUBLISH] onRenegotiationNeeded DONE \u2705");
              _context35.next = 25;
              break;

            case 20:
              _context35.prev = 20;
              _context35.t0 = _context35["catch"](3);

              if (_context35.t0 instanceof HMSException) {
                ex = _context35.t0;
              } else {
                ex = ErrorFactory.GenericErrors.Unknown(HMSAction.PUBLISH, _context35.t0.message);
              }

              callback.promise.reject(ex);
              HMSLogger.d(TAG$b, "[role=PUBLISH] onRenegotiationNeeded FAILED \u274C");

            case 25:
            case "end":
              return _context35.stop();
          }
        }
      }, _callee35, this, [[3, 20]]);
    }));

    function performPublishRenegotiation(_x44) {
      return _performPublishRenegotiation.apply(this, arguments);
    }

    return performPublishRenegotiation;
  }();

  _proto.handleIceConnectionFailure = /*#__PURE__*/function () {
    var _handleIceConnectionFailure = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee36(role) {
      return runtime_1.wrap(function _callee36$(_context36) {
        while (1) {
          switch (_context36.prev = _context36.next) {
            case 0:
              if (role === HMSConnectionRole.Publish) {
                this.retryScheduler.schedule(TransportFailureCategory.PublishIceConnectionFailed, ErrorFactory.WebrtcErrors.ICEFailure(HMSAction.PUBLISH), this.retryPublishIceFailedTask);
              } else {
                this.retryScheduler.schedule(TransportFailureCategory.SubscribeIceConnectionFailed, ErrorFactory.WebrtcErrors.ICEFailure(HMSAction.SUBSCRIBE), this.retrySubscribeIceFailedTask, 1);
              }

            case 1:
            case "end":
              return _context36.stop();
          }
        }
      }, _callee36, this);
    }));

    function handleIceConnectionFailure(_x45) {
      return _handleIceConnectionFailure.apply(this, arguments);
    }

    return handleIceConnectionFailure;
  }();

  _proto.internalConnect = /*#__PURE__*/function () {
    var _internalConnect = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee37(token, endpoint, peerId) {
      var connectRequestedAt;
      return runtime_1.wrap(function _callee37$(_context37) {
        while (1) {
          switch (_context37.prev = _context37.next) {
            case 0:
              HMSLogger.d(TAG$b, 'connect: started ⏰');
              connectRequestedAt = new Date();
              _context37.prev = 2;
              _context37.next = 5;
              return InitService.fetchInitConfig(token, endpoint);

            case 5:
              this.initConfig = _context37.sent;
              _context37.next = 8;
              return this.openSignal(token, peerId);

            case 8:
              HMSLogger.d(TAG$b, 'Adding Analytics Transport: JsonRpcSignal');
              analyticsEventsService.addTransport(this.analyticsSignalTransport);
              analyticsEventsService.flush();
              _context37.next = 18;
              break;

            case 13:
              _context37.prev = 13;
              _context37.t0 = _context37["catch"](2);
              analyticsEventsService.queue(AnalyticsEventFactory.connect(_context37.t0, connectRequestedAt, new Date(), endpoint)).flush();
              HMSLogger.d(TAG$b, '❌ internal connect: failed', _context37.t0);
              throw _context37.t0;

            case 18:
            case "end":
              return _context37.stop();
          }
        }
      }, _callee37, this, [[2, 13]]);
    }));

    function internalConnect(_x46, _x47, _x48) {
      return _internalConnect.apply(this, arguments);
    }

    return internalConnect;
  }();

  _proto.openSignal = /*#__PURE__*/function () {
    var _openSignal = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee38(token, peerId) {
      var url;
      return runtime_1.wrap(function _callee38$(_context38) {
        while (1) {
          switch (_context38.prev = _context38.next) {
            case 0:
              if (this.initConfig) {
                _context38.next = 2;
                break;
              }

              throw ErrorFactory.WebSocketConnectionErrors.GenericConnect(HMSAction.INIT, 'Init Config not found');

            case 2:
              HMSLogger.d(TAG$b, '⏳ internal connect: connecting to ws endpoint', this.initConfig.endpoint);
              url = new URL(this.initConfig.endpoint);
              url.searchParams.set('peer', peerId);
              url.searchParams.set('token', token);
              url.searchParams.set('user_agent', userAgent);
              this.endpoint = url.toString();
              _context38.next = 10;
              return this.signal.open(this.endpoint);

            case 10:
              HMSLogger.d(TAG$b, '✅ internal connect: connected to ws endpoint');

            case 11:
            case "end":
              return _context38.stop();
          }
        }
      }, _callee38, this);
    }));

    function openSignal(_x49, _x50) {
      return _openSignal.apply(this, arguments);
    }

    return openSignal;
  }();

  _proto.initRtcStatsMonitor = /*#__PURE__*/function () {
    var _initRtcStatsMonitor = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee39() {
      var _this5 = this;

      return runtime_1.wrap(function _callee39$(_context39) {
        while (1) {
          switch (_context39.prev = _context39.next) {
            case 0:
              if (!this.store.getSubscribeDegradationParams()) {
                _context39.next = 8;
                break;
              }

              this.subscribeConnStatsMonitor = new RTCStatsMonitor([this.subscribeConnection]);
              this.trackDegradationController = new TrackDegradationController(this.store);
              this.subscribeConnStatsMonitor.on('RTC_STATS_CHANGE', function (stats) {
                var _this5$trackDegradati;

                return (_this5$trackDegradati = _this5.trackDegradationController) == null ? void 0 : _this5$trackDegradati.handleRtcStatsChange(stats);
              });
              this.trackDegradationController.on('TRACK_DEGRADED', this.observer.onTrackDegrade);
              this.trackDegradationController.on('TRACK_RESTORED', this.observer.onTrackRestore);
              _context39.next = 8;
              return this.subscribeConnStatsMonitor.start();

            case 8:
            case "end":
              return _context39.stop();
          }
        }
      }, _callee39, this);
    }));

    function initRtcStatsMonitor() {
      return _initRtcStatsMonitor.apply(this, arguments);
    }

    return initRtcStatsMonitor;
  }();

  return HMSTransport;
}();

function decodeJWT(token) {
  if (token.length === 0) {
    throw ErrorFactory.InitAPIErrors.InvalidTokenFormat(HMSAction.INIT, 'Token cannot be an empty string');
  }

  var parts = token.split('.');

  if (parts.length !== 3) {
    throw ErrorFactory.InitAPIErrors.InvalidTokenFormat(HMSAction.INIT, "Expected 3 '.' separate fields - header, payload and signature respectively");
  }

  var payloadStr = atob(parts[1]);

  try {
    var payload = JSON.parse(payloadStr);
    return {
      roomId: payload.room_id,
      userId: payload.user_id,
      role: payload.role
    };
  } catch (err) {
    throw ErrorFactory.InitAPIErrors.InvalidTokenFormat(HMSAction.INIT, err.message);
  }
}

var Room = /*#__PURE__*/function () {
  function Room(id, name, store) {
    this.id = id;
    this.name = name;
    this.store = store;
  }

  _createClass(Room, [{
    key: "localPeer",
    get: function get() {
      return this.store.getLocalPeer();
    }
  }, {
    key: "peers",
    get: function get() {
      return this.store.getPeers();
    }
  }]);

  return Room;
}();

var AutoplayError = 'autoplay-error';
var INITIAL_STATE = {
  autoplayFailed: undefined,
  initialized: false,
  autoplayCheckPromise: undefined
};
var AudioSinkManager = /*#__PURE__*/function () {
  function AudioSinkManager(store, notificationManager, deviceManager) {
    var _this = this;

    this.store = store;
    this.notificationManager = notificationManager;
    this.deviceManager = deviceManager;
    this.autoPausedTracks = new Set();
    this.TAG = '[AudioSinkManager]:';
    this.volume = 100;
    this.eventEmitter = new EventEmitter.EventEmitter();
    this.state = _extends({}, INITIAL_STATE);

    this.handleAudioPaused = function (event) {
      var _audioEl$srcObject;

      var audioEl = event.target; //@ts-ignore

      var track = (_audioEl$srcObject = audioEl.srcObject) == null ? void 0 : _audioEl$srcObject.getAudioTracks()[0];

      if (!(track != null && track.enabled)) {
        // No need to play if already disabled
        return;
      } // this means the audio paused because of external factors(headset removal)


      HMSLogger.d(_this.TAG, 'Audio Paused', event.target.id);

      var audioTrack = _this.store.getTrackById(event.target.id);

      if (audioTrack) {
        if (isMobile()) {
          // Play after a delay since mobile devices don't call onDevice change event
          setTimeout( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee() {
            return runtime_1.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    if (!audioTrack) {
                      _context.next = 3;
                      break;
                    }

                    _context.next = 3;
                    return _this.playAudioFor(audioTrack);

                  case 3:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee);
          })), 500);
        } else {
          _this.autoPausedTracks.add(audioTrack);
        }
      }
    };

    this.handleTrackUpdate = function (event) {
      var _window$HMS;

      // @ts-ignore
      if ((_window$HMS = window.HMS) != null && _window$HMS.AUDIO_SINK) {
        var _event$detail = event.detail,
            track = _event$detail.track,
            enabled = _event$detail.enabled;

        if (enabled) {
          track.addSink();

          _this.playAudioFor(track);
        } else {
          track.removeSink();
        }
      }
    };

    this.handleTrackAdd = function (event) {
      _this.handleTrackAddAsync(event);
    };

    this.handleTrackAddAsync = /*#__PURE__*/function () {
      var _ref2 = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(event) {
        var _this$audioSink, _window$HMS2, _this$listener2;

        var _event$detail2, track, peer, audioEl, _this$listener;

        return runtime_1.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _event$detail2 = event.detail, track = _event$detail2.track, peer = _event$detail2.peer;
                audioEl = document.createElement('audio');
                audioEl.style.display = 'none';
                audioEl.id = track.trackId;
                audioEl.addEventListener('pause', _this.handleAudioPaused);
                track.setAudioElement(audioEl);
                track.setVolume(_this.volume);
                HMSLogger.d(_this.TAG, 'Audio track added', track.trackId);
                (_this$audioSink = _this.audioSink) == null ? void 0 : _this$audioSink.append(audioEl);
                _context2.t0 = _this.outputDevice;

                if (!_context2.t0) {
                  _context2.next = 13;
                  break;
                }

                _context2.next = 13;
                return track.setOutputDevice(_this.outputDevice);

              case 13:
                if (!((_window$HMS2 = window.HMS) != null && _window$HMS2.AUDIO_SINK)) {
                  _context2.next = 21;
                  break;
                }

                if (track.enabled) {
                  _context2.next = 18;
                  break;
                }

                track.removeSink();
                (_this$listener = _this.listener) == null ? void 0 : _this$listener.onTrackUpdate(exports.HMSTrackUpdate.TRACK_ADDED, track, peer);
                return _context2.abrupt("return");

              case 18:
                track.addSink();
                _context2.next = 22;
                break;

              case 21:
                audioEl.srcObject = new MediaStream([track.nativeTrack]);

              case 22:
                (_this$listener2 = _this.listener) == null ? void 0 : _this$listener2.onTrackUpdate(exports.HMSTrackUpdate.TRACK_ADDED, track, peer);
                /**
                 * if it's not known whether autoplay will succeed, wait for it to be known
                 */

                if (!(_this.state.autoplayFailed === undefined)) {
                  _context2.next = 27;
                  break;
                }

                if (!_this.state.autoplayCheckPromise) {
                  // it's the first track, try to play it, that'll tell us whether autoplay is allowed
                  _this.state.autoplayCheckPromise = new Promise(function (resolve) {
                    _this.playAudioFor(track).then(resolve);
                  });
                } // and wait for the result to be known


                _context2.next = 27;
                return _this.state.autoplayCheckPromise;

              case 27:
                if (!_this.state.autoplayFailed) {
                  _context2.next = 30;
                  break;
                }

                _this.autoPausedTracks.add(track);

                return _context2.abrupt("return");

              case 30:
                _context2.next = 32;
                return _this.playAudioFor(track);

              case 32:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }));

      return function (_x) {
        return _ref2.apply(this, arguments);
      };
    }();

    this.handleAudioDeviceChange = function (event) {
      // if there is no selection that means this is an init request. No need to do anything
      if (event.error || !event.selection) {
        return;
      }

      _this.unpauseAudioTracks();
    };

    this.handleTrackRemove = function (event) {
      var track = event.detail;

      _this.autoPausedTracks["delete"](track);

      var audioEl = document.getElementById(track.trackId);

      if (audioEl) {
        audioEl.removeEventListener('pause', _this.handleAudioPaused);
        audioEl.srcObject = null;
        audioEl.remove();
        track.setAudioElement(null);
      } // Reset autoplay error thrown because if all tracks are removed and a new track is added
      // Autoplay error is thrown in safari


      if (_this.audioSink && _this.audioSink.childElementCount === 0) {
        _this.state.autoplayCheckPromise = undefined;
        _this.state.autoplayFailed = undefined;
      }

      HMSLogger.d(_this.TAG, 'Audio track removed', track.trackId);
    };

    this.unpauseAudioTracks = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3() {
      var promises;
      return runtime_1.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              promises = [];

              _this.autoPausedTracks.forEach(function (track) {
                promises.push(_this.playAudioFor(track));
              }); // Return after all pending tracks are played


              _context3.next = 4;
              return Promise.all(promises);

            case 4:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));
    this.notificationManager.addEventListener('track-added', this.handleTrackAdd);
    this.notificationManager.addEventListener('track-removed', this.handleTrackRemove);
    this.notificationManager.addEventListener('track-updated', this.handleTrackUpdate);
    this.deviceManager.addEventListener('audio-device-change', this.handleAudioDeviceChange); // Initiate a Audio Context so safari will play audio on speaker instead of earpiece

    this.audioContext = new AudioContext();
  }

  var _proto = AudioSinkManager.prototype;

  _proto.setListener = function setListener(listener) {
    this.listener = listener;
  };

  _proto.addEventListener = function addEventListener(event, listener) {
    this.eventEmitter.addListener(event, listener);
  };

  _proto.removeEventListener = function removeEventListener(event, listener) {
    this.eventEmitter.removeListener(event, listener);
  };

  _proto.getVolume = function getVolume() {
    return this.volume;
  };

  _proto.setVolume = function setVolume(value) {
    this.store.updateAudioOutputVolume(value);
    this.volume = value;
  }
  /**
   *  This function is to be called only on user interaction when
   *  autoplay error is received.
   */
  ;

  _proto.unblockAutoplay =
  /*#__PURE__*/
  function () {
    var _unblockAutoplay = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4() {
      return runtime_1.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              if (this.autoPausedTracks.size > 0) {
                this.unpauseAudioTracks();
              }

            case 1:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4, this);
    }));

    function unblockAutoplay() {
      return _unblockAutoplay.apply(this, arguments);
    }

    return unblockAutoplay;
  }();

  _proto.init = function init(elementId) {
    if (this.state.initialized) {
      return;
    }

    this.state.initialized = true;
    var audioSink = document.createElement('div');
    audioSink.id = "HMS-SDK-audio-sink-" + uuid.v4();
    var userElement = elementId && document.getElementById(elementId);
    var audioSinkParent = userElement || document.body;
    audioSinkParent.append(audioSink);
    this.audioSink = audioSink;
  };

  _proto.cleanUp = function cleanUp() {
    var _this$audioSink2, _this$audioContext;

    (_this$audioSink2 = this.audioSink) == null ? void 0 : _this$audioSink2.remove();
    this.audioSink = undefined;
    (_this$audioContext = this.audioContext) == null ? void 0 : _this$audioContext.close();
    this.audioContext = undefined;
    this.notificationManager.removeEventListener('track-added', this.handleTrackAdd);
    this.notificationManager.removeEventListener('track-removed', this.handleTrackRemove);
    this.notificationManager.removeEventListener('track-updated', this.handleTrackUpdate);
    this.deviceManager.removeEventListener('audio-device-change', this.handleAudioDeviceChange);
    this.autoPausedTracks = new Set();
    this.state = _extends({}, INITIAL_STATE);
  }
  /**
   * try to play audio for the passed in track, assume autoplay error happened if play fails
   * @param track
   * @private
   */
  ;

  _proto.playAudioFor =
  /*#__PURE__*/
  function () {
    var _playAudioFor = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee5(track) {
      var audioEl, _this$audioContext2, _this$audioContext3, ex;

      return runtime_1.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              audioEl = track.getAudioElement();

              if (audioEl) {
                _context5.next = 4;
                break;
              }

              HMSLogger.w(this.TAG, 'No audio element found on track', track.trackId);
              return _context5.abrupt("return");

            case 4:
              _context5.prev = 4;

              if (((_this$audioContext2 = this.audioContext) == null ? void 0 : _this$audioContext2.state) === 'suspended') {
                (_this$audioContext3 = this.audioContext) == null ? void 0 : _this$audioContext3.resume();
              }

              _context5.next = 8;
              return audioEl.play();

            case 8:
              this.state.autoplayFailed = false;
              this.autoPausedTracks["delete"](track);
              HMSLogger.d(this.TAG, 'Played track', track.trackId);
              _context5.next = 18;
              break;

            case 13:
              _context5.prev = 13;
              _context5.t0 = _context5["catch"](4);
              this.autoPausedTracks.add(track);
              HMSLogger.e(this.TAG, 'Failed to play track', track.trackId, _context5.t0);

              if (!this.state.autoplayFailed) {
                this.state.autoplayFailed = true;
                ex = ErrorFactory.TracksErrors.AutoplayBlocked(HMSAction.AUTOPLAY, '');
                this.eventEmitter.emit(AutoplayError, {
                  error: ex
                });
              }

            case 18:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5, this, [[4, 13]]);
    }));

    function playAudioFor(_x2) {
      return _playAudioFor.apply(this, arguments);
    }

    return playAudioFor;
  }();

  _createClass(AudioSinkManager, [{
    key: "outputDevice",
    get: function get() {
      return this.deviceManager.outputDevice;
    }
  }]);

  return AudioSinkManager;
}();

var DeviceManager = /*#__PURE__*/function () {
  function DeviceManager(store) {
    var _this = this;

    this.store = store;
    this.audioInput = [];
    this.audioOutput = [];
    this.videoInput = []; // true if user has allowed the permission
    // false if user has denied the permission or prompt was never shown or ignored
    // or if the camera/mic is not available in the device

    this.hasWebcamPermission = false;
    this.hasMicrophonePermission = false;
    this.eventEmitter = new EventEmitter__default();
    this.TAG = '[Device Manager]:';
    this.initialized = false;
    this.videoInputChanged = false;
    this.audioInputChanged = false;

    this.updateOutputDevice = function (deviceId) {
      var newDevice = _this.audioOutput.find(function (device) {
        return device.deviceId === deviceId;
      });

      if (newDevice) {
        _this.outputDevice = newDevice;

        _this.store.updateAudioOutputDevice(newDevice);

        DeviceStorageManager.updateSelection('audioOutput', {
          deviceId: newDevice.deviceId,
          groupId: newDevice.groupId
        });
      }

      return newDevice;
    };

    this.getCurrentSelection = function () {
      var _localPeer$audioTrack, _localPeer$videoTrack;

      var localPeer = _this.store.getLocalPeer();

      var audioDevice = _this.createIdentifier(localPeer == null ? void 0 : (_localPeer$audioTrack = localPeer.audioTrack) == null ? void 0 : _localPeer$audioTrack.getMediaTrackSettings());

      var videoDevice = _this.createIdentifier(localPeer == null ? void 0 : (_localPeer$videoTrack = localPeer.videoTrack) == null ? void 0 : _localPeer$videoTrack.getMediaTrackSettings());

      var audioSelection = _this.audioInput.find(function (device) {
        var id = _this.createIdentifier(device);

        return id === audioDevice;
      });

      var videoSelection = _this.videoInput.find(function (device) {
        return _this.createIdentifier(device) === videoDevice;
      });

      return {
        audioInput: audioSelection,
        videoInput: videoSelection,
        audioOutput: _this.outputDevice
      };
    };

    this.computeChange = function (prevDevices, currentDevices) {
      if (prevDevices.length !== currentDevices.length) {
        return true;
      }

      return currentDevices.some(function (device) {
        return !prevDevices.includes(_this.createIdentifier(device));
      });
    };

    this.enumerateDevices = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee() {
      var devices, prevVideoInput, prevAudioInput;
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.prev = 0;
              _context.next = 3;
              return navigator.mediaDevices.enumerateDevices();

            case 3:
              devices = _context.sent;
              prevVideoInput = _this.videoInput.map(_this.createIdentifier);
              prevAudioInput = _this.audioInput.map(_this.createIdentifier);
              _this.audioInput = [];
              _this.audioOutput = [];
              _this.videoInput = [];
              devices.forEach(function (device) {
                if (device.kind === 'audioinput' && device.label) {
                  _this.hasMicrophonePermission = true;

                  _this.audioInput.push(device);
                } else if (device.kind === 'audiooutput') {
                  _this.audioOutput.push(device);
                } else if (device.kind === 'videoinput' && device.label) {
                  _this.hasWebcamPermission = true;

                  _this.videoInput.push(device);
                }
              });
              _this.videoInputChanged = _this.computeChange(prevVideoInput, _this.videoInput);
              _this.audioInputChanged = _this.computeChange(prevAudioInput, _this.audioInput);
              DeviceStorageManager.setDevices({
                videoInput: [].concat(_this.videoInput),
                audioInput: [].concat(_this.audioInput),
                audioOutput: [].concat(_this.audioOutput)
              });

              _this.logDevices('Enumerate Devices');

              _context.next = 19;
              break;

            case 16:
              _context.prev = 16;
              _context.t0 = _context["catch"](0);
              HMSLogger.e(_this.TAG, 'Failed enumerating devices', _context.t0);

            case 19:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, null, [[0, 16]]);
    }));
    this.handleDeviceChange = debounce( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2() {
      var localPeer;
      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return _this.enumerateDevices();

            case 2:
              analyticsEventsService.queue(AnalyticsEventFactory.deviceChange({
                selection: _this.getCurrentSelection(),
                type: 'list',
                devices: _this.getDevices()
              })).flush();

              _this.logDevices('After Device Change');

              localPeer = _this.store.getLocalPeer();

              _this.setOutputDevice(true);

              _context2.next = 8;
              return _this.handleAudioInputDeviceChange(localPeer == null ? void 0 : localPeer.audioTrack);

            case 8:
              _context2.next = 10;
              return _this.handleVideoInputDeviceChange(localPeer == null ? void 0 : localPeer.videoTrack);

            case 10:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    })), 500).bind(this);

    this.handleAudioInputDeviceChange = /*#__PURE__*/function () {
      var _ref3 = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3(audioTrack) {
        var newSelection, settings, newAudioTrackSettings;
        return runtime_1.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (audioTrack) {
                  _context3.next = 3;
                  break;
                }

                HMSLogger.d(_this.TAG, 'No Audio track on local peer');
                return _context3.abrupt("return");

              case 3:
                if (_this.audioInputChanged) {
                  _context3.next = 6;
                  break;
                }

                HMSLogger.d(_this.TAG, 'No Change in AudioInput Device');
                return _context3.abrupt("return");

              case 6:
                newSelection = _this.getNewAudioInputDevice();

                if (!(!newSelection || !newSelection.deviceId)) {
                  _context3.next = 10;
                  break;
                }

                HMSLogger.w(_this.TAG, 'Audio device not found');
                return _context3.abrupt("return");

              case 10:
                settings = audioTrack.settings;
                newAudioTrackSettings = new HMSAudioTrackSettingsBuilder().codec(settings.codec).maxBitrate(settings.maxBitrate).deviceId(newSelection.deviceId).build();
                _context3.prev = 12;
                _context3.next = 15;
                return audioTrack.setSettings(newAudioTrackSettings, true);

              case 15:
                _this.eventEmitter.emit('audio-device-change', {
                  devices: _this.getDevices(),
                  selection: newSelection,
                  type: 'audioInput'
                });

                _this.logDevices('Audio Device Change Success');

                _context3.next = 24;
                break;

              case 19:
                _context3.prev = 19;
                _context3.t0 = _context3["catch"](12);
                HMSLogger.e(_this.TAG, '[Audio Device Change]', _context3.t0);
                analyticsEventsService.queue(AnalyticsEventFactory.deviceChange({
                  selection: {
                    audioInput: newSelection
                  },
                  devices: _this.getDevices(),
                  error: _context3.t0
                })).flush();

                _this.eventEmitter.emit('audio-device-change', {
                  error: _context3.t0,
                  selection: newSelection,
                  type: 'audioInput',
                  devices: _this.getDevices()
                });

              case 24:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, null, [[12, 19]]);
      }));

      return function (_x) {
        return _ref3.apply(this, arguments);
      };
    }();

    this.handleVideoInputDeviceChange = /*#__PURE__*/function () {
      var _ref4 = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4(videoTrack) {
        var newSelection, settings, enabled, newVideoTrackSettings;
        return runtime_1.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                if (videoTrack) {
                  _context4.next = 3;
                  break;
                }

                HMSLogger.d(_this.TAG, 'No Audio track on local peer');
                return _context4.abrupt("return");

              case 3:
                if (_this.videoInputChanged) {
                  _context4.next = 6;
                  break;
                }

                HMSLogger.d(_this.TAG, 'No Change in VideoInput Device');
                return _context4.abrupt("return");

              case 6:
                newSelection = _this.videoInput[0];

                if (!(!newSelection || !newSelection.deviceId)) {
                  _context4.next = 10;
                  break;
                }

                HMSLogger.w(_this.TAG, 'Video device not found');
                return _context4.abrupt("return");

              case 10:
                settings = videoTrack.settings, enabled = videoTrack.enabled;
                newVideoTrackSettings = new HMSVideoTrackSettingsBuilder().codec(settings.codec).maxBitrate(settings.maxBitrate).maxFramerate(settings.maxFramerate).setWidth(settings.width).setHeight(settings.height).deviceId(newSelection.deviceId).build();
                _context4.prev = 12;
                _context4.next = 15;
                return videoTrack.setSettings(newVideoTrackSettings, true);

              case 15:
                if (!enabled) {
                  // On replace track, enabled will be true. Need to be set to previous state
                  videoTrack.setEnabled(enabled);
                }

                _this.eventEmitter.emit('video-device-change', {
                  devices: _this.getDevices(),
                  selection: newSelection,
                  type: 'video'
                });

                _this.logDevices('Video Device Change Success');

                _context4.next = 25;
                break;

              case 20:
                _context4.prev = 20;
                _context4.t0 = _context4["catch"](12);
                HMSLogger.e(_this.TAG, '[Video Device Change]', _context4.t0);
                analyticsEventsService.queue(AnalyticsEventFactory.deviceChange({
                  selection: {
                    videoInput: newSelection
                  },
                  devices: _this.getDevices(),
                  error: _context4.t0
                })).flush();

                _this.eventEmitter.emit('video-device-change', {
                  error: _context4.t0,
                  type: 'video',
                  selection: newSelection,
                  devices: _this.getDevices()
                });

              case 25:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, null, [[12, 20]]);
      }));

      return function (_x2) {
        return _ref4.apply(this, arguments);
      };
    }();
  }

  var _proto = DeviceManager.prototype;

  _proto.init = /*#__PURE__*/function () {
    var _init = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee5() {
      return runtime_1.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              if (!this.initialized) {
                _context5.next = 2;
                break;
              }

              return _context5.abrupt("return");

            case 2:
              this.initialized = true;
              navigator.mediaDevices.addEventListener('devicechange', this.handleDeviceChange);
              _context5.next = 6;
              return this.enumerateDevices();

            case 6:
              this.logDevices('Init');
              this.setOutputDevice();
              this.eventEmitter.emit('audio-device-change', {
                devices: this.getDevices()
              });
              analyticsEventsService.queue(AnalyticsEventFactory.deviceChange({
                selection: this.getCurrentSelection(),
                type: 'list',
                devices: this.getDevices()
              })).flush();

            case 10:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5, this);
    }));

    function init() {
      return _init.apply(this, arguments);
    }

    return init;
  }();

  _proto.getDevices = function getDevices() {
    return {
      audioInput: this.audioInput,
      audioOutput: this.audioOutput,
      videoInput: this.videoInput
    };
  };

  _proto.cleanUp = function cleanUp() {
    this.initialized = false;
    this.audioInput = [];
    this.audioOutput = [];
    this.videoInput = [];
    this.outputDevice = undefined;
    navigator.mediaDevices.removeEventListener('devicechange', this.handleDeviceChange);
  };

  _proto.createIdentifier = function createIdentifier(deviceInfo) {
    if (!deviceInfo) {
      return '';
    }

    return "" + deviceInfo.deviceId + deviceInfo.groupId;
  }
  /**
   * Function to get the device after device change
   * Chrome and Edge provide a default device from which we select the actual device
   * Firefox and safari give 0th device as system default
   * @returns {MediaDeviceInfo}
   */
  ;

  _proto.getNewAudioInputDevice = function getNewAudioInputDevice() {
    var defaultDevice = this.audioInput.find(function (device) {
      return device.deviceId === 'default';
    });

    if (defaultDevice) {
      // Selecting a non-default device so that the deviceId comparision does not give
      // false positives when device is removed, because the other available device
      // get's the deviceId as default once this device is removed
      var nextDevice = this.audioInput.find(function (device) {
        return device.label !== defaultDevice.label && defaultDevice.label.includes(device.label);
      });
      return nextDevice;
    }

    return this.audioInput[0];
  }
  /**
   * This method is to select the input/output from same group
   * same group meaning both input/output are of same device
   * This method might override the default coming from browser and system so as to select options from same
   * device type. This is required in certain cases where browser's default is not correct.
   * Algo:
   * 1. find the non default input device if selected one is default by matching device label
   * 2. find the corresponding output device which has the same group id or same label
   * 3. select the default one if nothing was found
   * 4. select the first option if there is no default
   */
  ;

  _proto.setOutputDevice = function setOutputDevice(deviceChange) {
    if (deviceChange === void 0) {
      deviceChange = false;
    }

    var inputDevice = this.getNewAudioInputDevice();
    var prevSelection = this.createIdentifier(this.outputDevice);
    this.outputDevice = undefined;

    if (inputDevice != null && inputDevice.groupId) {
      // only check for label because if groupId check is added it will select speaker
      // when an external earphone without microphone is added
      this.outputDevice = this.audioOutput.find(function (device) {
        return inputDevice.deviceId !== 'default' && device.label === inputDevice.label;
      });
    }

    if (!this.outputDevice) {
      // select default deviceId device if available, otherwise select 0th device
      this.outputDevice = this.audioOutput.find(function (device) {
        return device.deviceId === 'default';
      }) || this.audioOutput[0];
    }

    this.store.updateAudioOutputDevice(this.outputDevice); // send event only on device change and device is not same as previous

    if (deviceChange && prevSelection !== this.createIdentifier(this.outputDevice)) {
      this.eventEmitter.emit('audio-device-change', {
        selection: this.outputDevice,
        type: 'audioOutput',
        devices: this.getDevices()
      });
    }
  };

  _proto.addEventListener = function addEventListener(event, listener) {
    this.eventEmitter.addListener(event, listener);
  };

  _proto.removeEventListener = function removeEventListener(event, listener) {
    this.eventEmitter.removeListener(event, listener);
  };

  _proto.logDevices = function logDevices(label) {
    if (label === void 0) {
      label = '';
    }

    HMSLogger.d(this.TAG, label, JSON.stringify({
      videoInput: [].concat(this.videoInput),
      audioInput: [].concat(this.audioInput),
      audioOutput: [].concat(this.audioOutput),
      selected: this.getCurrentSelection()
    }, null, 4));
  };

  return DeviceManager;
}();

var AudioOutputManager = /*#__PURE__*/function () {
  function AudioOutputManager(deviceManager, audioSinkManager) {
    this.deviceManager = deviceManager;
    this.audioSinkManager = audioSinkManager;
  }

  var _proto = AudioOutputManager.prototype;

  _proto.getVolume = function getVolume() {
    return this.audioSinkManager.getVolume();
  };

  _proto.setVolume = function setVolume(value) {
    if (value < 0 || value > 100) {
      throw Error('Please pass a valid number between 0-100');
    }

    this.audioSinkManager.setVolume(value);
  };

  _proto.getDevice = function getDevice() {
    return this.deviceManager.outputDevice;
  };

  _proto.setDevice = function setDevice(deviceId) {
    return this.deviceManager.updateOutputDevice(deviceId);
  };

  _proto.unblockAutoplay = /*#__PURE__*/function () {
    var _unblockAutoplay = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee() {
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return this.audioSinkManager.unblockAutoplay();

            case 2:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function unblockAutoplay() {
      return _unblockAutoplay.apply(this, arguments);
    }

    return unblockAutoplay;
  }();

  return AudioOutputManager;
}();

/**
 * Used to sort list of items(peers/tracks) based on common use cases.
 * Usage: peerList.sort(comparator.getPeerComparators().audioLevel);
 */

var Comparator = /*#__PURE__*/function () {
  function Comparator(store) {
    this.store = store;
    /**
     * @returns a negative value if a is less than b, zero if they're equal and a positive value otherwise
     */

    this.primitiveComparator = function (a, b) {
      return a === b ? 0 : Number(a) - Number(b);
    };

    this.stringComparator = function (a, b) {
      return a === b ? 0 : a < b ? -1 : 1;
    };
  }

  var _proto = Comparator.prototype;

  _proto.getPeerComparators = function getPeerComparators() {
    var _this = this;

    return {
      videoEnabled: function videoEnabled(peerA, peerB) {
        var _peerA$videoTrack, _peerB$videoTrack;

        return _this.primitiveComparator(Boolean((_peerA$videoTrack = peerA.videoTrack) == null ? void 0 : _peerA$videoTrack.enabled), Boolean((_peerB$videoTrack = peerB.videoTrack) == null ? void 0 : _peerB$videoTrack.enabled));
      },
      audioEnabled: function audioEnabled(peerA, peerB) {
        var _peerA$audioTrack, _peerB$audioTrack;

        return _this.primitiveComparator(Boolean((_peerA$audioTrack = peerA.audioTrack) == null ? void 0 : _peerA$audioTrack.enabled), Boolean((_peerB$audioTrack = peerB.audioTrack) == null ? void 0 : _peerB$audioTrack.enabled));
      },
      screenShare: function screenShare(peerA, peerB) {
        return _this.primitiveComparator(peerA.auxiliaryTracks.some(function (track) {
          return track.source === 'screen';
        }), peerB.auxiliaryTracks.some(function (track) {
          return track.source === 'screen';
        }));
      },
      audioLevel: function audioLevel(peerA, peerB) {
        var _this$store$getSpeake, _this$store$getSpeake2;

        return _this.primitiveComparator(((_this$store$getSpeake = _this.store.getSpeakers().find(function (speaker) {
          return speaker.peer.peerId === (peerA == null ? void 0 : peerA.peerId);
        })) == null ? void 0 : _this$store$getSpeake.audioLevel) || -1, ((_this$store$getSpeake2 = _this.store.getSpeakers().find(function (speaker) {
          return speaker.peer.peerId === (peerB == null ? void 0 : peerB.peerId);
        })) == null ? void 0 : _this$store$getSpeake2.audioLevel) || -1);
      },
      rolePriority: function rolePriority(peerA, peerB) {
        var _peerA$role, _peerB$role;

        return _this.primitiveComparator(((_peerA$role = peerA.role) == null ? void 0 : _peerA$role.priority) || 0, ((_peerB$role = peerB.role) == null ? void 0 : _peerB$role.priority) || 0);
      }
    };
  };

  _proto.getTrackComparators = function getTrackComparators() {
    var _this2 = this;

    return {
      video: function video(trackA, trackB) {
        return _this2.primitiveComparator(trackA.type === exports.HMSTrackType.VIDEO, trackB.type === exports.HMSTrackType.VIDEO);
      },
      audio: function audio(trackA, trackB) {
        return _this2.primitiveComparator(trackA.type === exports.HMSTrackType.AUDIO, trackB.type === exports.HMSTrackType.AUDIO);
      },
      enabled: function enabled(trackA, trackB) {
        return _this2.primitiveComparator(Boolean(trackA.enabled), Boolean(trackB.enabled));
      },
      peerAudioLevel: function peerAudioLevel(trackA, trackB) {
        var peerA = _this2.store.getPeerByTrackId(trackA.trackId);

        var peerB = _this2.store.getPeerByTrackId(trackB.trackId);

        return _this2.getPeerComparators().audioLevel(peerA, peerB);
      },

      /**
       * Only HMSAudioTracks comparable as speaker objects have only HMSAudioTracks
       */
      audioLevel: function audioLevel(trackA, trackB) {
        var _this2$store$getSpeak, _this2$store$getSpeak2;

        return _this2.primitiveComparator(((_this2$store$getSpeak = _this2.store.getSpeakers().find(function (speaker) {
          return speaker.track.trackId === trackA.trackId;
        })) == null ? void 0 : _this2$store$getSpeak.audioLevel) || 0, ((_this2$store$getSpeak2 = _this2.store.getSpeakers().find(function (speaker) {
          return speaker.track.trackId === trackB.trackId;
        })) == null ? void 0 : _this2$store$getSpeak2.audioLevel) || 0);
      },
      screenShare: function screenShare(trackA, trackB) {
        return _this2.primitiveComparator(trackA.source === 'screen', trackB.source === 'screen');
      },
      rolePriority: function rolePriority(trackA, trackB) {
        var _this2$store$getPeerB, _this2$store$getPeerB2, _this2$store$getPeerB3, _this2$store$getPeerB4;

        return _this2.primitiveComparator(((_this2$store$getPeerB = _this2.store.getPeerByTrackId(trackA.trackId)) == null ? void 0 : (_this2$store$getPeerB2 = _this2$store$getPeerB.role) == null ? void 0 : _this2$store$getPeerB2.priority) || 0, ((_this2$store$getPeerB3 = _this2.store.getPeerByTrackId(trackB.trackId)) == null ? void 0 : (_this2$store$getPeerB4 = _this2$store$getPeerB3.role) == null ? void 0 : _this2$store$getPeerB4.priority) || 0);
      }
    };
  };

  return Comparator;
}();

var Store = /*#__PURE__*/function () {
  function Store() {
    this.comparator = new Comparator(this);
    this.knownRoles = {};
    this.peers = {};
    this.tracks = {}; // Not used currently. Will be used exclusively for preview tracks.
    // private previewTracks: Record<string, HMSTrack> = {};

    this.peerTrackStates = {};
    this.speakers = [];
    this.videoLayers = null;
    this.screenshareLayers = null;
  }

  var _proto = Store.prototype;

  _proto.getConfig = function getConfig() {
    return this.config;
  };

  _proto.getPublishParams = function getPublishParams() {
    return this.publishParams;
  };

  _proto.getComparator = function getComparator() {
    return this.comparator;
  };

  _proto.getRoom = function getRoom() {
    return this.room;
  };

  _proto.getPolicyForRole = function getPolicyForRole(role) {
    return this.knownRoles[role];
  };

  _proto.getKnownRoles = function getKnownRoles() {
    return this.knownRoles;
  };

  _proto.getLocalPeer = function getLocalPeer() {
    if (this.localPeerId && this.peers[this.localPeerId]) {
      return this.peers[this.localPeerId];
    }

    return undefined;
  };

  _proto.getRemotePeers = function getRemotePeers() {
    return Object.values(this.peers).filter(function (peer) {
      return !peer.isLocal;
    });
  };

  _proto.getPeers = function getPeers() {
    return Object.values(this.peers);
  };

  _proto.getPeerById = function getPeerById(peerId) {
    if (this.peers[peerId]) {
      return this.peers[peerId];
    }

    return undefined;
  };

  _proto.getTracks = function getTracks() {
    return Object.values(this.tracks);
  };

  _proto.getVideoTracks = function getVideoTracks() {
    return this.getTracks().filter(function (track) {
      return track.type === exports.HMSTrackType.VIDEO;
    });
  };

  _proto.getRemoteVideoTracks = function getRemoteVideoTracks() {
    return this.getTracks().filter(function (track) {
      return track instanceof HMSRemoteVideoTrack;
    });
  };

  _proto.getAudioTracks = function getAudioTracks() {
    return this.getTracks().filter(function (track) {
      return track.type === exports.HMSTrackType.AUDIO;
    });
  };

  _proto.getPeerTracks = function getPeerTracks(peerId) {
    var peer = peerId ? this.peers[peerId] : undefined;
    var tracks = [];
    (peer == null ? void 0 : peer.videoTrack) && tracks.push(peer.videoTrack);
    (peer == null ? void 0 : peer.audioTrack) && tracks.push(peer.audioTrack);
    return tracks.concat((peer == null ? void 0 : peer.auxiliaryTracks) || []);
  };

  _proto.getLocalPeerTracks = function getLocalPeerTracks() {
    return this.getPeerTracks(this.localPeerId);
  };

  _proto.getTrackById = function getTrackById(trackId) {
    return this.tracks[trackId];
  };

  _proto.getPeerByTrackId = function getPeerByTrackId(trackId) {
    var track = this.tracks[trackId];
    return track.peerId ? this.peers[track.peerId] : undefined;
  };

  _proto.getSpeakers = function getSpeakers() {
    return this.speakers;
  };

  _proto.getSpeakerPeers = function getSpeakerPeers() {
    return this.speakers.map(function (speaker) {
      return speaker.peer;
    });
  };

  _proto.setRoom = function setRoom(room) {
    this.room = room;
  };

  _proto.setKnownRoles = function setKnownRoles(knownRoles) {
    this.knownRoles = knownRoles;
    this.updatePeersPolicy();
  };

  _proto.setConfig = function setConfig(config) {
    DeviceStorageManager.rememberDevices(Boolean(config.rememberDeviceSelection));

    if (config.rememberDeviceSelection) {
      var devices = DeviceStorageManager.getSelection();

      if (devices) {
        var _devices$audioInput, _devices$audioOutput, _devices$videoInput;

        if (!config.settings) {
          config.settings = {};
        }

        if ((_devices$audioInput = devices.audioInput) != null && _devices$audioInput.deviceId) {
          config.settings.audioInputDeviceId = config.settings.audioInputDeviceId || devices.audioInput.deviceId;
        }

        if ((_devices$audioOutput = devices.audioOutput) != null && _devices$audioOutput.deviceId) {
          config.settings.audioOutputDeviceId = config.settings.audioOutputDeviceId || devices.audioOutput.deviceId;
        }

        if ((_devices$videoInput = devices.videoInput) != null && _devices$videoInput.deviceId) {
          config.settings.videoDeviceId = config.settings.videoDeviceId || devices.videoInput.deviceId;
        }
      }
    }

    this.config = config;
  };

  _proto.setPublishParams = function setPublishParams(params) {
    this.publishParams = params;
  };

  _proto.addPeer = function addPeer(peer) {
    this.peers[peer.peerId] = peer;
    if (peer.isLocal) this.localPeerId = peer.peerId;
  }
  /**
   * @param {HMSTrack} track the published track that has to be added
   *
   * Note: Only use this method to add published tracks not preview traks
   */
  ;

  _proto.addTrack = function addTrack(track) {
    this.tracks[track.trackId] = track;
  };

  _proto.getTrackState = function getTrackState(trackId) {
    return this.peerTrackStates[trackId];
  };

  _proto.setTrackState = function setTrackState(trackStateEntry) {
    this.peerTrackStates[trackStateEntry.trackInfo.track_id] = trackStateEntry;
  };

  _proto.removePeer = function removePeer(peerId) {
    if (this.localPeerId === peerId) this.localPeerId = undefined;
    delete this.peers[peerId];
  };

  _proto.removeTrack = function removeTrack(trackId) {
    delete this.tracks[trackId];
  };

  _proto.updateSpeakers = function updateSpeakers(speakers) {
    this.speakers = speakers;
  };

  _proto.updateAudioOutputVolume = function updateAudioOutputVolume(value) {
    this.getAudioTracks().forEach(function (track) {
      return track.setVolume(value);
    });
  };

  _proto.updateAudioOutputDevice = function updateAudioOutputDevice(device) {
    this.getAudioTracks().forEach(function (track) {
      track.setOutputDevice(device);
    });
  };

  _proto.getSubscribeDegradationParams = function getSubscribeDegradationParams() {
    var _this$getLocalPeer, _this$getLocalPeer$ro;

    var params = (_this$getLocalPeer = this.getLocalPeer()) == null ? void 0 : (_this$getLocalPeer$ro = _this$getLocalPeer.role) == null ? void 0 : _this$getLocalPeer$ro.subscribeParams.subscribeDegradation;

    if (params && Object.keys(params).length > 0) {
      return params;
    }

    return undefined;
  };

  _proto.getSimulcastLayers = function getSimulcastLayers(source) {
    var _this$videoLayers;

    if (source === 'screen') {
      var _this$screenshareLaye;

      return ((_this$screenshareLaye = this.screenshareLayers) == null ? void 0 : _this$screenshareLaye.layers) || [];
    }

    return ((_this$videoLayers = this.videoLayers) == null ? void 0 : _this$videoLayers.layers) || [];
  };

  _proto.getSimulcastDimensions = function getSimulcastDimensions(source) {
    var layers = source === 'screen' ? this.screenshareLayers : this.videoLayers;
    var width = layers == null ? void 0 : layers.width;
    var height = layers == null ? void 0 : layers.height;
    return {
      width: width,
      height: height
    };
  }
  /**
   * Convert maxBitrate from kbps to bps
   * @internal
   * @param simulcastLayers
   * @returns {SimulcastLayers}
   */
  ;

  _proto.convertSimulcastLayers = function convertSimulcastLayers(simulcastLayers) {
    return _extends({}, simulcastLayers, {
      layers: (simulcastLayers.layers || []).map(function (layer) {
        return _extends({}, layer, {
          maxBitrate: layer.maxBitrate * 1000
        });
      })
    });
  };

  _proto.setVideoSimulcastLayers = function setVideoSimulcastLayers(simulcastLayers) {
    this.videoLayers = this.convertSimulcastLayers(simulcastLayers);
  };

  _proto.setScreenshareSimulcastLayers = function setScreenshareSimulcastLayers(simulcastLayers) {
    this.screenshareLayers = this.convertSimulcastLayers(simulcastLayers);
  };

  _proto.getSimulcastDefinitionsForPeer = function getSimulcastDefinitionsForPeer(peer, source) {
    if (!peer.role) return [];
    var publishParams = this.getPolicyForRole(peer.role.name).publishParams;
    var simulcastLayers;

    if (source === 'regular') {
      simulcastLayers = publishParams.videoSimulcastLayers;
    } else if (source === 'screen') {
      simulcastLayers = publishParams.screenSimulcastLayers;
    }

    if (!simulcastLayers || !simulcastLayers.layers || simulcastLayers.layers.length === 0) {
      return [];
    }

    var width = simulcastLayers.width;
    var height = simulcastLayers.height;
    return simulcastLayers.layers.map(function (value) {
      var layer = simulcastMapping[value.rid];
      var resolution = {
        width: width && value.scaleResolutionDownBy ? width / value.scaleResolutionDownBy : undefined,
        height: height && value.scaleResolutionDownBy ? height / value.scaleResolutionDownBy : undefined
      };
      return {
        layer: layer,
        resolution: resolution
      };
    });
  };

  _proto.cleanUp = function cleanUp() {
    var tracks = this.getTracks();

    for (var _iterator = _createForOfIteratorHelperLoose(tracks), _step; !(_step = _iterator()).done;) {
      var track = _step.value;
      track.cleanup();
    }

    this.config = undefined;
  };

  _proto.setErrorListener = function setErrorListener(listener) {
    this.errorListener = listener;
  };

  _proto.updatePeersPolicy = function updatePeersPolicy() {
    var _this = this;

    this.getPeers().forEach(function (peer) {
      if (!peer.role) {
        var _this$errorListener;

        (_this$errorListener = _this.errorListener) == null ? void 0 : _this$errorListener.onError(ErrorFactory.GenericErrors.InvalidRole(HMSAction.VALIDATION, ''));
        return;
      }

      peer.role = _this.getPolicyForRole(peer.role.name);
    });
  };

  return Store;
}();

var RoleChangeManager = /*#__PURE__*/function () {
  function RoleChangeManager(store, transport, publish, removeAuxillaryTrack, listener) {
    var _this = this;

    this.store = store;
    this.transport = transport;
    this.publish = publish;
    this.removeAuxillaryTrack = removeAuxillaryTrack;
    this.listener = listener;

    this.handleLocalPeerRoleUpdate = /*#__PURE__*/function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(event) {
        var _this$store$getConfig, _this$listener;

        var localPeer, oldRole, newRole, wasPublishing, isPublishing, toRemove, initialSettings;
        return runtime_1.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                localPeer = _this.store.getLocalPeer();

                if (localPeer) {
                  _context.next = 3;
                  break;
                }

                return _context.abrupt("return");

              case 3:
                oldRole = event.detail.oldRole;
                newRole = event.detail.newRole;
                wasPublishing = oldRole.publishParams.allowed || [];
                isPublishing = newRole.publishParams.allowed || [];
                toRemove = {
                  removeVideo: false,
                  removeAudio: false,
                  removeScreen: false
                };

                if (wasPublishing.length > 0) {
                  // check if we have to remove any tracks
                  if (isPublishing.length === 0) {
                    toRemove.removeVideo = true;
                    toRemove.removeAudio = true;
                    toRemove.removeScreen = true;
                  } else {
                    if (wasPublishing.includes('video') && !isPublishing.includes('video')) {
                      toRemove.removeVideo = true;
                    }

                    if (wasPublishing.includes('audio') && !isPublishing.includes('audio')) {
                      toRemove.removeAudio = true;
                    }

                    if (wasPublishing.includes('screen') && !isPublishing.includes('screen')) {
                      toRemove.removeScreen = true;
                    }
                  }
                }

                _context.next = 11;
                return _this.removeLocalTracks(toRemove);

              case 11:
                _this.store.setPublishParams(newRole.publishParams);

                initialSettings = ((_this$store$getConfig = _this.store.getConfig()) == null ? void 0 : _this$store$getConfig.settings) || {
                  isAudioMuted: true,
                  isVideoMuted: true,
                  audioInputDeviceId: 'default',
                  videoDeviceId: 'default',
                  audioOutputDeviceId: 'default'
                }; // call publish with new settings, local track manager will diff policies

                _context.next = 15;
                return _this.publish(_extends({}, initialSettings, {
                  isAudioMuted: true,
                  isVideoMuted: true
                }));

              case 15:
                (_this$listener = _this.listener) == null ? void 0 : _this$listener.onPeerUpdate(exports.HMSPeerUpdate.ROLE_UPDATED, localPeer);

              case 16:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      return function (_x) {
        return _ref.apply(this, arguments);
      };
    }();
  }

  var _proto = RoleChangeManager.prototype;

  _proto.removeLocalTracks = /*#__PURE__*/function () {
    var _removeLocalTracks = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(_ref2) {
      var removeVideo, removeAudio, removeScreen, localPeer, tracksToUnpublish, _i, _tracksToUnpublish, _this$listener2, track, localAuxTracks, _iterator, _step, _track;

      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              removeVideo = _ref2.removeVideo, removeAudio = _ref2.removeAudio, removeScreen = _ref2.removeScreen;
              localPeer = this.store.getLocalPeer();

              if (localPeer) {
                _context2.next = 4;
                break;
              }

              return _context2.abrupt("return");

            case 4:
              tracksToUnpublish = []; // TODO check auxillary tracks for regular audio and video too

              if (localPeer != null && localPeer.videoTrack && removeVideo) {
                // TODO: stop processed track and cleanup plugins loop non async
                // vb can throw change role off otherwise
                tracksToUnpublish.push(localPeer.videoTrack);
                localPeer.videoTrack = undefined;
              }

              if (localPeer != null && localPeer.audioTrack && removeAudio) {
                tracksToUnpublish.push(localPeer.audioTrack);
                localPeer.audioTrack = undefined;
              }

              _context2.next = 9;
              return this.transport.unpublish(tracksToUnpublish);

            case 9:
              for (_i = 0, _tracksToUnpublish = tracksToUnpublish; _i < _tracksToUnpublish.length; _i++) {
                track = _tracksToUnpublish[_i];
                (_this$listener2 = this.listener) == null ? void 0 : _this$listener2.onTrackUpdate(exports.HMSTrackUpdate.TRACK_REMOVED, track, localPeer);
              }

              if (!(localPeer.auxiliaryTracks && removeScreen)) {
                _context2.next = 20;
                break;
              }

              localAuxTracks = [].concat(localPeer.auxiliaryTracks);
              _iterator = _createForOfIteratorHelperLoose(localAuxTracks);

            case 13:
              if ((_step = _iterator()).done) {
                _context2.next = 20;
                break;
              }

              _track = _step.value;

              if (!(_track.source === 'screen')) {
                _context2.next = 18;
                break;
              }

              _context2.next = 18;
              return this.removeAuxillaryTrack(_track.trackId);

            case 18:
              _context2.next = 13;
              break;

            case 20:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));

    function removeLocalTracks(_x2) {
      return _removeLocalTracks.apply(this, arguments);
    }

    return removeLocalTracks;
  }();

  return RoleChangeManager;
}();

var defaultSettings = {
  isAudioMuted: false,
  isVideoMuted: false,
  audioInputDeviceId: 'default',
  audioOutputDeviceId: 'default',
  videoDeviceId: 'default'
};
var blankCanvas$1;
var LocalTrackManager = /*#__PURE__*/function () {
  function LocalTrackManager(store, observer, deviceManager) {
    this.store = store;
    this.observer = observer;
    this.deviceManager = deviceManager;
    this.TAG = '[LocalTrackManager]';
  }

  var _proto = LocalTrackManager.prototype;

  _proto.getTracksToPublish = /*#__PURE__*/function () {
    var _getTracksToPublish = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(initialSettings) {
      var publishParams, allowed, canPublishAudio, canPublishVideo, tracksToPublish, trackSettings, localTracks, videoTrack, audioTrack, screenTrack, isVideoTrackPublished, isAudioTrackPublished, fetchTrackOptions, audioFailure, videoFailure, _tracksToPublish, _tracksToPublish2;

      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              publishParams = this.store.getPublishParams();

              if (publishParams) {
                _context.next = 3;
                break;
              }

              return _context.abrupt("return", []);

            case 3:
              allowed = publishParams.allowed;
              canPublishAudio = Boolean(allowed && allowed.includes('audio'));
              canPublishVideo = Boolean(allowed && allowed.includes('video'));

              if (!(!canPublishAudio && !canPublishVideo)) {
                _context.next = 8;
                break;
              }

              return _context.abrupt("return", []);

            case 8:
              tracksToPublish = [];
              trackSettings = this.getTrackSettings(initialSettings, publishParams);

              if (trackSettings) {
                _context.next = 12;
                break;
              }

              return _context.abrupt("return", []);

            case 12:
              localTracks = this.store.getLocalPeerTracks();
              videoTrack = localTracks.find(function (t) {
                return t.type === exports.HMSTrackType.VIDEO && t.source === 'regular';
              });
              audioTrack = localTracks.find(function (t) {
                return t.type === exports.HMSTrackType.AUDIO && t.source === 'regular';
              });
              screenTrack = localTracks.find(function (t) {
                return t.type === exports.HMSTrackType.VIDEO && t.source === 'screen';
              }); // The track gets added to the store only after it is published.

              isVideoTrackPublished = Boolean(videoTrack && this.store.getTrackById(videoTrack.trackId));
              isAudioTrackPublished = Boolean(audioTrack && this.store.getTrackById(audioTrack.trackId));

              if (!(videoTrack && trackSettings.video)) {
                _context.next = 21;
                break;
              }

              _context.next = 21;
              return videoTrack.setSettings(trackSettings.video);

            case 21:
              if (!(audioTrack && trackSettings.audio)) {
                _context.next = 24;
                break;
              }

              _context.next = 24;
              return audioTrack.setSettings(trackSettings.audio);

            case 24:
              if (screenTrack && trackSettings.screen) {
                screenTrack.setSettings(trackSettings.screen);
              }

              if (!(isVideoTrackPublished && isAudioTrackPublished)) {
                _context.next = 27;
                break;
              }

              return _context.abrupt("return", []);

            case 27:
              fetchTrackOptions = {
                audio: canPublishAudio && !audioTrack && (initialSettings.isAudioMuted ? 'empty' : true),
                video: canPublishVideo && !videoTrack && (initialSettings.isVideoMuted ? 'empty' : true)
              };
              _context.prev = 28;
              HMSLogger.d(this.TAG, 'Init Local Tracks', {
                fetchTrackOptions: fetchTrackOptions
              });
              _context.next = 32;
              return this.getLocalTracks(fetchTrackOptions, trackSettings);

            case 32:
              tracksToPublish = _context.sent;
              _context.next = 69;
              break;

            case 35:
              _context.prev = 35;
              _context.t0 = _context["catch"](28);

              if (!(_context.t0 instanceof HMSException && _context.t0.action === HMSAction.TRACK)) {
                _context.next = 67;
                break;
              }

              this.observer.onFailure(_context.t0);
              audioFailure = _context.t0.message.includes('audio');
              videoFailure = _context.t0.message.includes('video');
              fetchTrackOptions.audio = audioFailure ? 'empty' : fetchTrackOptions.audio;
              fetchTrackOptions.video = videoFailure ? 'empty' : fetchTrackOptions.video;
              HMSLogger.w(this.TAG, 'Fetch AV Tracks failed', {
                fetchTrackOptions: fetchTrackOptions
              }, _context.t0);
              _context.prev = 44;
              _context.t1 = (_tracksToPublish = tracksToPublish).push;
              _context.t2 = _tracksToPublish;
              _context.next = 49;
              return this.getLocalTracks(fetchTrackOptions, trackSettings);

            case 49:
              _context.t3 = _context.sent;

              _context.t1.apply.call(_context.t1, _context.t2, _context.t3);

              _context.next = 65;
              break;

            case 53:
              _context.prev = 53;
              _context.t4 = _context["catch"](44);
              HMSLogger.w(this.TAG, 'Fetch empty tacks failed', _context.t4);
              fetchTrackOptions.audio = fetchTrackOptions.audio && 'empty';
              fetchTrackOptions.video = fetchTrackOptions.video && 'empty';
              _context.t5 = (_tracksToPublish2 = tracksToPublish).push;
              _context.t6 = _tracksToPublish2;
              _context.next = 62;
              return this.getLocalTracks(fetchTrackOptions, trackSettings);

            case 62:
              _context.t7 = _context.sent;

              _context.t5.apply.call(_context.t5, _context.t6, _context.t7);

              this.observer.onFailure(ErrorFactory.TracksErrors.GenericTrack(HMSAction.TRACK, _context.t4.message));

            case 65:
              _context.next = 69;
              break;

            case 67:
              HMSLogger.w(this.TAG, 'Fetch AV Tracks failed - unknown exception', _context.t0);
              this.observer.onFailure(ErrorFactory.TracksErrors.GenericTrack(HMSAction.TRACK, _context.t0.message));

            case 69:
              /**
               * concat local tracks only if both are true which means it is either join or switched from a role
               * with no tracks earlier.
               * the reason we need this is for preview API to work, in case of preview we want to publish the same
               * tracks which were shown and are already part of the local peer instead of creating new ones.
               * */
              // if (publishConfig.publishAudio && publishConfig.publishVideo) {
              //   return tracks.concat(localTracks);
              // }
              if (videoTrack && canPublishVideo && !isVideoTrackPublished) {
                tracksToPublish.push(videoTrack);
              }

              if (audioTrack && canPublishAudio && !isAudioTrackPublished) {
                tracksToPublish.push(audioTrack);
              }

              return _context.abrupt("return", tracksToPublish);

            case 72:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this, [[28, 35], [44, 53]]);
    }));

    function getTracksToPublish(_x) {
      return _getTracksToPublish.apply(this, arguments);
    }

    return getTracksToPublish;
  }();

  _proto.getLocalTracks = /*#__PURE__*/function () {
    var _getLocalTracks = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(fetchTrackOptions, settings) {
      var nativeTracks, nativeVideoTrack, nativeAudioTrack, local, tracks, audioTrack, videoTrack;
      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (fetchTrackOptions === void 0) {
                fetchTrackOptions = {
                  audio: true,
                  video: true
                };
              }

              _context2.prev = 1;
              _context2.next = 4;
              return this.getNativeLocalTracks(fetchTrackOptions, settings);

            case 4:
              nativeTracks = _context2.sent;
              nativeVideoTrack = nativeTracks.find(function (track) {
                return track.kind === 'video';
              });
              nativeAudioTrack = nativeTracks.find(function (track) {
                return track.kind === 'audio';
              });
              local = new HMSLocalStream(new MediaStream(nativeTracks));
              tracks = [];

              if (nativeAudioTrack && settings != null && settings.audio) {
                audioTrack = new HMSLocalAudioTrack(local, nativeAudioTrack, 'regular', settings.audio);
                tracks.push(audioTrack);
              }

              if (nativeVideoTrack && settings != null && settings.video) {
                videoTrack = new HMSLocalVideoTrack(local, nativeVideoTrack, 'regular', settings.video);
                tracks.push(videoTrack);
              }

              return _context2.abrupt("return", tracks);

            case 14:
              _context2.prev = 14;
              _context2.t0 = _context2["catch"](1);

              // TOOD: On OverConstrained error, retry with dropping all constraints.
              // Just retry getusermedia again - it sometimes work when AbortError or NotFoundError is thrown on a few devices
              if (_context2.t0 instanceof HMSException) {
                analyticsEventsService.queue(AnalyticsEventFactory.publish({
                  devices: this.deviceManager.getDevices(),
                  error: _context2.t0,
                  settings: settings
                })).flush();
              }

              throw _context2.t0;

            case 18:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this, [[1, 14]]);
    }));

    function getLocalTracks(_x2, _x3) {
      return _getLocalTracks.apply(this, arguments);
    }

    return getLocalTracks;
  }();

  _proto.getNativeLocalTracks = /*#__PURE__*/function () {
    var _getNativeLocalTracks = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3(fetchTrackOptions, settings) {
      var trackSettings, nativeTracks;
      return runtime_1.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              if (fetchTrackOptions === void 0) {
                fetchTrackOptions = {
                  audio: false,
                  video: false
                };
              }

              trackSettings = new HMSTrackSettings(fetchTrackOptions.video === true ? settings.video : null, fetchTrackOptions.audio === true ? settings.audio : null, settings.simulcast);
              nativeTracks = [];

              if (!(trackSettings.audio || trackSettings.video)) {
                _context3.next = 10;
                break;
              }

              _context3.t0 = nativeTracks.push;
              _context3.t1 = nativeTracks;
              _context3.next = 8;
              return this.getAVTracks(trackSettings);

            case 8:
              _context3.t2 = _context3.sent;

              _context3.t0.apply.call(_context3.t0, _context3.t1, _context3.t2);

            case 10:
              if (fetchTrackOptions.audio === 'empty') {
                nativeTracks.push(this.getEmptyAudioTrack());
              }

              if (fetchTrackOptions.video === 'empty') {
                nativeTracks.push(this.getEmptyVideoTrack());
              }

              return _context3.abrupt("return", nativeTracks);

            case 13:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, this);
    }));

    function getNativeLocalTracks(_x4, _x5) {
      return _getNativeLocalTracks.apply(this, arguments);
    }

    return getNativeLocalTracks;
  }();

  _proto.getEmptyVideoTrack = function getEmptyVideoTrack(prevTrack) {
    var _prevTrack$getSetting, _prevTrack$getSetting2;

    var width = (prevTrack == null ? void 0 : (_prevTrack$getSetting = prevTrack.getSettings()) == null ? void 0 : _prevTrack$getSetting.width) || 320;
    var height = (prevTrack == null ? void 0 : (_prevTrack$getSetting2 = prevTrack.getSettings()) == null ? void 0 : _prevTrack$getSetting2.height) || 240;
    var frameRate = 10; // fps TODO: experiment, see if this can be reduced

    if (!blankCanvas$1) {
      var _blankCanvas$getConte;

      blankCanvas$1 = Object.assign(document.createElement('canvas'), {
        width: width,
        height: height
      });
      (_blankCanvas$getConte = blankCanvas$1.getContext('2d')) == null ? void 0 : _blankCanvas$getConte.fillRect(0, 0, width, height);
    }

    var stream = blankCanvas$1.captureStream(frameRate);
    var emptyTrack = stream.getVideoTracks()[0];
    var intervalID = setInterval(function () {
      if (emptyTrack.readyState === 'ended') {
        clearInterval(intervalID);
        return;
      }

      var ctx = blankCanvas$1.getContext('2d');

      if (ctx) {
        var pixel = ctx.getImageData(0, 0, 1, 1).data;
        var red = pixel[0] === 0 ? 1 : 0; // toggle red in pixel

        ctx.fillStyle = "rgb(" + red + ", 0, 0)";
        ctx.fillRect(0, 0, 1, 1);
      }
    }, 1000 / frameRate);

    emptyTrack.onended = function () {
      clearInterval(intervalID);
    };

    emptyTrack.enabled = false;
    return emptyTrack;
  };

  _proto.getEmptyAudioTrack = function getEmptyAudioTrack() {
    var ctx = new AudioContext();
    var oscillator = ctx.createOscillator();
    var dst = oscillator.connect(ctx.createMediaStreamDestination());
    oscillator.start(); // @ts-expect-error

    var emptyTrack = dst.stream.getAudioTracks()[0];
    emptyTrack.enabled = false;
    return emptyTrack;
  };

  _proto.getAVTracks = /*#__PURE__*/function () {
    var _getAVTracks = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4(settings) {
      var stream, videoError, audioError;
      return runtime_1.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              _context4.prev = 0;
              _context4.next = 3;
              return navigator.mediaDevices.getUserMedia({
                audio: settings.audio ? settings.audio.toConstraints() : false,
                video: settings.video ? settings.video.toConstraints() : false
              });

            case 3:
              stream = _context4.sent;
              return _context4.abrupt("return", stream.getVideoTracks().concat(stream.getAudioTracks()));

            case 7:
              _context4.prev = 7;
              _context4.t0 = _context4["catch"](0);
              videoError = false;
              audioError = false;
              _context4.next = 13;
              return this.deviceManager.init();

            case 13:
              if (!this.deviceManager.hasWebcamPermission && settings.video) {
                videoError = true;
              }

              if (!this.deviceManager.hasMicrophonePermission && settings.audio) {
                audioError = true;
              }

              if (!(videoError && audioError)) {
                _context4.next = 19;
                break;
              }

              throw BuildGetMediaError(_context4.t0, HMSGetMediaActions.AV);

            case 19:
              if (!videoError) {
                _context4.next = 23;
                break;
              }

              throw BuildGetMediaError(_context4.t0, HMSGetMediaActions.VIDEO);

            case 23:
              throw BuildGetMediaError(_context4.t0, HMSGetMediaActions.AUDIO);

            case 24:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4, this, [[0, 7]]);
    }));

    function getAVTracks(_x6) {
      return _getAVTracks.apply(this, arguments);
    }

    return getAVTracks;
  }();

  _proto.getTrackSettings = function getTrackSettings(initialSettings, publishParams) {
    var audio = publishParams.audio,
        video = publishParams.video,
        screen = publishParams.screen,
        allowed = publishParams.allowed;
    var canPublishAudio = Boolean(allowed && allowed.includes('audio'));
    var canPublishVideo = Boolean(allowed && allowed.includes('video'));
    var canPublishScreen = Boolean(allowed && allowed.includes('screen'));

    if (!canPublishAudio && !canPublishVideo) {
      return null;
    }

    var audioInputDeviceId = initialSettings.audioInputDeviceId,
        videoDeviceId = initialSettings.videoDeviceId;
    var audioSettings = null;
    var videoSettings = null;
    var screenSettings = null;

    if (canPublishAudio) {
      audioSettings = new HMSAudioTrackSettingsBuilder().codec(audio.codec).maxBitrate(audio.bitRate).deviceId(audioInputDeviceId || defaultSettings.audioInputDeviceId).build();
    }

    if (canPublishVideo) {
      var dimensions = this.store.getSimulcastDimensions('regular');
      videoSettings = new HMSVideoTrackSettingsBuilder().codec(video.codec).maxBitrate(video.bitRate).maxFramerate(video.frameRate).setWidth((dimensions == null ? void 0 : dimensions.width) || video.width) // take simulcast width if available
      .setHeight((dimensions == null ? void 0 : dimensions.height) || video.height) // take simulcast width if available
      .deviceId(videoDeviceId || defaultSettings.videoDeviceId).build();
    }

    if (canPublishScreen) {
      var _dimensions = this.store.getSimulcastDimensions('screen');

      screenSettings = new HMSVideoTrackSettingsBuilder() // Don't cap maxBitrate for screenshare.
      // If publish params doesn't have bitRate value - don't set maxBitrate.
      .maxBitrate(screen.bitRate, false).codec(screen.codec).maxFramerate(screen.frameRate).setWidth((_dimensions == null ? void 0 : _dimensions.width) || screen.width).setHeight((_dimensions == null ? void 0 : _dimensions.height) || screen.height).build();
    }

    return new HMSTrackSettingsBuilder().video(videoSettings).audio(audioSettings).screen(screenSettings).build();
  };

  return LocalTrackManager;
}();

var AudioContextManager = /*#__PURE__*/function () {
  function AudioContextManager(element) {
    this.audioContext = new AudioContext();
    this.source = this.audioContext.createMediaElementSource(element);
    this.source.connect(this.audioContext.destination);
  }
  /**
   * Resume AudioContext if it is suspended
   * Note: when the browser tab is muted by default, AudioContext will be in suspended state
   * It has to be resumed for the video/audio to be played.
   */


  var _proto = AudioContextManager.prototype;

  _proto.resumeContext = function resumeContext() {
    if (this.audioContext.state === 'suspended') {
      HMSLogger.d(this.TAG, 'AudioContext is resumed');
      this.audioContext.resume();
    }
  };

  _proto.getAudioTrack = function getAudioTrack() {
    // Always create a destinationNode to get new audio track id
    if (this.destinationNode) {
      this.source.disconnect(this.destinationNode);
    }

    this.destinationNode = this.audioContext.createMediaStreamDestination();
    this.source.connect(this.destinationNode);
    return this.destinationNode.stream.getAudioTracks()[0];
  };

  _proto.cleanup = function cleanup() {
    if (this.audioContext.state !== 'closed') {
      this.audioContext.close();
    }
  };

  _createClass(AudioContextManager, [{
    key: "TAG",
    get: function get() {
      return 'AudioContextManager';
    }
  }]);

  return AudioContextManager;
}();

/**
 * This class handles audio playlist management
 * - An audio element and audio context which processes audio from audio element is created
 *   in the constructor
 * It handles playback in the following steps
 *  - set's the url on the audio element created in the constructor
 *  - oncanplaythrough event of the audio element
 *    - resume the audio context if it is suspended
 *    - play the audio element
 *    - Get audio track from the audio context manager
 *    - The track is passed to playlist manager to publish
 */

var PlaylistAudioManager = /*#__PURE__*/function (_TypedEventEmitter) {
  _inheritsLoose(PlaylistAudioManager, _TypedEventEmitter);

  function PlaylistAudioManager() {
    var _this;

    _this = _TypedEventEmitter.call(this) || this; // This is to handle audio playing when seekTo is called when audio is paused

    _this.seeked = false;
    _this.audioElement = _this.getAudioElement();
    return _this;
  }

  var _proto = PlaylistAudioManager.prototype;

  _proto.play = /*#__PURE__*/function () {
    var _play = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(url) {
      var _this2 = this;

      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              return _context2.abrupt("return", new Promise(function (resolve, reject) {
                _this2.audioElement = _this2.getAudioElement();
                _this2.audioElement.src = url;
                _this2.seeked = false;

                _this2.audioElement.onerror = function () {
                  var error = "Error loading " + url;
                  HMSLogger.e(_this2.TAG, error);

                  _this2.stop();

                  reject(error);
                }; // oncanplaythrough is called when enough media is loaded for play to be possible in two cases -
                //    * when play is called for the first time
                //    * when user seeks jumps to any mid track timestamp


                // oncanplaythrough is called when enough media is loaded for play to be possible in two cases -
                //    * when play is called for the first time
                //    * when user seeks jumps to any mid track timestamp
                _this2.audioElement.oncanplaythrough = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee() {
                  var audioTrack;
                  return runtime_1.wrap(function _callee$(_context) {
                    while (1) {
                      switch (_context.prev = _context.next) {
                        case 0:
                          _context.prev = 0;

                          if (_this2.audioElement) {
                            _context.next = 3;
                            break;
                          }

                          return _context.abrupt("return");

                        case 3:
                          _this2.audioContextManager.resumeContext(); // Create audio track only once and reuse, it will be updated with current content


                          if (_this2.track) {
                            _context.next = 12;
                            break;
                          }

                          _context.next = 7;
                          return _this2.audioElement.play();

                        case 7:
                          audioTrack = _this2.audioContextManager.getAudioTrack();
                          _this2.track = audioTrack;
                          resolve([audioTrack]);
                          _context.next = 19;
                          break;

                        case 12:
                          if (_this2.seeked) {
                            _context.next = 18;
                            break;
                          }

                          _context.next = 15;
                          return _this2.audioElement.play();

                        case 15:
                          resolve([_this2.track]);
                          _context.next = 19;
                          break;

                        case 18:
                          // if seek happened, there is no play call/promise to be resolved, just reset seeked
                          _this2.seeked = false;

                        case 19:
                          _context.next = 25;
                          break;

                        case 21:
                          _context.prev = 21;
                          _context.t0 = _context["catch"](0);
                          HMSLogger.e(_this2.TAG, 'Error playing audio', url, _context.t0.message);
                          reject(_context.t0);

                        case 25:
                        case "end":
                          return _context.stop();
                      }
                    }
                  }, _callee, null, [[0, 21]]);
                }));

                _this2.audioElement.onseeked = function () {
                  _this2.seeked = true;
                };
              }));

            case 1:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));

    function play(_x) {
      return _play.apply(this, arguments);
    }

    return play;
  }();

  _proto.getTracks = function getTracks() {
    return this.track ? [this.track.id] : [];
  };

  _proto.getElement = function getElement() {
    return this.audioElement;
  };

  _proto.stop = function stop() {
    var _this$audioElement, _this$audioElement2;

    (_this$audioElement = this.audioElement) == null ? void 0 : _this$audioElement.pause();
    (_this$audioElement2 = this.audioElement) == null ? void 0 : _this$audioElement2.removeAttribute('src');
    this.audioElement = null;
    this.audioContextManager.cleanup();
    this.track = undefined;
  };

  _proto.getAudioElement = function getAudioElement() {
    var _this3 = this;

    if (this.audioElement) {
      return this.audioElement;
    }

    var audioElement = document.createElement('audio');
    audioElement.crossOrigin = 'anonymous';
    audioElement.addEventListener('timeupdate', function (event) {
      return _this3.emit('progress', event);
    });
    audioElement.addEventListener('ended', function () {
      _this3.emit('ended', null);
    });
    this.audioContextManager = new AudioContextManager(audioElement);
    return audioElement;
  };

  _createClass(PlaylistAudioManager, [{
    key: "TAG",
    get: function get() {
      return 'PlaylistAudioManager';
    }
  }]);

  return PlaylistAudioManager;
}(TypedEventEmitter);

/**
 * This class handles video playlist management
 * - An video element, canvas and audio context which processes audio from video element is created
 *   in the constructor
 * It handles playback in the following steps
 *  - set's the url on the video element created in the constructor
 *  - oncanplaythrough event of the video element
 *    - resume the audio context if it is suspended
 *    - set width/height on canvas
 *    - captureStream on canvas element if not already captured
 *    - play the video element
 *    - on video element is played, it is drawn to canvas
 *    - Get audio track from the audio context manager
 *    - add audioTrack to canvas stream
 *    - The audio and video tracks are passed to playlist manager to publish
 */

var PlaylistVideoManager = /*#__PURE__*/function (_TypedEventEmitter) {
  _inheritsLoose(PlaylistVideoManager, _TypedEventEmitter);

  function PlaylistVideoManager() {
    var _this;

    _this = _TypedEventEmitter.call(this) || this;
    _this.tracks = [];
    _this.DEFAUL_FPS = 24; // This is to handle video playing when seekTo is called when video is paused

    _this.seeked = false;

    _this.drawImage = function () {
      if (_this.videoElement && !_this.videoElement.paused && !_this.videoElement.ended) {
        var _this$canvasContext, _this$canvas, _this$canvas2;

        (_this$canvasContext = _this.canvasContext) == null ? void 0 : _this$canvasContext.drawImage(_this.videoElement, 0, 0, (_this$canvas = _this.canvas) == null ? void 0 : _this$canvas.width, (_this$canvas2 = _this.canvas) == null ? void 0 : _this$canvas2.height);
        _this.timer = setTimeout(function () {
          _this.drawImage();
        }, 1000 / _this.DEFAUL_FPS);
      }
    };

    _this.videoElement = _this.getVideoElement();
    _this.canvas = document.createElement('canvas');
    _this.canvasContext = _this.canvas.getContext('2d');
    return _this;
  }

  var _proto = PlaylistVideoManager.prototype;

  _proto.play = function play(url) {
    var _this2 = this;

    return new Promise(function (resolve, reject) {
      _this2.videoElement = _this2.getVideoElement();
      _this2.videoElement.src = url;
      _this2.seeked = false;

      _this2.videoElement.onerror = function () {
        var error = "Error loading " + url;
        HMSLogger.e(_this2.TAG, error);

        _this2.stop();

        reject(error);
      }; // oncanplaythrough is called when enough media is loaded for play to be possible in two cases -
      //    * when play is called for the first time
      //    * when user jumps to any mid track timestamp using seekTo


      _this2.videoElement.oncanplaythrough = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee() {
        var stream, audioTrack, _this2$canvasContext, _this2$canvas, _this2$canvas2;

        return runtime_1.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.prev = 0;

                if (_this2.videoElement) {
                  _context.next = 3;
                  break;
                }

                return _context.abrupt("return");

              case 3:
                _this2.canvas.width = _this2.videoElement.videoWidth;
                _this2.canvas.height = _this2.videoElement.videoHeight; // Capture stream only once and reuse the same tracks. it will be autoupdated with the selected video

                if (!(_this2.tracks.length === 0)) {
                  _context.next = 21;
                  break;
                }

                _this2.clearCanvasAndTracks(); //@ts-ignore


                stream = _this2.canvas.captureStream();

                if (stream) {
                  _context.next = 11;
                  break;
                }

                HMSLogger.e(_this2.TAG, 'Browser does not support captureStream');
                return _context.abrupt("return");

              case 11:
                _this2.videoElement.onplay = _this2.drawImage;

                _this2.audioContextManager.resumeContext();

                _context.next = 15;
                return _this2.videoElement.play();

              case 15:
                audioTrack = _this2.audioContextManager.getAudioTrack();
                stream.addTrack(audioTrack);
                stream.getTracks().forEach(function (track) {
                  _this2.tracks.push(track);
                });
                resolve(_this2.tracks);
                _context.next = 29;
                break;

              case 21:
                if (_this2.seeked) {
                  _context.next = 27;
                  break;
                }

                _context.next = 24;
                return _this2.videoElement.play();

              case 24:
                resolve(_this2.tracks);
                _context.next = 29;
                break;

              case 27:
                // if seek happened, there is no play call/promise to be resolved, just reset seeked
                _this2.seeked = false; // This event will be called on seekTo when paused. Just draw the one frame on canvas.

                (_this2$canvasContext = _this2.canvasContext) == null ? void 0 : _this2$canvasContext.drawImage(_this2.videoElement, 0, 0, (_this2$canvas = _this2.canvas) == null ? void 0 : _this2$canvas.width, (_this2$canvas2 = _this2.canvas) == null ? void 0 : _this2$canvas2.height);

              case 29:
                _context.next = 35;
                break;

              case 31:
                _context.prev = 31;
                _context.t0 = _context["catch"](0);
                HMSLogger.e(_this2.TAG, 'Error playing video', url, _context.t0.message);
                reject(_context.t0);

              case 35:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, null, [[0, 31]]);
      }));

      _this2.videoElement.onseeked = function () {
        _this2.seeked = true;
      };
    });
  };

  _proto.getTracks = function getTracks() {
    return this.tracks.map(function (track) {
      return track.id;
    });
  };

  _proto.getElement = function getElement() {
    return this.videoElement;
  };

  _proto.stop = function stop() {
    var _this$videoElement, _this$videoElement2;

    (_this$videoElement = this.videoElement) == null ? void 0 : _this$videoElement.pause();
    (_this$videoElement2 = this.videoElement) == null ? void 0 : _this$videoElement2.removeAttribute('src');
    this.videoElement = null;
    this.clearCanvasAndTracks();
  };

  _proto.clearCanvasAndTracks = function clearCanvasAndTracks() {
    var _this$canvasContext2;

    this.tracks = []; // clear canvas before playing new video

    (_this$canvasContext2 = this.canvasContext) == null ? void 0 : _this$canvasContext2.clearRect(0, 0, this.canvas.width, this.canvas.height);
    clearTimeout(this.timer);
  };

  _proto.getVideoElement = function getVideoElement() {
    var _this3 = this;

    if (this.videoElement) {
      return this.videoElement;
    }

    var videoElement = document.createElement('video');
    videoElement.crossOrigin = 'anonymous';
    videoElement.addEventListener('timeupdate', function (event) {
      return _this3.emit('progress', event);
    });
    videoElement.addEventListener('ended', function () {
      _this3.emit('ended', null);
    });
    this.audioContextManager = new AudioContextManager(videoElement);
    return videoElement;
  };

  _createClass(PlaylistVideoManager, [{
    key: "TAG",
    get: function get() {
      return 'PlaylistVideoManager';
    }
  }]);

  return PlaylistVideoManager;
}(TypedEventEmitter);

var INITIAL_STATE$1 = {
  audio: {
    list: [],
    currentIndex: -1
  },
  video: {
    list: [],
    currentIndex: -1
  }
};
var PlaylistManager = /*#__PURE__*/function (_TypedEventEmitter) {
  _inheritsLoose(PlaylistManager, _TypedEventEmitter);

  function PlaylistManager(sdk) {
    var _this;

    _this = _TypedEventEmitter.call(this) || this;
    _this.sdk = sdk;
    _this.state = {
      audio: _extends({}, INITIAL_STATE$1.audio),
      video: _extends({}, INITIAL_STATE$1.video)
    };

    _this.addTrack = /*#__PURE__*/function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(track, source) {
        return runtime_1.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return _this.sdk.addTrack(track, source);

              case 2:
                HMSLogger.d(_this.TAG, 'Playlist track added', track);

              case 3:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      return function (_x, _x2) {
        return _ref.apply(this, arguments);
      };
    }();

    _this.removeTrack = /*#__PURE__*/function () {
      var _ref2 = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(trackId) {
        return runtime_1.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return _this.sdk.removeTrack(trackId);

              case 2:
                HMSLogger.d(_this.TAG, 'Playlist track removed', trackId);

              case 3:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }));

      return function (_x3) {
        return _ref2.apply(this, arguments);
      };
    }();

    _this.audioManager = new PlaylistAudioManager();
    _this.videoManager = new PlaylistVideoManager();

    _this.addListeners();

    return _this;
  }

  var _proto = PlaylistManager.prototype;

  _proto.getList = function getList(type) {
    if (type === void 0) {
      type = exports.HMSPlaylistType.audio;
    }

    return this.state[type].list;
  };

  _proto.setList = function setList(list) {
    var _this2 = this;

    if (!list || list.length === 0) {
      HMSLogger.w(this.TAG, "Please pass in a list of HMSPlaylistItem's");
      return;
    }

    list.forEach(function (item) {
      _this2.state[item.type].list.push(item);
    });
  };

  _proto.removeItem = function removeItem(item) {
    var list = this.state[item.type].list;
    var index = list.findIndex(function (playItem) {
      return item.id === playItem.id;
    });

    if (index > -1) {
      list.splice(index, 1);
    }
  };

  _proto.seek = function seek(value, type) {
    if (type === void 0) {
      type = exports.HMSPlaylistType.audio;
    }

    var currentIndex = this.state[type].currentIndex;

    if (currentIndex === -1) {
      throw ErrorFactory.PlaylistErrors.NoEntryToPlay(HMSAction.PLAYLIST, 'No item is currently playing');
    }

    var element = this.getElement(type);

    if (element) {
      var updatedValue = Math.max(element.currentTime + value, 0);
      element.currentTime = Math.min(updatedValue, element.duration);
    }
  };

  _proto.seekTo = function seekTo(value, type) {
    if (type === void 0) {
      type = exports.HMSPlaylistType.audio;
    }

    var currentIndex = this.state[type].currentIndex;

    if (currentIndex === -1) {
      throw ErrorFactory.PlaylistErrors.NoEntryToPlay(HMSAction.PLAYLIST, 'No item is currently playing');
    }

    if (value < 0) {
      throw Error('value cannot be negative');
    }

    var element = this.getElement(type);

    if (element) {
      element.currentTime = Math.min(value, element.duration);
    }
  };

  _proto.setVolume = function setVolume(value, type) {
    if (type === void 0) {
      type = exports.HMSPlaylistType.audio;
    }

    if (value < 0 || value > 100) {
      throw Error('Please pass a valid number between 0-100');
    }

    var element = this.getElement(type);

    if (element) {
      element.volume = value * 0.01;
    } else {
      HMSLogger.w(this.TAG, "No valid element of type " + type + " found");
    }
  };

  _proto.getVolume = function getVolume(type) {
    if (type === void 0) {
      type = exports.HMSPlaylistType.audio;
    }

    var element = this.getElement(type);

    if (element) {
      return element.volume * 100;
    } else {
      HMSLogger.w(this.TAG, "No valid element of type " + type + " found");
    }

    return 0;
  };

  _proto.getCurrentTime = function getCurrentTime(type) {
    if (type === void 0) {
      type = exports.HMSPlaylistType.audio;
    }

    var element = this.getElement(type);
    return (element == null ? void 0 : element.currentTime) || 0;
  };

  _proto.getCurrentIndex = function getCurrentIndex(type) {
    if (type === void 0) {
      type = exports.HMSPlaylistType.audio;
    }

    return this.state[type].currentIndex;
  };

  _proto.getCurrentProgress = function getCurrentProgress(type) {
    var _list$currentIndex;

    if (type === void 0) {
      type = exports.HMSPlaylistType.audio;
    }

    var _this$state$type = this.state[type],
        list = _this$state$type.list,
        currentIndex = _this$state$type.currentIndex;
    var activeUrl = (_list$currentIndex = list[currentIndex]) == null ? void 0 : _list$currentIndex.url;
    var element = this.getElement(type);

    if (!activeUrl || !element) {
      return 0;
    }

    return Math.floor(100 * (element.currentTime / element.duration));
  };

  _proto.getCurrentSelection = function getCurrentSelection(type) {
    if (type === void 0) {
      type = exports.HMSPlaylistType.audio;
    }

    var _this$state$type2 = this.state[type],
        list = _this$state$type2.list,
        currentIndex = _this$state$type2.currentIndex;

    if (currentIndex === -1) {
      return undefined;
    }

    return list[currentIndex];
  };

  _proto.isPlaying = function isPlaying(type) {
    if (type === void 0) {
      type = exports.HMSPlaylistType.audio;
    }

    var element = this.getElement(type);
    return !!element && !element.paused;
  };

  _proto.setEnabled = /*#__PURE__*/function () {
    var _setEnabled = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3(enabled, _ref3) {
      var id, _ref3$type, type, list, currentIndex, url;

      return runtime_1.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              id = _ref3.id, _ref3$type = _ref3.type, type = _ref3$type === void 0 ? exports.HMSPlaylistType.audio : _ref3$type;
              list = this.state[type].list;
              currentIndex = list.findIndex(function (item) {
                return item.id === id;
              });

              if (!(!id || currentIndex === -1)) {
                _context3.next = 6;
                break;
              }

              HMSLogger.w(this.TAG, 'Pass a valid id');
              return _context3.abrupt("return");

            case 6:
              url = this.state[type].list[currentIndex].url;

              if (!enabled) {
                _context3.next = 12;
                break;
              }

              _context3.next = 10;
              return this.play(url, type);

            case 10:
              _context3.next = 14;
              break;

            case 12:
              _context3.next = 14;
              return this.pause(url, type);

            case 14:
              this.state[type].currentIndex = currentIndex;
              this.setDuration(type);

            case 16:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, this);
    }));

    function setEnabled(_x4, _x5) {
      return _setEnabled.apply(this, arguments);
    }

    return setEnabled;
  }();

  _proto.playNext = /*#__PURE__*/function () {
    var _playNext = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4(type) {
      var _this$state$type3, list, currentIndex;

      return runtime_1.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              if (type === void 0) {
                type = exports.HMSPlaylistType.audio;
              }

              _this$state$type3 = this.state[type], list = _this$state$type3.list, currentIndex = _this$state$type3.currentIndex;

              if (!(currentIndex >= list.length - 1)) {
                _context4.next = 4;
                break;
              }

              throw ErrorFactory.PlaylistErrors.NoEntryToPlay(HMSAction.PLAYLIST, 'Reached end of playlist');

            case 4:
              _context4.next = 6;
              return this.play(list[currentIndex + 1].url, type);

            case 6:
              this.state[type].currentIndex = currentIndex + 1;
              this.setDuration(type);

            case 8:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4, this);
    }));

    function playNext(_x6) {
      return _playNext.apply(this, arguments);
    }

    return playNext;
  }();

  _proto.playPrevious = /*#__PURE__*/function () {
    var _playPrevious = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee5(type) {
      var _this$state$type4, list, currentIndex;

      return runtime_1.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              if (type === void 0) {
                type = exports.HMSPlaylistType.audio;
              }

              _this$state$type4 = this.state[type], list = _this$state$type4.list, currentIndex = _this$state$type4.currentIndex;

              if (!(currentIndex <= 0)) {
                _context5.next = 4;
                break;
              }

              throw ErrorFactory.PlaylistErrors.NoEntryToPlay(HMSAction.PLAYLIST, 'Reached start of playlist');

            case 4:
              _context5.next = 6;
              return this.play(list[currentIndex - 1].url, type);

            case 6:
              this.state[type].currentIndex = currentIndex - 1;
              this.setDuration(type);

            case 8:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5, this);
    }));

    function playPrevious(_x7) {
      return _playPrevious.apply(this, arguments);
    }

    return playPrevious;
  }();

  _proto.stop = /*#__PURE__*/function () {
    var _stop = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee6(type) {
      var manager;
      return runtime_1.wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              if (type === void 0) {
                type = exports.HMSPlaylistType.audio;
              }

              manager = type === exports.HMSPlaylistType.audio ? this.audioManager : this.videoManager;
              _context6.next = 4;
              return this.removeTracks(type);

            case 4:
              manager.stop();
              this.state[type].currentIndex = -1;

            case 6:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6, this);
    }));

    function stop(_x8) {
      return _stop.apply(this, arguments);
    }

    return stop;
  }();

  _proto.cleanup = function cleanup() {
    this.state = {
      audio: _extends({}, INITIAL_STATE$1.audio),
      video: _extends({}, INITIAL_STATE$1.video)
    };
    this.audioManager.stop();
    this.videoManager.stop();
  };

  _proto.onProgress = function onProgress(fn) {
    var _this3 = this;

    this.videoManager.on('progress', function () {
      try {
        fn({
          type: exports.HMSPlaylistType.video,
          progress: _this3.getCurrentProgress(exports.HMSPlaylistType.video)
        });
      } catch (error) {
        HMSLogger.e(_this3.TAG, 'Error in onProgress callback');
      }
    });
    this.audioManager.on('progress', function () {
      try {
        fn({
          type: exports.HMSPlaylistType.audio,
          progress: _this3.getCurrentProgress(exports.HMSPlaylistType.audio)
        });
      } catch (error) {
        HMSLogger.e(_this3.TAG, 'Error in onProgress callback');
      }
    });
  };

  _proto.onNewTrackStart = function onNewTrackStart(fn) {
    this.on('newTrackStart', fn);
  };

  _proto.onPlaylistEnded = function onPlaylistEnded(fn) {
    this.on('playlistEnded', fn);
  };

  _proto.getElement = function getElement(type) {
    if (type === void 0) {
      type = exports.HMSPlaylistType.audio;
    }

    return type === exports.HMSPlaylistType.audio ? this.audioManager.getElement() : this.videoManager.getElement();
  };

  _proto.removeTracks = /*#__PURE__*/function () {
    var _removeTracks = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee7(type) {
      var manager, tracks, _iterator, _step, trackId;

      return runtime_1.wrap(function _callee7$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              if (type === void 0) {
                type = exports.HMSPlaylistType.audio;
              }

              manager = type === exports.HMSPlaylistType.audio ? this.audioManager : this.videoManager;
              tracks = manager.getTracks();
              _iterator = _createForOfIteratorHelperLoose(tracks);

            case 4:
              if ((_step = _iterator()).done) {
                _context7.next = 10;
                break;
              }

              trackId = _step.value;
              _context7.next = 8;
              return this.removeTrack(trackId);

            case 8:
              _context7.next = 4;
              break;

            case 10:
            case "end":
              return _context7.stop();
          }
        }
      }, _callee7, this);
    }));

    function removeTracks(_x9) {
      return _removeTracks.apply(this, arguments);
    }

    return removeTracks;
  }();

  _proto.play = /*#__PURE__*/function () {
    var _play = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee8(url, type) {
      var element, tracks, _iterator2, _step2, track;

      return runtime_1.wrap(function _callee8$(_context8) {
        while (1) {
          switch (_context8.prev = _context8.next) {
            case 0:
              if (type === void 0) {
                type = exports.HMSPlaylistType.audio;
              }

              element = this.getElement(type);

              if (!(element && !element.paused && element.src.includes(url))) {
                _context8.next = 5;
                break;
              }

              HMSLogger.w(this.TAG, "The " + type + " is currently playing");
              return _context8.abrupt("return");

            case 5:
              if (!(element && element.src.includes(url))) {
                _context8.next = 10;
                break;
              }

              _context8.next = 8;
              return element.play();

            case 8:
              _context8.next = 27;
              break;

            case 10:
              element == null ? void 0 : element.pause();

              if (!(type === exports.HMSPlaylistType.audio)) {
                _context8.next = 17;
                break;
              }

              _context8.next = 14;
              return this.audioManager.play(url);

            case 14:
              tracks = _context8.sent;
              _context8.next = 20;
              break;

            case 17:
              _context8.next = 19;
              return this.videoManager.play(url);

            case 19:
              tracks = _context8.sent;

            case 20:
              _iterator2 = _createForOfIteratorHelperLoose(tracks);

            case 21:
              if ((_step2 = _iterator2()).done) {
                _context8.next = 27;
                break;
              }

              track = _step2.value;
              _context8.next = 25;
              return this.addTrack(track, type === exports.HMSPlaylistType.audio ? 'audioplaylist' : 'videoplaylist');

            case 25:
              _context8.next = 21;
              break;

            case 27:
            case "end":
              return _context8.stop();
          }
        }
      }, _callee8, this);
    }));

    function play(_x10, _x11) {
      return _play.apply(this, arguments);
    }

    return play;
  }();

  _proto.setDuration = function setDuration(type) {
    if (type === void 0) {
      type = exports.HMSPlaylistType.audio;
    }

    var element = this.getElement(type);
    var _this$state$type5 = this.state[type],
        list = _this$state$type5.list,
        currentIndex = _this$state$type5.currentIndex;

    if (list[currentIndex]) {
      list[currentIndex].duration = (element == null ? void 0 : element.duration) || 0;
    }

    this.emit('newTrackStart', list[currentIndex]);
  };

  _proto.pause = /*#__PURE__*/function () {
    var _pause = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee9(url, type) {
      var el;
      return runtime_1.wrap(function _callee9$(_context9) {
        while (1) {
          switch (_context9.prev = _context9.next) {
            case 0:
              if (type === void 0) {
                type = exports.HMSPlaylistType.audio;
              }

              el = this.getElement(type);

              if (el && !el.paused && el.src.includes(url)) {
                el.pause();
                HMSLogger.d(this.TAG, 'paused url', url);
              } else {
                HMSLogger.w(this.TAG, 'The passed in url is not currently playing');
              }

            case 3:
            case "end":
              return _context9.stop();
          }
        }
      }, _callee9, this);
    }));

    function pause(_x12, _x13) {
      return _pause.apply(this, arguments);
    }

    return pause;
  }();

  _proto.addListeners = function addListeners() {
    var _this4 = this;

    this.audioManager.on('ended', function () {
      return _this4.handleEnded(exports.HMSPlaylistType.audio);
    });
    this.videoManager.on('ended', function () {
      return _this4.handleEnded(exports.HMSPlaylistType.video);
    });
  }
  /**
   * Remove tracks if reached the end of list otherwise play next
   * @param {HMSPlaylistType} type
   */
  ;

  _proto.handleEnded =
  /*#__PURE__*/
  function () {
    var _handleEnded = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee10(type) {
      var _this$state$type6, list, currentIndex;

      return runtime_1.wrap(function _callee10$(_context10) {
        while (1) {
          switch (_context10.prev = _context10.next) {
            case 0:
              if (type === void 0) {
                type = exports.HMSPlaylistType.audio;
              }

              _this$state$type6 = this.state[type], list = _this$state$type6.list, currentIndex = _this$state$type6.currentIndex;

              if (!(currentIndex === list.length - 1)) {
                _context10.next = 8;
                break;
              }

              _context10.next = 5;
              return this.stop(type);

            case 5:
              this.emit('playlistEnded', type);
              _context10.next = 9;
              break;

            case 8:
              this.playNext(type);

            case 9:
            case "end":
              return _context10.stop();
          }
        }
      }, _callee10, this);
    }));

    function handleEnded(_x14) {
      return _handleEnded.apply(this, arguments);
    }

    return handleEnded;
  }();

  _createClass(PlaylistManager, [{
    key: "TAG",
    get: function get() {
      return 'PlaylistManager';
    }
  }]);

  return PlaylistManager;
}(TypedEventEmitter);

var defaultSettings$1 = {
  isAudioMuted: false,
  isVideoMuted: false,
  audioInputDeviceId: 'default',
  audioOutputDeviceId: 'default',
  videoDeviceId: 'default'
};
var INITIAL_STATE$2 = {
  published: false,
  isInitialised: false,
  isReconnecting: false,
  isPreviewInProgress: false,
  deviceManagersInitialised: false
};
var HMSSdk = /*#__PURE__*/function () {
  function HMSSdk() {
    var _this = this;

    this.TAG = '[HMSSdk]:';
    this.transportState = TransportState.Disconnected;
    this.sdkState = _extends({}, INITIAL_STATE$2);

    this.handleAutoplayError = function (event) {
      var _this$errorListener;

      (_this$errorListener = _this.errorListener) == null ? void 0 : _this$errorListener.onError == null ? void 0 : _this$errorListener.onError(event.error);
    };

    this.observer = {
      onNotification: function onNotification(message) {
        if (message.method === HMSNotificationMethod.PEER_LEAVE_REQUEST) {
          _this.handlePeerLeaveRequest(message.params);

          return;
        }

        _this.notificationManager.handleNotification(message, _this.sdkState.isReconnecting);
      },
      onTrackAdd: function onTrackAdd(track) {
        _this.notificationManager.handleTrackAdd(track);
      },
      onTrackRemove: function onTrackRemove(track) {
        _this.notificationManager.handleTrackRemove(track);
      },
      onTrackDegrade: function onTrackDegrade(track) {
        var _this$listener, _this$store;

        HMSLogger.d(_this.TAG, 'Sending Track Update Track Degraded', track);
        (_this$listener = _this.listener) == null ? void 0 : _this$listener.onTrackUpdate(exports.HMSTrackUpdate.TRACK_DEGRADED, track, (_this$store = _this.store) == null ? void 0 : _this$store.getPeerByTrackId(track.trackId));
      },
      onTrackRestore: function onTrackRestore(track) {
        var _this$listener2, _this$store2;

        HMSLogger.d(_this.TAG, 'Sending Track Update Track Restored', track);
        (_this$listener2 = _this.listener) == null ? void 0 : _this$listener2.onTrackUpdate(exports.HMSTrackUpdate.TRACK_RESTORED, track, (_this$store2 = _this.store) == null ? void 0 : _this$store2.getPeerByTrackId(track.trackId));
      },
      onFailure: function onFailure(exception) {
        var _this$errorListener2;

        (_this$errorListener2 = _this.errorListener) == null ? void 0 : _this$errorListener2.onError(exception);
      },
      onStateChange: function () {
        var _onStateChange = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(state, error) {
          var _this$errorListener3, _this$listener4;

          var _this$listener3;

          return runtime_1.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _context.t0 = state;
                  _context.next = _context.t0 === TransportState.Joined ? 3 : _context.t0 === TransportState.Failed ? 5 : _context.t0 === TransportState.Reconnecting ? 10 : 13;
                  break;

                case 3:
                  if (_this.transportState === TransportState.Reconnecting) {
                    (_this$listener3 = _this.listener) == null ? void 0 : _this$listener3.onReconnected();
                  }

                  return _context.abrupt("break", 13);

                case 5:
                  _context.next = 7;
                  return _this.leave();

                case 7:
                  (_this$errorListener3 = _this.errorListener) == null ? void 0 : _this$errorListener3.onError == null ? void 0 : _this$errorListener3.onError(error);
                  _this.sdkState.isReconnecting = false;
                  return _context.abrupt("break", 13);

                case 10:
                  _this.sdkState.isReconnecting = true;
                  (_this$listener4 = _this.listener) == null ? void 0 : _this$listener4.onReconnecting(error);
                  return _context.abrupt("break", 13);

                case 13:
                  _this.transportState = state;

                case 14:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }));

        function onStateChange(_x, _x2) {
          return _onStateChange.apply(this, arguments);
        }

        return onStateChange;
      }()
    };

    this.handlePeerLeaveRequest = function (message) {
      var _this$listener5;

      var peer = _this.store.getPeerById(message.requested_by);

      var request = {
        roomEnded: message.room_end,
        reason: message.reason,
        requestedBy: peer
      };
      (_this$listener5 = _this.listener) == null ? void 0 : _this$listener5.onRemovedFromRoom(request);

      _this.leave();
    };

    this.handleDeviceChangeError = function (event) {
      var _this$deviceChangeLis;

      HMSLogger.d(_this.TAG, 'Device Change event', event);
      (_this$deviceChangeLis = _this.deviceChangeListener) == null ? void 0 : _this$deviceChangeLis.onDeviceChange == null ? void 0 : _this$deviceChangeLis.onDeviceChange(event);

      if (event.error && event.type) {
        var _this$localPeer, _this$localPeer2, _this$errorListener4;

        var track = event.type.includes('audio') ? (_this$localPeer = _this.localPeer) == null ? void 0 : _this$localPeer.audioTrack : (_this$localPeer2 = _this.localPeer) == null ? void 0 : _this$localPeer2.videoTrack;
        (_this$errorListener4 = _this.errorListener) == null ? void 0 : _this$errorListener4.onError(event.error);

        if ([ErrorCodes.TracksErrors.CANT_ACCESS_CAPTURE_DEVICE, ErrorCodes.TracksErrors.DEVICE_IN_USE, ErrorCodes.TracksErrors.DEVICE_NOT_AVAILABLE].includes(event.error.code) && track) {
          var _this$listener6;

          track.setEnabled(false);
          (_this$listener6 = _this.listener) == null ? void 0 : _this$listener6.onTrackUpdate(exports.HMSTrackUpdate.TRACK_MUTED, track, _this.localPeer);
        }
      }
    };
  }

  var _proto = HMSSdk.prototype;

  _proto.initStoreAndManagers = function initStoreAndManagers() {
    if (this.sdkState.isInitialised) {
      /**
       * Set listener after both join and preview, since they can have different listeners
       */
      this.notificationManager.setListener(this.listener);
      this.audioSinkManager.setListener(this.listener);
      return;
    }

    this.sdkState.isInitialised = true;
    this.store = new Store();
    this.playlistManager = new PlaylistManager(this);
    this.notificationManager = new NotificationManager(this.store, this.listener, this.audioListener);
    this.deviceManager = new DeviceManager(this.store);
    this.audioSinkManager = new AudioSinkManager(this.store, this.notificationManager, this.deviceManager);
    this.audioOutput = new AudioOutputManager(this.deviceManager, this.audioSinkManager);
    this.audioSinkManager.addEventListener(AutoplayError, this.handleAutoplayError);
    this.transport = new HMSTransport(this.observer, this.deviceManager, this.store);
    this.localTrackManager = new LocalTrackManager(this.store, this.observer, this.deviceManager);
  };

  _proto.getPlaylistManager = function getPlaylistManager() {
    return this.playlistManager;
  };

  _proto.getRecordingState = function getRecordingState() {
    var _this$store$getRoom;

    return (_this$store$getRoom = this.store.getRoom()) == null ? void 0 : _this$store$getRoom.recording;
  };

  _proto.getRTMPState = function getRTMPState() {
    var _this$store$getRoom2;

    return (_this$store$getRoom2 = this.store.getRoom()) == null ? void 0 : _this$store$getRoom2.rtmp;
  };

  _proto.preview = /*#__PURE__*/function () {
    var _preview = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3(config, listener) {
      var _this2 = this;

      var _decodeJWT, roomId, userId, role, policy, localPeer, policyHandler, _this$errorListener5;

      return runtime_1.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              if (!this.sdkState.isPreviewInProgress) {
                _context3.next = 2;
                break;
              }

              return _context3.abrupt("return");

            case 2:
              this.sdkState.isPreviewInProgress = true;
              _decodeJWT = decodeJWT(config.authToken), roomId = _decodeJWT.roomId, userId = _decodeJWT.userId, role = _decodeJWT.role;
              this.errorListener = listener;
              this.deviceChangeListener = listener;
              this.initStoreAndManagers();
              this.store.setErrorListener(this.errorListener);
              this.store.setConfig(config);
              this.store.setRoom(new Room(roomId, config.userName, this.store));
              policy = this.store.getPolicyForRole(role);
              localPeer = new HMSLocalPeer({
                name: config.userName || '',
                customerUserId: userId,
                customerDescription: config.metaData,
                role: policy
              });
              this.store.addPeer(localPeer);
              HMSLogger.d(this.TAG, 'SDK Store', this.store);

              policyHandler = /*#__PURE__*/function () {
                var _ref = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2() {
                  var _this2$localPeer;

                  var tracks;
                  return runtime_1.wrap(function _callee2$(_context2) {
                    while (1) {
                      switch (_context2.prev = _context2.next) {
                        case 0:
                          _this2.notificationManager.removeEventListener('policy-change', policyHandler);

                          _context2.next = 3;
                          return _this2.localTrackManager.getTracksToPublish(config.settings || defaultSettings$1);

                        case 3:
                          tracks = _context2.sent;
                          tracks.forEach(function (track) {
                            return _this2.setLocalPeerTrack(track);
                          });
                          ((_this2$localPeer = _this2.localPeer) == null ? void 0 : _this2$localPeer.audioTrack) && _this2.initPreviewTrackAudioLevelMonitor();
                          _context2.next = 8;
                          return _this2.initDeviceManagers();

                        case 8:
                          listener.onPreview(_this2.store.getRoom(), tracks);
                          _this2.sdkState.isPreviewInProgress = false;

                        case 10:
                        case "end":
                          return _context2.stop();
                      }
                    }
                  }, _callee2);
                }));

                return function policyHandler() {
                  return _ref.apply(this, arguments);
                };
              }();

              this.notificationManager.addEventListener('policy-change', policyHandler);
              _context3.prev = 16;
              _context3.next = 19;
              return this.transport.connect(config.authToken, config.initEndpoint || 'https://prod-init.100ms.live/init', this.localPeer.peerId);

            case 19:
              _context3.next = 25;
              break;

            case 21:
              _context3.prev = 21;
              _context3.t0 = _context3["catch"](16);
              (_this$errorListener5 = this.errorListener) == null ? void 0 : _this$errorListener5.onError(_context3.t0);
              this.sdkState.isPreviewInProgress = false;

            case 25:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, this, [[16, 21]]);
    }));

    function preview(_x3, _x4) {
      return _preview.apply(this, arguments);
    }

    return preview;
  }();

  _proto.join = function join(config, listener) {
    var _this$localPeer3,
        _this$localPeer3$audi,
        _this3 = this;

    if (this.sdkState.isPreviewInProgress) {
      throw ErrorFactory.GenericErrors.NotReady(HMSAction.JOIN, "Preview is in progress, can't join");
    }

    (_this$localPeer3 = this.localPeer) == null ? void 0 : (_this$localPeer3$audi = _this$localPeer3.audioTrack) == null ? void 0 : _this$localPeer3$audi.destroyAudioLevelMonitor();
    this.listener = listener;
    this.errorListener = listener;
    this.deviceChangeListener = listener;
    this.initStoreAndManagers();
    var storedConfig = this.store.getConfig();

    if (storedConfig && config.settings) {
      // preview was called
      delete config.settings.audioOutputDeviceId;
      delete config.settings.videoDeviceId;
      delete config.settings.audioInputDeviceId;
    }

    this.store.setErrorListener(this.errorListener);
    this.store.setConfig(config);

    var _decodeJWT2 = decodeJWT(config.authToken),
        roomId = _decodeJWT2.roomId,
        userId = _decodeJWT2.userId,
        role = _decodeJWT2.role;

    if (!this.localPeer) {
      this.notificationManager.addEventListener('role-change', function (e) {
        _this3.store.setPublishParams(e.detail.params.role.publishParams);
      });
      var localPeer = new HMSLocalPeer({
        name: config.userName,
        customerUserId: userId,
        customerDescription: config.metaData || '',
        role: this.store.getPolicyForRole(role)
      });
      this.store.addPeer(localPeer);
    } else {
      this.localPeer.name = config.userName;
      this.localPeer.role = this.store.getPolicyForRole(role);
      this.localPeer.customerUserId = userId;
      this.localPeer.customerDescription = config.metaData || '';
    }

    this.roleChangeManager = new RoleChangeManager(this.store, this.transport, this.publish.bind(this), this.removeTrack.bind(this), this.listener);
    this.notificationManager.addEventListener('local-peer-role-update', this.roleChangeManager.handleLocalPeerRoleUpdate);
    HMSLogger.d(this.TAG, 'SDK Store', this.store);
    HMSLogger.d(this.TAG, "\u23F3 Joining room " + roomId);

    if (!this.store.getRoom()) {
      // note: store room is used to handle server notifications in join and has to be done before join process starts
      this.store.setRoom(new Room(roomId, config.userName, this.store));
    }

    HMSLogger.time("join-room-" + roomId);
    this.transport.join(config.authToken, this.localPeer.peerId, {
      name: config.userName,
      metaData: config.metaData || ''
    }, config.initEndpoint, config.autoVideoSubscribe).then( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4() {
      var _window$HMS, _window$HMS2;

      return runtime_1.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              HMSLogger.d(_this3.TAG, "\u2705 Joined room " + roomId); // if delay fix is set, call onJoin before publishing
              //@ts-ignore

              if ((_window$HMS = window.HMS) != null && _window$HMS.JOIN_DELAY_FIX) {
                _this3.notifyJoin();
              }

              if (!(_this3.publishParams && !_this3.sdkState.published && !isNode)) {
                _context4.next = 5;
                break;
              }

              _context4.next = 5;
              return _this3.publish(config.settings || defaultSettings$1);

            case 5:
              //@ts-ignore
              if (!((_window$HMS2 = window.HMS) != null && _window$HMS2.JOIN_DELAY_FIX)) {
                _this3.notifyJoin();
              }

            case 6:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    })))["catch"](function (error) {
      var _this3$listener;

      (_this3$listener = _this3.listener) == null ? void 0 : _this3$listener.onError(error);
      HMSLogger.e(_this3.TAG, 'Unable to join room', error);
    }).then(function () {
      HMSLogger.timeEnd("join-room-" + roomId);
    });
  };

  _proto.cleanUp = function cleanUp() {
    this.store.cleanUp();
    this.cleanDeviceManagers();
    DeviceStorageManager.cleanup();
    this.playlistManager.cleanup();
    HMSLogger.cleanUp();
    this.sdkState = _extends({}, INITIAL_STATE$2);
    /**
     * when leave is called after preview itself without join.
     * Store won't have the tracks in this case
     */

    if (this.localPeer) {
      var _this$localPeer$audio, _this$localPeer$video;

      (_this$localPeer$audio = this.localPeer.audioTrack) == null ? void 0 : _this$localPeer$audio.cleanup();
      this.localPeer.audioTrack = undefined;
      (_this$localPeer$video = this.localPeer.videoTrack) == null ? void 0 : _this$localPeer$video.cleanup();
      this.localPeer.videoTrack = undefined;
    }

    this.listener = undefined;

    if (this.roleChangeManager) {
      this.notificationManager.removeEventListener('local-peer-role-update', this.roleChangeManager.handleLocalPeerRoleUpdate);
    }
  };

  _proto.leave = /*#__PURE__*/function () {
    var _leave = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee5() {
      var room, _this$transport, roomId;

      return runtime_1.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              room = this.store.getRoom();

              if (!room) {
                _context5.next = 8;
                break;
              }

              roomId = room.id;
              HMSLogger.d(this.TAG, "\u23F3 Leaving room " + roomId); // browsers often put limitation on amount of time a function set on window onBeforeUnload can take in case of
              // tab refresh or close. Therefore prioritise the leave action over anything else, if tab is closed/refreshed
              // we would want leave to succeed to stop stucked peer for others. The followup cleanup however is important
              // for cases where uses stays on the page post leave.

              _context5.next = 6;
              return (_this$transport = this.transport) == null ? void 0 : _this$transport.leave();

            case 6:
              this.cleanUp();
              HMSLogger.d(this.TAG, "\u2705 Left room " + roomId);

            case 8:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5, this);
    }));

    function leave() {
      return _leave.apply(this, arguments);
    }

    return leave;
  }();

  _proto.getLocalPeer = function getLocalPeer() {
    return this.store.getLocalPeer();
  };

  _proto.getPeers = function getPeers() {
    var peers = this.store.getPeers();
    HMSLogger.d(this.TAG, "Got peers", peers);
    return peers;
  };

  _proto.getAudioOutput = function getAudioOutput() {
    return this.audioOutput;
  };

  _proto.sendMessage = function sendMessage(type, message) {
    this.sendMessageInternal({
      message: message,
      type: type
    });
  };

  _proto.sendBroadcastMessage = /*#__PURE__*/function () {
    var _sendBroadcastMessage = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee6(message, type) {
      return runtime_1.wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              _context6.next = 2;
              return this.sendMessageInternal({
                message: message,
                type: type
              });

            case 2:
              return _context6.abrupt("return", _context6.sent);

            case 3:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6, this);
    }));

    function sendBroadcastMessage(_x5, _x6) {
      return _sendBroadcastMessage.apply(this, arguments);
    }

    return sendBroadcastMessage;
  }();

  _proto.sendGroupMessage = /*#__PURE__*/function () {
    var _sendGroupMessage = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee7(message, roles, type) {
      var knownRoles, recipientRoles;
      return runtime_1.wrap(function _callee7$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              knownRoles = this.store.getKnownRoles();
              recipientRoles = roles.filter(function (role) {
                return knownRoles[role.name];
              }) || [];

              if (!(recipientRoles.length === 0)) {
                _context7.next = 4;
                break;
              }

              throw ErrorFactory.GenericErrors.ValidationFailed('No valid role is present', roles);

            case 4:
              _context7.next = 6;
              return this.sendMessageInternal({
                message: message,
                recipientRoles: roles,
                type: type
              });

            case 6:
              return _context7.abrupt("return", _context7.sent);

            case 7:
            case "end":
              return _context7.stop();
          }
        }
      }, _callee7, this);
    }));

    function sendGroupMessage(_x7, _x8, _x9) {
      return _sendGroupMessage.apply(this, arguments);
    }

    return sendGroupMessage;
  }();

  _proto.sendDirectMessage = /*#__PURE__*/function () {
    var _sendDirectMessage = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee8(message, peer, type) {
      var _this$localPeer4;

      var recipientPeer;
      return runtime_1.wrap(function _callee8$(_context8) {
        while (1) {
          switch (_context8.prev = _context8.next) {
            case 0:
              recipientPeer = this.store.getPeerById(peer.peerId);

              if (recipientPeer) {
                _context8.next = 3;
                break;
              }

              throw ErrorFactory.GenericErrors.ValidationFailed('Invalid peer - peer not present in the room', peer);

            case 3:
              if (!(((_this$localPeer4 = this.localPeer) == null ? void 0 : _this$localPeer4.peerId) === peer.peerId)) {
                _context8.next = 5;
                break;
              }

              throw ErrorFactory.GenericErrors.ValidationFailed('Cannot send message to self');

            case 5:
              _context8.next = 7;
              return this.sendMessageInternal({
                message: message,
                recipientPeer: peer,
                type: type
              });

            case 7:
              return _context8.abrupt("return", _context8.sent);

            case 8:
            case "end":
              return _context8.stop();
          }
        }
      }, _callee8, this);
    }));

    function sendDirectMessage(_x10, _x11, _x12) {
      return _sendDirectMessage.apply(this, arguments);
    }

    return sendDirectMessage;
  }();

  _proto.sendMessageInternal = /*#__PURE__*/function () {
    var _sendMessageInternal = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee9(_ref3) {
      var recipientRoles, recipientPeer, _ref3$type, type, message, hmsMessage;

      return runtime_1.wrap(function _callee9$(_context9) {
        while (1) {
          switch (_context9.prev = _context9.next) {
            case 0:
              recipientRoles = _ref3.recipientRoles, recipientPeer = _ref3.recipientPeer, _ref3$type = _ref3.type, type = _ref3$type === void 0 ? 'chat' : _ref3$type, message = _ref3.message;

              if (!(message.replace(/\u200b/g, ' ').trim() === '')) {
                _context9.next = 4;
                break;
              }

              HMSLogger.w(this.TAG, 'sendMessage', 'Ignoring empty message send');
              throw ErrorFactory.GenericErrors.ValidationFailed('Empty message not allowed');

            case 4:
              hmsMessage = new Message({
                sender: this.localPeer,
                type: type,
                message: message,
                recipientPeer: recipientPeer,
                recipientRoles: recipientRoles,
                time: new Date()
              });
              HMSLogger.d(this.TAG, 'Sending Message:: ', hmsMessage);
              _context9.next = 8;
              return this.transport.sendMessage(hmsMessage);

            case 8:
              return _context9.abrupt("return", hmsMessage);

            case 9:
            case "end":
              return _context9.stop();
          }
        }
      }, _callee9, this);
    }));

    function sendMessageInternal(_x13) {
      return _sendMessageInternal.apply(this, arguments);
    }

    return sendMessageInternal;
  }();

  _proto.startScreenShare = /*#__PURE__*/function () {
    var _startScreenShare = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee10(onStop, audioOnly) {
      var _this$localPeer6,
          _this$localPeer6$auxi,
          _this4 = this;

      var publishParams, screen, allowed, canPublishScreen, _this$localPeer5, dimensions, _yield$this$transport, videoTrack, audioTrack, handleEnded, tracks;

      return runtime_1.wrap(function _callee10$(_context10) {
        while (1) {
          switch (_context10.prev = _context10.next) {
            case 0:
              if (audioOnly === void 0) {
                audioOnly = false;
              }

              publishParams = this.publishParams;

              if (publishParams) {
                _context10.next = 4;
                break;
              }

              return _context10.abrupt("return");

            case 4:
              screen = publishParams.screen, allowed = publishParams.allowed;
              canPublishScreen = allowed && allowed.includes('screen');

              if (canPublishScreen) {
                _context10.next = 9;
                break;
              }

              HMSLogger.e(this.TAG, "Role " + ((_this$localPeer5 = this.localPeer) == null ? void 0 : _this$localPeer5.role) + " cannot share screen");
              return _context10.abrupt("return");

            case 9:
              if (!((_this$localPeer6 = this.localPeer) != null && (_this$localPeer6$auxi = _this$localPeer6.auxiliaryTracks) != null && _this$localPeer6$auxi.find(function (track) {
                return track.source === 'screen';
              }))) {
                _context10.next = 11;
                break;
              }

              throw Error('Cannot share multiple screens');

            case 11:
              dimensions = this.store.getSimulcastDimensions('screen');
              _context10.next = 14;
              return this.transport.getLocalScreen(new HMSVideoTrackSettingsBuilder() // Don't cap maxBitrate for screenshare.
              // If publish params doesn't have bitRate value - don't set maxBitrate.
              .maxBitrate(screen.bitRate, false).codec(screen.codec).maxFramerate(screen.frameRate).setWidth((dimensions == null ? void 0 : dimensions.width) || screen.width).setHeight((dimensions == null ? void 0 : dimensions.height) || screen.height).build(), new HMSAudioTrackSettingsBuilder().build());

            case 14:
              _yield$this$transport = _context10.sent;
              videoTrack = _yield$this$transport[0];
              audioTrack = _yield$this$transport[1];

              handleEnded = function handleEnded() {
                _this4.stopEndedScreenshare(onStop);
              };

              tracks = [];

              if (!audioOnly) {
                _context10.next = 27;
                break;
              }

              videoTrack.nativeTrack.stop();

              if (audioTrack) {
                _context10.next = 23;
                break;
              }

              throw Error('Select share audio when sharing screen');

            case 23:
              tracks.push(audioTrack);
              audioTrack.nativeTrack.onended = handleEnded;
              _context10.next = 30;
              break;

            case 27:
              tracks.push(videoTrack);
              videoTrack.nativeTrack.onended = handleEnded; // audio track is not always available

              if (audioTrack) {
                tracks.push(audioTrack);
              }

            case 30:
              _context10.next = 32;
              return this.transport.publish(tracks);

            case 32:
              tracks.forEach(function (track) {
                var _this4$localPeer, _this4$localPeer2, _this4$listener;

                track.peerId = (_this4$localPeer = _this4.localPeer) == null ? void 0 : _this4$localPeer.peerId;
                (_this4$localPeer2 = _this4.localPeer) == null ? void 0 : _this4$localPeer2.auxiliaryTracks.push(track);
                (_this4$listener = _this4.listener) == null ? void 0 : _this4$listener.onTrackUpdate(exports.HMSTrackUpdate.TRACK_ADDED, track, _this4.localPeer);
              });

            case 33:
            case "end":
              return _context10.stop();
          }
        }
      }, _callee10, this);
    }));

    function startScreenShare(_x14, _x15) {
      return _startScreenShare.apply(this, arguments);
    }

    return startScreenShare;
  }();

  _proto.stopEndedScreenshare = /*#__PURE__*/function () {
    var _stopEndedScreenshare = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee11(onStop) {
      return runtime_1.wrap(function _callee11$(_context11) {
        while (1) {
          switch (_context11.prev = _context11.next) {
            case 0:
              HMSLogger.d(this.TAG, "\u2705 Screenshare ended natively");
              _context11.next = 3;
              return this.stopScreenShare();

            case 3:
              onStop();

            case 4:
            case "end":
              return _context11.stop();
          }
        }
      }, _callee11, this);
    }));

    function stopEndedScreenshare(_x16) {
      return _stopEndedScreenshare.apply(this, arguments);
    }

    return stopEndedScreenshare;
  }();

  _proto.stopScreenShare = /*#__PURE__*/function () {
    var _stopScreenShare = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee12() {
      var _this$localPeer7;

      var screenTracks, _iterator, _step, track;

      return runtime_1.wrap(function _callee12$(_context12) {
        while (1) {
          switch (_context12.prev = _context12.next) {
            case 0:
              HMSLogger.d(this.TAG, "\u2705 Screenshare ended from app");
              screenTracks = (_this$localPeer7 = this.localPeer) == null ? void 0 : _this$localPeer7.auxiliaryTracks.filter(function (t) {
                return t.source === 'screen';
              });

              if (!screenTracks) {
                _context12.next = 10;
                break;
              }

              _iterator = _createForOfIteratorHelperLoose(screenTracks);

            case 4:
              if ((_step = _iterator()).done) {
                _context12.next = 10;
                break;
              }

              track = _step.value;
              _context12.next = 8;
              return this.removeTrack(track.trackId);

            case 8:
              _context12.next = 4;
              break;

            case 10:
            case "end":
              return _context12.stop();
          }
        }
      }, _callee12, this);
    }));

    function stopScreenShare() {
      return _stopScreenShare.apply(this, arguments);
    }

    return stopScreenShare;
  }();

  _proto.addTrack = /*#__PURE__*/function () {
    var _addTrack = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee13(track, source) {
      var _this$transport2, _this$localPeer8, _this$localPeer9, _this$listener7;

      var isTrackPresent, type, nativeStream, stream, TrackKlass, hmsTrack, settings, _track$getSettings, width, height;

      return runtime_1.wrap(function _callee13$(_context13) {
        while (1) {
          switch (_context13.prev = _context13.next) {
            case 0:
              if (source === void 0) {
                source = 'regular';
              }

              if (track) {
                _context13.next = 4;
                break;
              }

              HMSLogger.w(this.TAG, 'Please pass a valid MediaStreamTrack');
              return _context13.abrupt("return");

            case 4:
              if (this.localPeer) {
                _context13.next = 6;
                break;
              }

              throw ErrorFactory.GenericErrors.NotConnected(HMSAction.VALIDATION, 'No local peer present, cannot addTrack');

            case 6:
              isTrackPresent = this.localPeer.auxiliaryTracks.find(function (t) {
                return t.trackId === track.id;
              });

              if (!isTrackPresent) {
                _context13.next = 9;
                break;
              }

              return _context13.abrupt("return");

            case 9:
              type = track.kind;
              nativeStream = new MediaStream([track]);
              stream = new HMSLocalStream(nativeStream);
              TrackKlass = type === 'audio' ? HMSLocalAudioTrack : HMSLocalVideoTrack;
              hmsTrack = new TrackKlass(stream, track, source);

              if (!(source === 'videoplaylist')) {
                _context13.next = 21;
                break;
              }

              settings = {};

              if (type === 'audio') {
                settings.maxBitrate = 64;
              } else {
                settings.maxBitrate = 1000;
                _track$getSettings = track.getSettings(), width = _track$getSettings.width, height = _track$getSettings.height;
                settings.width = width;
                settings.height = height;
              } // TODO: rt update from policy once policy is updated


              _context13.next = 19;
              return hmsTrack.setSettings(settings);

            case 19:
              _context13.next = 24;
              break;

            case 21:
              if (!(source === 'audioplaylist')) {
                _context13.next = 24;
                break;
              }

              _context13.next = 24;
              return hmsTrack.setSettings({
                maxBitrate: 64
              });

            case 24:
              _context13.next = 26;
              return (_this$transport2 = this.transport) == null ? void 0 : _this$transport2.publish([hmsTrack]);

            case 26:
              hmsTrack.peerId = (_this$localPeer8 = this.localPeer) == null ? void 0 : _this$localPeer8.peerId;
              (_this$localPeer9 = this.localPeer) == null ? void 0 : _this$localPeer9.auxiliaryTracks.push(hmsTrack);
              (_this$listener7 = this.listener) == null ? void 0 : _this$listener7.onTrackUpdate(exports.HMSTrackUpdate.TRACK_ADDED, hmsTrack, this.localPeer);

            case 29:
            case "end":
              return _context13.stop();
          }
        }
      }, _callee13, this);
    }));

    function addTrack(_x17, _x18) {
      return _addTrack.apply(this, arguments);
    }

    return addTrack;
  }();

  _proto.removeTrack = /*#__PURE__*/function () {
    var _removeTrack = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee14(trackId) {
      var trackIndex, _this$listener8, track;

      return runtime_1.wrap(function _callee14$(_context14) {
        while (1) {
          switch (_context14.prev = _context14.next) {
            case 0:
              if (this.localPeer) {
                _context14.next = 2;
                break;
              }

              throw ErrorFactory.GenericErrors.NotConnected(HMSAction.VALIDATION, 'No local peer present, cannot removeTrack');

            case 2:
              trackIndex = this.localPeer.auxiliaryTracks.findIndex(function (t) {
                return t.trackId === trackId;
              });

              if (!(trackIndex > -1)) {
                _context14.next = 11;
                break;
              }

              track = this.localPeer.auxiliaryTracks[trackIndex];
              _context14.next = 7;
              return this.transport.unpublish([track]);

            case 7:
              this.localPeer.auxiliaryTracks.splice(trackIndex, 1);
              (_this$listener8 = this.listener) == null ? void 0 : _this$listener8.onTrackUpdate(exports.HMSTrackUpdate.TRACK_REMOVED, track, this.localPeer);
              _context14.next = 12;
              break;

            case 11:
              HMSLogger.w(this.TAG, "No track found for " + trackId);

            case 12:
            case "end":
              return _context14.stop();
          }
        }
      }, _callee14, this);
    }));

    function removeTrack(_x19) {
      return _removeTrack.apply(this, arguments);
    }

    return removeTrack;
  }();

  _proto.setAnalyticsLevel = function setAnalyticsLevel(level) {
    analyticsEventsService.level = level;
  };

  _proto.setLogLevel = function setLogLevel(level) {
    HMSLogger.level = level;
  };

  _proto.addAudioListener = function addAudioListener(audioListener) {
    this.audioListener = audioListener;
    this.notificationManager.setAudioListener(audioListener);
  };

  _proto.changeRole = /*#__PURE__*/function () {
    var _changeRole = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee15(forPeer, toRole, force) {
      var _this$transport3;

      return runtime_1.wrap(function _callee15$(_context15) {
        while (1) {
          switch (_context15.prev = _context15.next) {
            case 0:
              if (force === void 0) {
                force = false;
              }

              if (!(!forPeer.role || forPeer.role.name === toRole)) {
                _context15.next = 3;
                break;
              }

              return _context15.abrupt("return");

            case 3:
              _context15.next = 5;
              return (_this$transport3 = this.transport) == null ? void 0 : _this$transport3.changeRole(forPeer, toRole, force);

            case 5:
            case "end":
              return _context15.stop();
          }
        }
      }, _callee15, this);
    }));

    function changeRole(_x20, _x21, _x22) {
      return _changeRole.apply(this, arguments);
    }

    return changeRole;
  }();

  _proto.acceptChangeRole = /*#__PURE__*/function () {
    var _acceptChangeRole = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee16(request) {
      var _this$transport4;

      return runtime_1.wrap(function _callee16$(_context16) {
        while (1) {
          switch (_context16.prev = _context16.next) {
            case 0:
              _context16.next = 2;
              return (_this$transport4 = this.transport) == null ? void 0 : _this$transport4.acceptRoleChange(request);

            case 2:
            case "end":
              return _context16.stop();
          }
        }
      }, _callee16, this);
    }));

    function acceptChangeRole(_x23) {
      return _acceptChangeRole.apply(this, arguments);
    }

    return acceptChangeRole;
  }();

  _proto.endRoom = /*#__PURE__*/function () {
    var _endRoom = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee17(lock, reason) {
      var _this$transport5;

      return runtime_1.wrap(function _callee17$(_context17) {
        while (1) {
          switch (_context17.prev = _context17.next) {
            case 0:
              if (this.localPeer) {
                _context17.next = 2;
                break;
              }

              throw ErrorFactory.GenericErrors.NotConnected(HMSAction.VALIDATION, 'No local peer present, cannot end room');

            case 2:
              _context17.next = 4;
              return (_this$transport5 = this.transport) == null ? void 0 : _this$transport5.endRoom(lock, reason);

            case 4:
            case "end":
              return _context17.stop();
          }
        }
      }, _callee17, this);
    }));

    function endRoom(_x24, _x25) {
      return _endRoom.apply(this, arguments);
    }

    return endRoom;
  }();

  _proto.removePeer = /*#__PURE__*/function () {
    var _removePeer = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee18(peer, reason) {
      var _this$transport6;

      return runtime_1.wrap(function _callee18$(_context18) {
        while (1) {
          switch (_context18.prev = _context18.next) {
            case 0:
              if (this.localPeer) {
                _context18.next = 2;
                break;
              }

              throw ErrorFactory.GenericErrors.NotConnected(HMSAction.VALIDATION, 'No local peer present, cannot remove peer');

            case 2:
              if (this.store.getPeerById(peer.peerId)) {
                _context18.next = 4;
                break;
              }

              throw ErrorFactory.GenericErrors.ValidationFailed('Invalid peer, given peer not present in room', peer);

            case 4:
              _context18.next = 6;
              return (_this$transport6 = this.transport) == null ? void 0 : _this$transport6.removePeer(peer.peerId, reason);

            case 6:
            case "end":
              return _context18.stop();
          }
        }
      }, _callee18, this);
    }));

    function removePeer(_x26, _x27) {
      return _removePeer.apply(this, arguments);
    }

    return removePeer;
  }();

  _proto.startRTMPOrRecording = /*#__PURE__*/function () {
    var _startRTMPOrRecording = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee19(params) {
      var _this$transport7, _params$rtmpURLs;

      var rtmpStart, recordingStart;
      return runtime_1.wrap(function _callee19$(_context19) {
        while (1) {
          switch (_context19.prev = _context19.next) {
            case 0:
              if (this.localPeer) {
                _context19.next = 2;
                break;
              }

              throw ErrorFactory.GenericErrors.NotConnected(HMSAction.VALIDATION, 'No local peer present, cannot start streaming or recording');

            case 2:
              _context19.next = 4;
              return (_this$transport7 = this.transport) == null ? void 0 : _this$transport7.startRTMPOrRecording(params);

            case 4:
              // emit this notification to update current peer recording status
              rtmpStart = {
                method: HMSNotificationMethod.RTMP_START,
                params: {}
              };
              recordingStart = {
                method: HMSNotificationMethod.RECORDING_START,
                params: {
                  type: 'Browser'
                }
              };

              if ((_params$rtmpURLs = params.rtmpURLs) != null && _params$rtmpURLs.length) {
                this.notificationManager.handleNotification(rtmpStart);
              }

              if (params.record) {
                this.notificationManager.handleNotification(recordingStart);
              }

            case 8:
            case "end":
              return _context19.stop();
          }
        }
      }, _callee19, this);
    }));

    function startRTMPOrRecording(_x28) {
      return _startRTMPOrRecording.apply(this, arguments);
    }

    return startRTMPOrRecording;
  }();

  _proto.stopRTMPAndRecording = /*#__PURE__*/function () {
    var _stopRTMPAndRecording = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee20() {
      var _this$transport8;

      var _this$store$getRoom3, recording, rtmp;

      return runtime_1.wrap(function _callee20$(_context20) {
        while (1) {
          switch (_context20.prev = _context20.next) {
            case 0:
              if (this.localPeer) {
                _context20.next = 2;
                break;
              }

              throw ErrorFactory.GenericErrors.NotConnected(HMSAction.VALIDATION, 'No local peer present, cannot stop streaming or recording');

            case 2:
              _context20.next = 4;
              return (_this$transport8 = this.transport) == null ? void 0 : _this$transport8.stopRTMPOrRecording();

            case 4:
              // emit this notification to update current peer recording status
              _this$store$getRoom3 = this.store.getRoom(), recording = _this$store$getRoom3.recording, rtmp = _this$store$getRoom3.rtmp;

              if (recording != null && recording.browser.running) {
                this.notificationManager.handleNotification({
                  method: HMSNotificationMethod.RECORDING_STOP,
                  params: {
                    type: 'Browser'
                  }
                });
              }

              if (rtmp != null && rtmp.running) {
                this.notificationManager.handleNotification({
                  method: HMSNotificationMethod.RTMP_STOP,
                  params: {}
                });
              }

            case 7:
            case "end":
              return _context20.stop();
          }
        }
      }, _callee20, this);
    }));

    function stopRTMPAndRecording() {
      return _stopRTMPAndRecording.apply(this, arguments);
    }

    return stopRTMPAndRecording;
  }();

  _proto.getRoles = function getRoles() {
    return Object.values(this.store.getKnownRoles());
  };

  _proto.changeTrackState = /*#__PURE__*/function () {
    var _changeTrackState = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee21(forRemoteTrack, enabled) {
      var _this$transport9;

      var peer;
      return runtime_1.wrap(function _callee21$(_context21) {
        while (1) {
          switch (_context21.prev = _context21.next) {
            case 0:
              if (!(forRemoteTrack.type === exports.HMSTrackType.VIDEO && forRemoteTrack.source !== 'regular')) {
                _context21.next = 3;
                break;
              }

              HMSLogger.w(this.TAG, "Muting non-regular video tracks is currently not supported");
              return _context21.abrupt("return");

            case 3:
              if (!(forRemoteTrack.enabled === enabled)) {
                _context21.next = 6;
                break;
              }

              HMSLogger.w(this.TAG, "Aborting change track state, track already has enabled - " + enabled, forRemoteTrack);
              return _context21.abrupt("return");

            case 6:
              if (this.store.getTrackById(forRemoteTrack.trackId)) {
                _context21.next = 8;
                break;
              }

              throw ErrorFactory.GenericErrors.ValidationFailed('No track found for change track state', forRemoteTrack);

            case 8:
              peer = this.store.getPeerByTrackId(forRemoteTrack.trackId);

              if (peer) {
                _context21.next = 11;
                break;
              }

              throw ErrorFactory.GenericErrors.ValidationFailed('No peer found for change track state', forRemoteTrack);

            case 11:
              _context21.next = 13;
              return (_this$transport9 = this.transport) == null ? void 0 : _this$transport9.changeTrackState({
                requested_for: peer.peerId,
                track_id: forRemoteTrack.trackId,
                stream_id: forRemoteTrack.stream.id,
                mute: !enabled
              });

            case 13:
            case "end":
              return _context21.stop();
          }
        }
      }, _callee21, this);
    }));

    function changeTrackState(_x29, _x30) {
      return _changeTrackState.apply(this, arguments);
    }

    return changeTrackState;
  }();

  _proto.changeMultiTrackState = /*#__PURE__*/function () {
    var _changeMultiTrackState = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee22(params) {
      var _this$transport10;

      var enabled, roles, type, source;
      return runtime_1.wrap(function _callee22$(_context22) {
        while (1) {
          switch (_context22.prev = _context22.next) {
            case 0:
              if (!(typeof params.enabled !== 'boolean')) {
                _context22.next = 2;
                break;
              }

              throw ErrorFactory.GenericErrors.ValidationFailed('Pass a boolean for enabled');

            case 2:
              enabled = params.enabled, roles = params.roles, type = params.type, source = params.source;
              _context22.next = 5;
              return (_this$transport10 = this.transport) == null ? void 0 : _this$transport10.changeMultiTrackState({
                value: !enabled,
                type: type,
                source: source,
                roles: roles == null ? void 0 : roles.map(function (role) {
                  return role == null ? void 0 : role.name;
                })
              });

            case 5:
            case "end":
              return _context22.stop();
          }
        }
      }, _callee22, this);
    }));

    function changeMultiTrackState(_x31) {
      return _changeMultiTrackState.apply(this, arguments);
    }

    return changeMultiTrackState;
  }();

  _proto.publish = /*#__PURE__*/function () {
    var _publish = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee23(initialSettings) {
      var tracks;
      return runtime_1.wrap(function _callee23$(_context23) {
        while (1) {
          switch (_context23.prev = _context23.next) {
            case 0:
              _context23.next = 2;
              return this.localTrackManager.getTracksToPublish(initialSettings);

            case 2:
              tracks = _context23.sent;
              _context23.next = 5;
              return this.setAndPublishTracks(tracks);

            case 5:
              this.sdkState.published = true;

            case 6:
            case "end":
              return _context23.stop();
          }
        }
      }, _callee23, this);
    }));

    function publish(_x32) {
      return _publish.apply(this, arguments);
    }

    return publish;
  }();

  _proto.setAndPublishTracks = /*#__PURE__*/function () {
    var _setAndPublishTracks = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee24(tracks) {
      var _iterator2, _step2, _this$listener9, track;

      return runtime_1.wrap(function _callee24$(_context24) {
        while (1) {
          switch (_context24.prev = _context24.next) {
            case 0:
              _iterator2 = _createForOfIteratorHelperLoose(tracks);

            case 1:
              if ((_step2 = _iterator2()).done) {
                _context24.next = 9;
                break;
              }

              track = _step2.value;
              _context24.next = 5;
              return this.transport.publish([track]);

            case 5:
              this.setLocalPeerTrack(track);
              (_this$listener9 = this.listener) == null ? void 0 : _this$listener9.onTrackUpdate(exports.HMSTrackUpdate.TRACK_ADDED, track, this.localPeer);

            case 7:
              _context24.next = 1;
              break;

            case 9:
              _context24.next = 11;
              return this.initDeviceManagers();

            case 11:
            case "end":
              return _context24.stop();
          }
        }
      }, _callee24, this);
    }));

    function setAndPublishTracks(_x33) {
      return _setAndPublishTracks.apply(this, arguments);
    }

    return setAndPublishTracks;
  }();

  _proto.setLocalPeerTrack = function setLocalPeerTrack(track) {
    var _this$localPeer10;

    track.peerId = (_this$localPeer10 = this.localPeer) == null ? void 0 : _this$localPeer10.peerId;

    switch (track.type) {
      case exports.HMSTrackType.AUDIO:
        this.localPeer.audioTrack = track;
        break;

      case exports.HMSTrackType.VIDEO:
        this.localPeer.videoTrack = track;
        break;
    }
  };

  _proto.initDeviceManagers = /*#__PURE__*/function () {
    var _initDeviceManagers = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee25() {
      var _DeviceStorageManager, _DeviceStorageManager2, _this$store$getConfig;

      return runtime_1.wrap(function _callee25$(_context25) {
        while (1) {
          switch (_context25.prev = _context25.next) {
            case 0:
              if (!this.sdkState.deviceManagersInitialised) {
                _context25.next = 2;
                break;
              }

              return _context25.abrupt("return");

            case 2:
              this.sdkState.deviceManagersInitialised = true;
              this.deviceManager.addEventListener('audio-device-change', this.handleDeviceChangeError);
              this.deviceManager.addEventListener('video-device-change', this.handleDeviceChangeError);
              _context25.next = 7;
              return this.deviceManager.init();

            case 7:
              this.deviceManager.updateOutputDevice((_DeviceStorageManager = DeviceStorageManager.getSelection()) == null ? void 0 : (_DeviceStorageManager2 = _DeviceStorageManager.audioOutput) == null ? void 0 : _DeviceStorageManager2.deviceId);
              this.audioSinkManager.init((_this$store$getConfig = this.store.getConfig()) == null ? void 0 : _this$store$getConfig.audioSinkElementId);

            case 9:
            case "end":
              return _context25.stop();
          }
        }
      }, _callee25, this);
    }));

    function initDeviceManagers() {
      return _initDeviceManagers.apply(this, arguments);
    }

    return initDeviceManagers;
  }();

  _proto.cleanDeviceManagers = function cleanDeviceManagers() {
    this.deviceManager.removeEventListener('audio-device-change', this.handleDeviceChangeError);
    this.deviceManager.removeEventListener('video-device-change', this.handleDeviceChangeError);
    this.deviceManager.cleanUp();
    this.audioSinkManager.removeEventListener(AutoplayError, this.handleAutoplayError);
    this.audioSinkManager.cleanUp();
  };

  _proto.initPreviewTrackAudioLevelMonitor = function initPreviewTrackAudioLevelMonitor() {
    var _this$localPeer11,
        _this$localPeer11$aud,
        _this$localPeer12,
        _this$localPeer12$aud,
        _this$localPeer12$aud2,
        _this5 = this;

    (_this$localPeer11 = this.localPeer) == null ? void 0 : (_this$localPeer11$aud = _this$localPeer11.audioTrack) == null ? void 0 : _this$localPeer11$aud.initAudioLevelMonitor();
    (_this$localPeer12 = this.localPeer) == null ? void 0 : (_this$localPeer12$aud = _this$localPeer12.audioTrack) == null ? void 0 : (_this$localPeer12$aud2 = _this$localPeer12$aud.audioLevelMonitor) == null ? void 0 : _this$localPeer12$aud2.on('AUDIO_LEVEL_UPDATE', function (audioLevelUpdate) {
      var _this5$localPeer, _this5$audioListener;

      var hmsSpeakers = audioLevelUpdate ? [{
        audioLevel: audioLevelUpdate.audioLevel,
        peer: _this5.localPeer,
        track: (_this5$localPeer = _this5.localPeer) == null ? void 0 : _this5$localPeer.audioTrack
      }] : [];

      _this5.store.updateSpeakers(hmsSpeakers);

      (_this5$audioListener = _this5.audioListener) == null ? void 0 : _this5$audioListener.onAudioLevelUpdate(hmsSpeakers);
    });
  };

  _proto.notifyJoin = function notifyJoin() {
    var _this6 = this;

    var localPeer = this.store.getLocalPeer();

    if (localPeer != null && localPeer.role) {
      var _this$listener10;

      (_this$listener10 = this.listener) == null ? void 0 : _this$listener10.onJoin(this.store.getRoom());
    } else {
      this.notificationManager.once('policy-change', function () {
        var _this6$listener;

        (_this6$listener = _this6.listener) == null ? void 0 : _this6$listener.onJoin(_this6.store.getRoom());
      });
    }
  };

  _createClass(HMSSdk, [{
    key: "localPeer",
    get: function get() {
      var _this$store3;

      return (_this$store3 = this.store) == null ? void 0 : _this$store3.getLocalPeer();
    }
  }, {
    key: "publishParams",
    get: function get() {
      var _this$store4;

      return (_this$store4 = this.store) == null ? void 0 : _this$store4.getPublishParams();
    }
  }]);

  return HMSSdk;
}();

function getLocalStream(_x) {
  return _getLocalStream.apply(this, arguments);
}

function _getLocalStream() {
  _getLocalStream = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(constraints) {
    var stream;
    return runtime_1.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.prev = 0;
            _context.next = 3;
            return navigator.mediaDevices.getUserMedia(constraints);

          case 3:
            stream = _context.sent;
            return _context.abrupt("return", stream);

          case 7:
            _context.prev = 7;
            _context.t0 = _context["catch"](0);
            throw BuildGetMediaError(_context.t0, HMSGetMediaActions.AV);

          case 10:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[0, 7]]);
  }));
  return _getLocalStream.apply(this, arguments);
}

function getLocalScreen(_x2) {
  return _getLocalScreen.apply(this, arguments);
}

function _getLocalScreen() {
  _getLocalScreen = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(constraints) {
    var stream;
    return runtime_1.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.prev = 0;
            _context2.next = 3;
            return navigator.mediaDevices.getDisplayMedia({
              video: constraints,
              audio: false
            });

          case 3:
            stream = _context2.sent;
            return _context2.abrupt("return", stream);

          case 7:
            _context2.prev = 7;
            _context2.t0 = _context2["catch"](0);
            throw BuildGetMediaError(_context2.t0, HMSGetMediaActions.SCREEN);

          case 10:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[0, 7]]);
  }));
  return _getLocalScreen.apply(this, arguments);
}

function getLocalDevices() {
  return _getLocalDevices.apply(this, arguments);
}

function _getLocalDevices() {
  _getLocalDevices = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3() {
    var devices, deviceGroups;
    return runtime_1.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.prev = 0;
            _context3.next = 3;
            return navigator.mediaDevices.enumerateDevices();

          case 3:
            devices = _context3.sent;
            deviceGroups = {
              audioinput: [],
              audiooutput: [],
              videoinput: []
            };
            devices.forEach(function (device) {
              return deviceGroups[device.kind].push(device);
            });
            return _context3.abrupt("return", deviceGroups);

          case 9:
            _context3.prev = 9;
            _context3.t0 = _context3["catch"](0);
            throw BuildGetMediaError(_context3.t0, HMSGetMediaActions.AV);

          case 12:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, null, [[0, 9]]);
  }));
  return _getLocalDevices.apply(this, arguments);
}

function validateDeviceAV() {
  return _validateDeviceAV.apply(this, arguments);
}

function _validateDeviceAV() {
  _validateDeviceAV = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee() {
    var videoTrackSettings, audioTrackSettings, _track, stream, track;

    return runtime_1.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            videoTrackSettings = new HMSVideoTrackSettingsBuilder().build();
            audioTrackSettings = new HMSAudioTrackSettingsBuilder().build();
            /**
             * Check audio failure.
             * If audio failure - check AV failure.
             * If AV failure - throw AV failure.
             * If AV passed - throw audio failure.
             *
             * If audio passed - check video failure.
             * If video failure - throw video failure.
             * If video passed - no error - return false.
             */

            _context.prev = 2;
            _context.next = 5;
            return getAudioTrack(audioTrackSettings);

          case 5:
            _track = _context.sent;

            _track.stop();

            _context.next = 17;
            break;

          case 9:
            _context.prev = 9;
            _context.t0 = _context["catch"](2);

            if (!isHMSDeviceError(_context.t0)) {
              _context.next = 17;
              break;
            }

            _context.next = 14;
            return getLocalStream({
              audio: false,
              video: true
            });

          case 14:
            stream = _context.sent;
            stream.getTracks().forEach(function (track) {
              return track.stop();
            });
            throw _context.t0;

          case 17:
            _context.next = 19;
            return getVideoTrack(videoTrackSettings);

          case 19:
            track = _context.sent;
            track.stop();
            return _context.abrupt("return", false);

          case 22:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[2, 9]]);
  }));
  return _validateDeviceAV.apply(this, arguments);
}

function isHMSDeviceError(error) {
  return error instanceof HMSException && error.action === HMSAction.TRACK;
}

console.log("%c " + adapter.browserDetails.browser + " v" + adapter.browserDetails.version, 'color: #2F80FF');

exports.HMSAudioTrack = HMSAudioTrack;
exports.HMSException = HMSException;
exports.HMSLocalAudioTrack = HMSLocalAudioTrack;
exports.HMSLocalVideoTrack = HMSLocalVideoTrack;
exports.HMSRemoteAudioTrack = HMSRemoteAudioTrack;
exports.HMSRemoteVideoTrack = HMSRemoteVideoTrack;
exports.HMSSdk = HMSSdk;
exports.HMSTrack = HMSTrack;
exports.HMSVideoTrack = HMSVideoTrack;
exports.getLocalDevices = getLocalDevices;
exports.getLocalScreen = getLocalScreen;
exports.getLocalStream = getLocalStream;
exports.isBrowser = isBrowser;
exports.isMobile = isMobile;
exports.isNode = isNode;
exports.isSupported = isSupported;
exports.parsedUserAgent = parsedUserAgent;
exports.userAgent = userAgent;
exports.validateDeviceAV = validateDeviceAV;
//# sourceMappingURL=hms-video.cjs.development.js.map
