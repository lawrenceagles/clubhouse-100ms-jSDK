{"version":3,"file":"hms-video.cjs.production.min.js","sources":["../src/connection/model.ts","../src/utils/logger.ts","../node_modules/regenerator-runtime/runtime.js","../src/utils/session-description.ts","../src/error/ErrorCodes.ts","../src/error/ErrorFactory.ts","../src/error/HMSException.ts","../src/interfaces/update-listener.ts","../src/interfaces/room.ts","../src/interfaces/simulcast-layers.ts","../src/connection/index.ts","../src/connection/publish/index.ts","../src/utils/constants.ts","../src/media/streams/HMSMediaStream.ts","../src/interfaces/track-settings.ts","../src/interfaces/playlist.ts","../src/media/tracks/HMSTrackType.ts","../src/media/streams/HMSRemoteStream.ts","../src/connection/HMSDataChannel.ts","../src/media/tracks/HMSTrack.ts","../src/media/tracks/HMSAudioTrack.ts","../src/media/tracks/HMSRemoteAudioTrack.ts","../src/media/tracks/HMSVideoTrack.ts","../src/media/tracks/HMSRemoteVideoTrack.ts","../src/connection/subscribe/index.ts","../src/utils/presence.ts","../src/utils/support.ts","../src/signal/jsonrpc/models.ts","../src/signal/init/index.ts","../src/error/utils.ts","../src/utils/track.ts","../src/signal/jsonrpc/index.ts","../src/media/settings/HMSAudioTrackSettings.ts","../src/media/settings/HMSVideoTrackSettings.ts","../src/media/settings/HMSTrackSettings.ts","../src/plugins/audio/HMSAudioPlugin.ts","../src/analytics/AnalyticsEventDomains.ts","../src/utils/typed-event-emitter.ts","../src/utils/track-audio-level-monitor.ts","../src/analytics/domain-analytics.ts","../src/analytics/AnalyticsEventLevel.ts","../src/analytics/AnalyticsEvent.ts","../src/analytics/MediaPluginsAnalyticsFactory.ts","../src/analytics/AnalyticsEventsService.ts","../src/plugins/audio/AudioPluginsAnalytics.ts","../src/plugins/audio/HMSAudioPluginsManager.ts","../src/utils/local-storage.ts","../src/device-manager/DeviceStorage.ts","../src/media/tracks/HMSLocalAudioTrack.ts","../src/plugins/video/HMSVideoPlugin.ts","../src/utils/timer-utils.ts","../src/utils/math.ts","../src/plugins/video/VideoPluginsAnalytics.ts","../src/plugins/video/HMSVideoPluginsManager.ts","../src/media/tracks/HMSLocalVideoTrack.ts","../src/notification-manager/HMSNotificationMethod.ts","../src/media/streams/HMSLocalStream.ts","../src/notification-manager/managers/ActiveSpeakerManager.ts","../src/sdk/models/HMSMessage.ts","../src/sdk/models/peer/HMSPeer.ts","../src/utils/id-factory.ts","../src/transport/models/TransportState.ts","../src/sdk/models/peer/HMSLocalPeer.ts","../src/sdk/models/peer/HMSRemotePeer.ts","../src/notification-manager/managers/BroadcastManager.ts","../src/notification-manager/managers/PeerListManager.ts","../src/notification-manager/managers/PeerManager.ts","../src/notification-manager/managers/PolicyChangeManager.ts","../src/notification-manager/managers/RequestManager.ts","../src/notification-manager/managers/RoomUpdateManager.ts","../src/notification-manager/managers/TrackManager.ts","../src/notification-manager/NotificationManager.ts","../src/notification-manager/HMSNotifications.ts","../src/analytics/AnalyticsEventFactory.ts","../src/transport/models/TransportFailureCategory.ts","../src/transport/models/JoinParameters.ts","../src/utils/promise.ts","../src/transport/RetryScheduler.ts","../src/analytics/AnalyticsTransport.ts","../src/analytics/signal-transport/LocalStoageEvents.ts","../src/utils/queue.ts","../src/analytics/signal-transport/SignalAnalyticsTransport.ts","../src/rtc-stats/RTCStatsMonitor.ts","../src/degradation/TrackDegradationController.ts","../src/transport/index.ts","../src/utils/jwt.ts","../src/sdk/LocalTrackManager.ts","../src/sdk/models/HMSRoom.ts","../src/audio-sink-manager/AudioSinkManager.ts","../src/device-manager/DeviceManager.ts","../src/device-manager/AudioOutputManager.ts","../src/sdk/store/Comparator.ts","../src/sdk/store/Store.ts","../src/sdk/RoleChangeManager.ts","../src/playlist-manager/AudioContextManager.ts","../src/playlist-manager/PlaylistAudioManager.ts","../src/playlist-manager/PlaylistVideoManager.ts","../src/playlist-manager/PlaylistManager.ts","../src/sdk/index.ts","../src/utils/media.ts","../src/utils/device-error.ts","../src/index.ts"],"sourcesContent":["export enum HMSConnectionRole {\n  Publish = 0,\n  Subscribe = 1,\n}\n\nexport interface HMSTrickle {\n  candidate: RTCIceCandidateInit;\n  target: HMSConnectionRole;\n}\n","export enum HMSLogLevel {\n  VERBOSE,\n  DEBUG,\n  INFO,\n  WARN,\n  TIME,\n  TIMEEND,\n  ERROR,\n  NONE,\n}\n\n/**\n * TODO: fix this so logs show the real file and line numbers where they originated from instead of this class\n * https://stackoverflow.com/questions/13815640/a-proper-wrapper-for-console-log-with-correct-line-number\n */\nexport default class HMSLogger {\n  static level: HMSLogLevel = HMSLogLevel.VERBOSE;\n\n  static v(tag: string, ...data: any[]) {\n    this.log(HMSLogLevel.VERBOSE, tag, ...data);\n  }\n\n  static d(tag: string, ...data: any[]) {\n    this.log(HMSLogLevel.DEBUG, tag, ...data);\n  }\n\n  static i(tag: string, ...data: any[]) {\n    this.log(HMSLogLevel.INFO, tag, ...data);\n  }\n\n  static w(tag: string, ...data: any[]) {\n    this.log(HMSLogLevel.WARN, tag, ...data);\n  }\n\n  static e(tag: string, ...data: any[]) {\n    this.log(HMSLogLevel.ERROR, tag, ...data);\n  }\n\n  static time(mark: string) {\n    this.log(HMSLogLevel.TIME, '[HMSPerformanceTiming]', mark);\n  }\n\n  static timeEnd(mark: string) {\n    this.log(HMSLogLevel.TIMEEND, '[HMSPerformanceTiming]', mark, mark);\n  }\n\n  static cleanUp() {\n    performance.clearMarks();\n    performance.clearMeasures();\n  }\n\n  private static log(level: HMSLogLevel, tag: string, ...data: any[]) {\n    if (this.level.valueOf() > level.valueOf()) {\n      return;\n    }\n\n    switch (level) {\n      case HMSLogLevel.VERBOSE: {\n        console.log(tag, ...data);\n        break;\n      }\n      case HMSLogLevel.DEBUG: {\n        console.debug(tag, ...data);\n        break;\n      }\n      case HMSLogLevel.INFO: {\n        console.info(tag, ...data);\n        break;\n      }\n      case HMSLogLevel.WARN: {\n        console.warn(tag, ...data);\n        break;\n      }\n      case HMSLogLevel.ERROR: {\n        console.error(tag, ...data);\n        break;\n      }\n      case HMSLogLevel.TIME: {\n        performance.mark(data[0]);\n        break;\n      }\n      case HMSLogLevel.TIMEEND: {\n        const mark = data[0];\n        try {\n          const entry = performance.measure(mark, mark);\n          // @ts-ignore\n          this.log(HMSLogLevel.DEBUG, tag, mark, entry?.duration);\n          performance.clearMarks(mark);\n          performance.clearMeasures(mark);\n        } catch (error) {\n          this.log(HMSLogLevel.DEBUG, tag, mark, error);\n        }\n        break;\n      }\n    }\n  }\n}\n","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, \"\");\n  } catch (err) {\n    define = function(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  define(IteratorPrototype, iteratorSymbol, function () {\n    return this;\n  });\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = GeneratorFunctionPrototype;\n  define(Gp, \"constructor\", GeneratorFunctionPrototype);\n  define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction);\n  GeneratorFunction.displayName = define(\n    GeneratorFunctionPrototype,\n    toStringTagSymbol,\n    \"GeneratorFunction\"\n  );\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      define(prototype, method, function(arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {\n    return this;\n  });\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  define(Gp, toStringTagSymbol, \"Generator\");\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  define(Gp, iteratorSymbol, function() {\n    return this;\n  });\n\n  define(Gp, \"toString\", function() {\n    return \"[object Generator]\";\n  });\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, in modern engines\n  // we can explicitly access globalThis. In older engines we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  if (typeof globalThis === \"object\") {\n    globalThis.regeneratorRuntime = runtime;\n  } else {\n    Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n  }\n}\n","import * as sdpTransform from 'sdp-transform';\nimport { TrackState } from '../notification-manager';\nimport { isPresent } from './presence';\n\n/**\n * @DISCUSS: Should we have a wrapper over RTCSessionDescriptionInit(SDP) and have these methods in it?\n */\n\nexport function fixMsid(desc: RTCSessionDescriptionInit, tracks: Map<string, TrackState>): RTCSessionDescriptionInit {\n  const parsedSdp = sdpTransform.parse(desc.sdp!);\n\n  if (!parsedSdp.origin?.username.startsWith('mozilla')) {\n    // This isn't firefox, so we return the original offer without doing anything\n    return desc;\n  }\n\n  const mediaTracks = Array.from(tracks.values());\n\n  parsedSdp.media.forEach((m) => {\n    const streamId = m.msid?.split(' ')[0];\n    // check for both type and streamid as both video and screenshare have same type but different stream_id\n    const trackId = mediaTracks.find((val) => val.type === m.type && val.stream_id === streamId)?.track_id;\n    if (trackId) {\n      m.msid = m.msid?.replace(/\\s(.+)/, ` ${trackId}`);\n    }\n  });\n\n  return { type: desc.type, sdp: sdpTransform.write(parsedSdp) };\n}\n\n/**\n * Get the track ID from the SDP using the transceiver's mid from RTCTrackEvent\n * @TODO: This could take more processing time in a large room and when the SDP is big.\n * Consider using this for Firefox only?\n */\nexport function getSdpTrackIdForMid(\n  desc?: RTCSessionDescriptionInit | null,\n  mid?: RTCRtpTransceiver['mid'],\n): string | undefined {\n  if (!desc?.sdp || !mid) {\n    return undefined;\n  }\n  const parsedSdp = sdpTransform.parse(desc.sdp);\n  const trackSection = parsedSdp.media.find((media) => isPresent(media.mid) && parseInt(media.mid!) === parseInt(mid));\n  const trackId = trackSection?.msid?.split(' ')[1];\n  return trackId;\n}\n\nexport function enableOpusDtx(desc: RTCSessionDescriptionInit): RTCSessionDescriptionInit {\n  if (desc.sdp!.includes('usedtx=1')) return desc;\n\n  return { type: desc.type, sdp: desc.sdp!.replace('useinbandfec=1', 'useinbandfec=1;usedtx=1') };\n}\n","/*\n * ErrorCodes.ts\n *\n * Created by codegen\n * Copyright © 2021 100ms. All rights reserved.\n */\n\nexport const ErrorCodes = {\n  WebSocketConnectionErrors: {\n    // Something went wrong\n    GENERIC_CONNECT: 1000,\n\n    // Network connection lost\n    WEBSOCKET_CONNECTION_LOST: 1003,\n  },\n\n  InitAPIErrors: {\n    // [INIT]: Server error\n    SERVER_ERRORS: 2000,\n\n    // [INIT]: Network error\n    CONNECTION_LOST: 2001,\n\n    // Bad Request\n    HTTP_ERROR: 2400,\n\n    // Endpoint URL is invalid\n    INVALID_ENDPOINT_URL: 2002,\n\n    // Endpoint is not reachable.\n    ENDPOINT_UNREACHABLE: 2003,\n\n    // Token is not in proper JWT format\n    INVALID_TOKEN_FORMAT: 2004,\n  },\n\n  TracksErrors: {\n    // [PUBLISH]: Something went wrong\n    GENERIC_TRACK: 3000,\n\n    // [PUBLISH]: No permission to access capture device - {device_type}\n    CANT_ACCESS_CAPTURE_DEVICE: 3001,\n\n    // [PUBLISH]: Capture device is no longer available - {device_type}\n    DEVICE_NOT_AVAILABLE: 3002,\n\n    // [PUBLISH]: Capture device is in use by another application - {device_type}\n    DEVICE_IN_USE: 3003,\n\n    // Lost access to capture device midway - {device_type}\n    DEVICE_LOST_MIDWAY: 3008,\n\n    // There is no media to return. Please select either video or audio or both.\n    NOTHING_TO_RETURN: 3005,\n\n    // Cannot enable simulcast when no video settings are provided\n    INVALID_VIDEO_SETTINGS: 3006,\n\n    // Codec can't be changed mid call.\n    CODEC_CHANGE_NOT_PERMITTED: 3007,\n\n    // When the browser throws autoplay exception if something is played before interacting\n    AUTOPLAY_ERROR: 3008,\n  },\n\n  WebrtcErrors: {\n    // [{action}]: Failed to create offer.\n    CREATE_OFFER_FAILED: 4001,\n\n    // [{action}]: Failed to create answer.\n    CREATE_ANSWER_FAILED: 4002,\n\n    // [{action}]: Failed to set offer.\n    SET_LOCAL_DESCRIPTION_FAILED: 4003,\n\n    // [{action}]: Failed to set answer.\n    SET_REMOTE_DESCRIPTION_FAILED: 4004,\n\n    // [{action}]: Ice connection state FAILED\n    ICE_FAILURE: 4005,\n  },\n\n  WebsocketMethodErrors: {\n    // [JOIN]: {server_error}\n    SERVER_ERRORS: 5000,\n\n    // [JOIN]: You have already joined this room.\n    ALREADY_JOINED: 5001,\n\n    // [JOIN]: Cannot join if preview is in progress\n    CANNOT_JOIN_PREVIEW_IN_PROGRESS: 5002,\n  },\n\n  GenericErrors: {\n    // Client is not connected\n    NOT_CONNECTED: 6000,\n\n    // Unknown signalling error: {action} {error_info}\n    SIGNALLING: 6001,\n\n    // Unknown exception: {error_info}\n    UNKNOWN: 6002,\n\n    // WebRTC engine is not ready yet\n    NOT_READY: 6003,\n\n    // Failed to parse JSON message - {json_message}\n    JSON_PARSING_FAILED: 6004,\n\n    // Track Metadata Missing\n    TRACK_METADATA_MISSING: 6005,\n\n    // RTC Track missing\n    RTC_TRACK_MISSING: 6006,\n\n    // Peer Metadata Missing\n    PEER_METADATA_MISSING: 6007,\n\n    // Joined with invalid role\n    INVALID_ROLE: 6008,\n  },\n\n  PlaylistErrors: {\n    NO_ENTRY_TO_PLAY: 8001,\n    NO_ENTRY_IS_PLAYING: 8002,\n  },\n};\n","/*\n * ErrorFactory.ts\n *\n * Created by codegen\n * Copyright © 2021 100ms. All rights reserved.\n */\n\nimport { ErrorCodes } from './ErrorCodes';\nimport { HMSException } from './HMSException';\n\nexport enum HMSAction {\n  NONE = 'NONE',\n  TRACK = 'TRACK',\n  INIT = 'INIT',\n  PUBLISH = 'PUBLISH',\n  UNPUBLISH = 'UNPUBLISH',\n  JOIN = 'JOIN',\n  SUBSCRIBE = 'SUBSCRIBE',\n  DATA_CHANNEL_SEND = 'DATA_CHANNEL_SEND',\n  RESTART_ICE = 'RESTART_ICE',\n  VIDEO_PLUGINS = 'VIDEO_PLUGINS',\n  AUDIO_PLUGINS = 'AUDIO_PLUGINS',\n  AUTOPLAY = 'AUTOPLAY',\n  RECONNECT_SIGNAL = 'RECONNECT_SIGNAL',\n  VALIDATION = 'VALIDATION',\n  PLAYLIST = 'PLAYLIST',\n}\n\nexport const ErrorFactory = {\n  WebSocketConnectionErrors: {\n    GenericConnect(action: HMSAction, description: string = '') {\n      return new HMSException(1000, 'GenericConnect', action, `Something went wrong`, description);\n    },\n\n    WebSocketConnectionLost(action: HMSAction, description: string = '') {\n      return new HMSException(1003, 'WebSocketConnectionLost', action, `Network connection lost `, description);\n    },\n  },\n\n  InitAPIErrors: {\n    ServerErrors(code: number, action: HMSAction, description: string = '') {\n      return new HMSException(code, 'ServerErrors', action, `[INIT]: Server error`, description);\n    },\n\n    ConnectionLost(action: HMSAction, description: string = '') {\n      return new HMSException(2001, 'ConnectionLost', action, `[INIT]: Network error`, description);\n    },\n\n    HTTPError(code: number, action: HMSAction, description: string = '') {\n      return new HMSException(code, 'HTTPError', action, `[INIT]: Bad Request`, description);\n    },\n\n    InvalidEndpointURL(action: HMSAction, description: string = '') {\n      return new HMSException(2002, 'InvalidEndpointURL', action, `Endpoint URL is invalid`, description);\n    },\n\n    EndpointUnreachable(action: HMSAction, description: string = '') {\n      return new HMSException(2003, 'EndpointUnreachable', action, `Endpoint is not reachable.`, description);\n    },\n\n    InvalidTokenFormat(action: HMSAction, description: string = '') {\n      return new HMSException(2004, 'InvalidTokenFormat', action, `Token is not in proper JWT format`, description);\n    },\n  },\n\n  TracksErrors: {\n    GenericTrack(action: HMSAction, description: string = '') {\n      return new HMSException(3000, 'GenericTrack', action, `[TRACK]: Something went wrong`, description);\n    },\n\n    CantAccessCaptureDevice(action: HMSAction, deviceInfo: string, description: string = '') {\n      return new HMSException(\n        3001,\n        'CantAccessCaptureDevice',\n        action,\n        `[TRACK]: No permission to access capture device - ${deviceInfo}`,\n        description,\n      );\n    },\n\n    DeviceNotAvailable(action: HMSAction, deviceInfo: string, description: string = '') {\n      return new HMSException(\n        3002,\n        'DeviceNotAvailable',\n        action,\n        `[TRACK]: Capture device is no longer available - ${deviceInfo}`,\n        description,\n      );\n    },\n\n    DeviceInUse(action: HMSAction, deviceInfo: string, description: string = '') {\n      return new HMSException(\n        3003,\n        'DeviceInUse',\n        action,\n        `[TRACK]: Capture device is in use by another application - ${deviceInfo}`,\n        description,\n      );\n    },\n\n    DeviceLostMidway(action: HMSAction, deviceInfo: string, description: string = '') {\n      return new HMSException(\n        3008,\n        'DeviceLostMidway',\n        action,\n        `Lost access to capture device midway - ${deviceInfo}`,\n        description,\n      );\n    },\n\n    NothingToReturn(action: HMSAction, description: string = '') {\n      return new HMSException(\n        3005,\n        'NothingToReturn',\n        action,\n        `There is no media to return. Please select either video or audio or both.`,\n        description,\n      );\n    },\n\n    InvalidVideoSettings(action: HMSAction, description: string = '') {\n      return new HMSException(\n        3006,\n        'InvalidVideoSettings',\n        action,\n        `Cannot enable simulcast when no video settings are provided`,\n        description,\n      );\n    },\n\n    AutoplayBlocked(action: HMSAction, description: string = '') {\n      return new HMSException(\n        ErrorCodes.TracksErrors.AUTOPLAY_ERROR,\n        'AutoplayBlocked',\n        action,\n        \"Autoplay blocked because the user didn't interact with the document first\",\n        description,\n      );\n    },\n\n    CodecChangeNotPermitted(action: HMSAction, description: string = '') {\n      return new HMSException(3007, 'CodecChangeNotPermitted', action, `Codec can't be changed mid call.`, description);\n    },\n  },\n\n  WebrtcErrors: {\n    CreateOfferFailed(action: HMSAction, description: string = '') {\n      return new HMSException(\n        4001,\n        'CreateOfferFailed',\n        action,\n        `[${action.toString()}]: Failed to create offer. `,\n        description,\n      );\n    },\n\n    CreateAnswerFailed(action: HMSAction, description: string = '') {\n      return new HMSException(\n        4002,\n        'CreateAnswerFailed',\n        action,\n        `[${action.toString()}]: Failed to create answer. `,\n        description,\n      );\n    },\n\n    SetLocalDescriptionFailed(action: HMSAction, description: string = '') {\n      return new HMSException(\n        4003,\n        'SetLocalDescriptionFailed',\n        action,\n        `[${action.toString()}]: Failed to set offer. `,\n        description,\n      );\n    },\n\n    SetRemoteDescriptionFailed(action: HMSAction, description: string = '') {\n      return new HMSException(\n        4004,\n        'SetRemoteDescriptionFailed',\n        action,\n        `[${action.toString()}]: Failed to set answer. `,\n        description,\n      );\n    },\n\n    ICEFailure(action: HMSAction, description: string = '') {\n      return new HMSException(\n        4005,\n        'ICEFailure',\n        action,\n        `[${action.toString()}]: Ice connection state FAILED`,\n        description,\n      );\n    },\n  },\n\n  WebsocketMethodErrors: {\n    ServerErrors(code: number, action: HMSAction, description: string) {\n      return new HMSException(code, 'ServerErrors', action, description, description);\n    },\n\n    AlreadyJoined(action: HMSAction, description: string = '') {\n      return new HMSException(5001, 'AlreadyJoined', action, `[JOIN]: You have already joined this room.`, description);\n    },\n\n    CannotJoinPreviewInProgress(action: HMSAction, description: string = '') {\n      return new HMSException(\n        5002,\n        'CannotJoinPreviewInProgress',\n        action,\n        `[JOIN]: Cannot join if preview is in progress`,\n        description,\n      );\n    },\n  },\n\n  GenericErrors: {\n    NotConnected(action: HMSAction, description: string = '') {\n      return new HMSException(6000, 'NotConnected', action, `Client is not connected`, description);\n    },\n\n    Signalling(action: HMSAction, description: string) {\n      return new HMSException(\n        6001,\n        'Signalling',\n        action,\n        `Unknown signalling error: ${action.toString()} ${description} `,\n        description,\n      );\n    },\n\n    Unknown(action: HMSAction, description: string) {\n      return new HMSException(6002, 'Unknown', action, `Unknown exception: ${description}`, description);\n    },\n\n    NotReady(action: HMSAction, description: string = '') {\n      return new HMSException(6003, 'NotReady', action, `WebRTC engine is not ready yet`, description);\n    },\n\n    JsonParsingFailed(action: HMSAction, jsonMessage: string, description: string = '') {\n      return new HMSException(\n        6004,\n        'JsonParsingFailed',\n        action,\n        `Failed to parse JSON message - ${jsonMessage}`,\n        description,\n      );\n    },\n\n    TrackMetadataMissing(action: HMSAction, description: string = '') {\n      return new HMSException(6005, 'TrackMetadataMissing', action, `Track Metadata Missing`, description);\n    },\n\n    RTCTrackMissing(action: HMSAction, description: string = '') {\n      return new HMSException(6006, 'RTCTrackMissing', action, `RTC Track missing`, description);\n    },\n\n    PeerMetadataMissing(action: HMSAction, description: string = '') {\n      return new HMSException(6007, 'PeerMetadataMissing', action, `Peer Metadata Missing`, description);\n    },\n\n    ValidationFailed(message: string, entity?: any) {\n      return new HMSException(\n        6008,\n        'ValidationFailed',\n        HMSAction.VALIDATION,\n        message,\n        entity ? JSON.stringify(entity) : '',\n      );\n    },\n\n    InvalidRole(action: HMSAction, description: string) {\n      return new HMSException(\n        ErrorCodes.GenericErrors.INVALID_ROLE,\n        'InvalidRole',\n        action,\n        `Invalid role. Join with valid role`,\n        description,\n        true,\n      );\n    },\n  },\n\n  MediaPluginErrors: {\n    PlatformNotSupported(action: HMSAction, description: string = '') {\n      return new HMSException(\n        7001,\n        'PlatformNotSupported',\n        action,\n        'Check HMS Docs to see the list of supported platforms',\n        description,\n      );\n    },\n\n    InitFailed(action: HMSAction, description: string = '') {\n      return new HMSException(7002, 'InitFailed', action, 'Plugin init failed', description);\n    },\n\n    ProcessingFailed(action: HMSAction, description: string = '') {\n      return new HMSException(7003, 'ProcessingFailed', action, 'Plugin processing failed', description);\n    },\n\n    AddAlreadyInProgress(action: HMSAction, description: string = '') {\n      return new HMSException(7004, 'AddAlreadyInProgress', action, 'Plugin add already in progress', description);\n    },\n  },\n\n  PlaylistErrors: {\n    NoEntryToPlay(action: HMSAction, description: string) {\n      return new HMSException(\n        ErrorCodes.PlaylistErrors.NO_ENTRY_TO_PLAY,\n        'NoEntryToPlay',\n        action,\n        'Reached end of playlist',\n        description,\n      );\n    },\n    NoEntryPlaying(action: HMSAction, description: string) {\n      return new HMSException(\n        ErrorCodes.PlaylistErrors.NO_ENTRY_IS_PLAYING,\n        'NoEntryIsPlaying',\n        action,\n        'No entry is playing at this time',\n        description,\n      );\n    },\n  },\n};\n","import { IAnalyticsPropertiesProvider } from '../analytics/IAnalyticsPropertiesProvider';\nimport { HMSAction } from './ErrorFactory';\n\nexport class HMSException extends Error implements IAnalyticsPropertiesProvider {\n  action: string;\n  nativeError?: Error;\n\n  constructor(\n    public readonly code: number,\n    public name: string,\n    action: HMSAction,\n    public message: string,\n    public description: string,\n    public isTerminal: boolean = false,\n  ) {\n    super(message);\n\n    // Ref: https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work\n    Object.setPrototypeOf(this, HMSException.prototype);\n    this.action = action.toString();\n  }\n\n  toAnalyticsProperties() {\n    return {\n      error_name: this.name,\n      error_code: this.code,\n      error_message: this.message,\n      error_description: this.description,\n      action: this.action,\n      is_terminal: this.isTerminal,\n    };\n  }\n\n  addNativeError(error: Error) {\n    this.nativeError = error;\n  }\n}\n","import { HMSException } from '../error/HMSException';\nimport { HMSTrack } from '../media/tracks/HMSTrack';\nimport { HMSPeer } from '../sdk/models/peer';\nimport { HMSRoleChangeRequest } from './role-change-request';\nimport { HMSMessage } from './message';\nimport { HMSRoom } from './room';\nimport { HMSSpeaker } from './speaker';\nimport { DeviceChangeListener } from './device-change-listener';\nimport { HMSChangeMultiTrackStateRequest, HMSChangeTrackStateRequest } from './change-track-state';\nimport { HMSLeaveRoomRequest } from './leave-room-request';\n\nexport enum HMSRoomUpdate {\n  PEER_ADDED,\n  PEER_REMOVED,\n  PEER_KNOCKED,\n  ROOM_TYPE_CHANGED,\n  METADATA_UPDATED,\n  SCREENSHARE_STARTED,\n  SCREENSHARE_STOPPED,\n  DEFAULT_UPDATE,\n  RECORDING_STATE_UPDATED,\n  BROWSER_RECORDING_STATE_UPDATED,\n  SERVER_RECORDING_STATE_UPDATED,\n  RTMP_STREAMING_STATE_UPDATED,\n}\n\nexport enum HMSPeerUpdate {\n  PEER_JOINED,\n  PEER_LEFT,\n  AUDIO_TOGGLED,\n  VIDEO_TOGGLED,\n  BECAME_DOMINANT_SPEAKER,\n  RESIGNED_DOMINANT_SPEAKER,\n  STARTED_SPEAKING,\n  STOPPED_SPEAKING,\n  ROLE_UPDATED,\n  PEER_LIST,\n}\n\nexport enum HMSTrackUpdate {\n  TRACK_ADDED,\n  TRACK_REMOVED,\n  TRACK_MUTED,\n  TRACK_UNMUTED,\n  TRACK_DESCRIPTION_CHANGED,\n  TRACK_DEGRADED,\n  TRACK_RESTORED,\n}\n\nexport interface HMSAudioListener {\n  onAudioLevelUpdate(speakers: HMSSpeaker[]): void;\n}\n\nexport interface HMSUpdateListener extends DeviceChangeListener {\n  onJoin(room: HMSRoom): void;\n  onRoomUpdate(type: HMSRoomUpdate, room: HMSRoom): void;\n  onPeerUpdate(type: HMSPeerUpdate, peer: HMSPeer | HMSPeer[] | null): void;\n  onTrackUpdate(type: HMSTrackUpdate, track: HMSTrack, peer: HMSPeer): void;\n  onMessageReceived(message: HMSMessage): void;\n  onError(error: HMSException): void;\n  onReconnecting(error: HMSException): void;\n  onReconnected(): void;\n  onRoleChangeRequest(request: HMSRoleChangeRequest): void;\n  onRoleUpdate(newRole: string): void;\n  onChangeTrackStateRequest(request: HMSChangeTrackStateRequest): void;\n  onChangeMultiTrackStateRequest(request: HMSChangeMultiTrackStateRequest): void;\n  onRemovedFromRoom(request: HMSLeaveRoomRequest): void;\n}\n","import { HMSLocalPeer, HMSPeer } from '../sdk/models/peer';\n\nexport enum HMSRoomType {\n  DEFAULT,\n}\n\nexport interface HMSRoom {\n  id: string;\n  name: string;\n  localPeer: HMSLocalPeer;\n  peers: HMSPeer[];\n  shareableLink: string;\n  type: HMSRoomType;\n  hasWaitingRoom: boolean;\n  recording?: HMSRecording;\n  rtmp?: HMSRTMP;\n}\n\nexport interface HMSRecording {\n  browser: {\n    running: boolean;\n  };\n  server: {\n    running: boolean;\n  };\n}\n\nexport interface HMSRTMP {\n  running: boolean;\n}\n","export enum HMSSimulcastLayer {\n  NONE = 'none',\n  LOW = 'low',\n  MEDIUM = 'medium',\n  HIGH = 'high',\n}\n\nexport interface SimulcastLayer {\n  rid: string;\n  scaleResolutionDownBy?: number;\n  maxBitrate: number;\n  maxFramerate: number;\n}\n\nexport interface SimulcastDimensions {\n  width?: number;\n  height?: number;\n}\n\nexport interface SimulcastLayers extends SimulcastDimensions {\n  layers: SimulcastLayer[];\n}\n\nexport interface SimulcastLayerDefinition {\n  layer: Exclude<HMSSimulcastLayer, HMSSimulcastLayer.NONE>;\n  resolution: SimulcastDimensions;\n}\n\nexport type RID = 'f' | 'h' | 'q';\n\nexport const simulcastMapping = {\n  f: HMSSimulcastLayer.HIGH,\n  h: HMSSimulcastLayer.MEDIUM,\n  q: HMSSimulcastLayer.LOW,\n};\n","import { HMSConnectionRole } from './model';\nimport { ISignal } from '../signal/ISignal';\nimport HMSLogger from '../utils/logger';\nimport { HMSLocalTrack } from '../media/tracks';\nimport { enableOpusDtx, fixMsid } from '../utils/session-description';\nimport { ErrorFactory, HMSAction } from '../error/ErrorFactory';\nimport { TrackState } from '../notification-manager';\n\nconst TAG = 'HMSConnection';\nexport default abstract class HMSConnection {\n  readonly role: HMSConnectionRole;\n  protected readonly signal: ISignal;\n\n  abstract readonly nativeConnection: RTCPeerConnection;\n  /**\n   * We keep a list of pending IceCandidates received\n   * from the signalling server. When the peer-connection\n   * is initialized we call [addIceCandidate] for each.\n   *\n   * WARN:\n   *  - [HMSPublishConnection] keeps the complete list of candidates (for\n   *      ice-connection failed/disconnect) forever.\n   *  - [HMSSubscribeConnection] clears this list as soon as we call [addIceCandidate]\n   */\n  readonly candidates = new Array<RTCIceCandidateInit>();\n\n  protected constructor(role: HMSConnectionRole, signal: ISignal) {\n    this.role = role;\n    this.signal = signal;\n  }\n\n  public get iceConnectionState(): RTCIceConnectionState {\n    return this.nativeConnection.iceConnectionState;\n  }\n\n  public get connectionState(): RTCPeerConnectionState {\n    return this.nativeConnection.connectionState;\n  }\n\n  private get action(): HMSAction {\n    return this.role === HMSConnectionRole.Publish ? HMSAction.PUBLISH : HMSAction.SUBSCRIBE;\n  }\n\n  addTransceiver(track: MediaStreamTrack, init: RTCRtpTransceiverInit): RTCRtpTransceiver {\n    return this.nativeConnection.addTransceiver(track, init);\n  }\n\n  async createOffer(\n    options: RTCOfferOptions | undefined = undefined,\n    tracks: Map<string, TrackState>,\n  ): Promise<RTCSessionDescriptionInit> {\n    try {\n      const offer = await this.nativeConnection.createOffer(options);\n      HMSLogger.d(TAG, `[role=${this.role}] createOffer offer=${JSON.stringify(offer, null, 1)}`);\n      return enableOpusDtx(fixMsid(offer, tracks));\n    } catch (error) {\n      throw ErrorFactory.WebrtcErrors.CreateOfferFailed(this.action, (error as Error).message);\n    }\n  }\n\n  async createAnswer(options: RTCOfferOptions | undefined = undefined): Promise<RTCSessionDescriptionInit> {\n    try {\n      const answer = await this.nativeConnection.createAnswer(options);\n      HMSLogger.d(TAG, `[role=${this.role}] createAnswer answer=${JSON.stringify(answer, null, 1)}`);\n      return answer;\n    } catch (error) {\n      throw ErrorFactory.WebrtcErrors.CreateAnswerFailed(this.action, (error as Error).message);\n    }\n  }\n\n  async setLocalDescription(description: RTCSessionDescriptionInit): Promise<void> {\n    try {\n      HMSLogger.d(TAG, `[role=${this.role}] setLocalDescription description=${JSON.stringify(description, null, 1)}`);\n      await this.nativeConnection.setLocalDescription(description);\n    } catch (error) {\n      throw ErrorFactory.WebrtcErrors.SetLocalDescriptionFailed(this.action, (error as Error).message);\n    }\n  }\n\n  async setRemoteDescription(description: RTCSessionDescriptionInit): Promise<void> {\n    try {\n      HMSLogger.d(TAG, `[role=${this.role}] setRemoteDescription description=${JSON.stringify(description, null, 1)}`);\n      await this.nativeConnection.setRemoteDescription(description);\n    } catch (error) {\n      throw ErrorFactory.WebrtcErrors.SetRemoteDescriptionFailed(this.action, (error as Error).message);\n    }\n  }\n\n  async addIceCandidate(candidate: RTCIceCandidateInit): Promise<void> {\n    HMSLogger.d(TAG, `[role=${this.role}] addIceCandidate candidate=${JSON.stringify(candidate, null, 1)}`);\n    await this.nativeConnection.addIceCandidate(candidate);\n  }\n\n  public get remoteDescription(): RTCSessionDescription | null {\n    return this.nativeConnection.remoteDescription;\n  }\n\n  getSenders(): Array<RTCRtpSender> {\n    return this.nativeConnection.getSenders();\n  }\n\n  removeTrack(sender: RTCRtpSender) {\n    this.nativeConnection.removeTrack(sender);\n  }\n\n  async setMaxBitrate(maxBitrate: number, track: HMSLocalTrack) {\n    const sender = this.getSenders().find((s) => s?.track?.id === track.getTrackIDBeingSent());\n\n    if (sender) {\n      const params = sender.getParameters();\n      if (params.encodings.length > 0) {\n        params.encodings[0].maxBitrate = maxBitrate * 1000;\n      }\n      await sender.setParameters(params);\n    } else {\n      HMSLogger.w(\n        TAG,\n        `no sender found to setMaxBitrate for track - ${track.trackId}, sentTrackId - ${track.getTrackIDBeingSent()}`,\n      );\n    }\n  }\n\n  async getStats() {\n    const stats = await this.nativeConnection.getStats();\n    const reports: any[] = [];\n    stats.forEach((stat) => reports.push(stat));\n    return reports;\n  }\n\n  async close() {\n    this.nativeConnection.close();\n  }\n}\n","import HMSConnection from '../index';\nimport { ISignal } from '../../signal/ISignal';\nimport { IPublishConnectionObserver } from './IPublishConnectionObserver';\nimport { HMSConnectionRole } from '../model';\nimport { API_DATA_CHANNEL } from '../../utils/constants';\nimport HMSLogger from '../../utils/logger';\nimport HMSTransport from '../../transport';\nimport { HMSLocalTrack } from '../../media/tracks';\n\nconst TAG = 'HMSPublishConnection';\n\nexport default class HMSPublishConnection extends HMSConnection {\n  private readonly observer: IPublishConnectionObserver;\n  readonly nativeConnection: RTCPeerConnection;\n  private readonly transport: HMSTransport;\n\n  constructor(\n    signal: ISignal,\n    config: RTCConfiguration,\n    observer: IPublishConnectionObserver,\n    transport: HMSTransport,\n  ) {\n    super(HMSConnectionRole.Publish, signal);\n    this.observer = observer;\n    this.transport = transport;\n\n    this.nativeConnection = new RTCPeerConnection(config);\n    this.nativeConnection.createDataChannel(API_DATA_CHANNEL, {\n      protocol: 'SCTP',\n    });\n\n    this.nativeConnection.onicecandidate = ({ candidate }) => {\n      if (candidate) {\n        signal.trickle(this.role, candidate);\n      }\n    };\n\n    this.nativeConnection.oniceconnectionstatechange = () => {\n      this.observer.onIceConnectionChange(this.nativeConnection.iceConnectionState);\n    };\n\n    // @TODO(eswar): Remove this. Use iceconnectionstate change with interval and threshold.\n    this.nativeConnection.onconnectionstatechange = () => {\n      this.observer.onConnectionStateChange(this.nativeConnection.connectionState);\n    };\n  }\n\n  initAfterJoin() {\n    this.nativeConnection.onnegotiationneeded = async () => {\n      HMSLogger.d(TAG, `onnegotiationneeded`);\n      await this.observer.onRenegotiationNeeded();\n    };\n  }\n\n  trackUpdate(track: HMSLocalTrack) {\n    this.transport.trackUpdate(track);\n  }\n}\n","export const RENEGOTIATION_CALLBACK_ID = 'renegotiation-callback-id';\nexport const API_DATA_CHANNEL = 'ion-sfu';\nexport const ANALYTICS_BUFFER_SIZE = 100;\n\n/**\n * Maximum number of retries that transport-layer will try\n * before giving up on the connection and returning a failure\n *\n * Refer https://100ms.atlassian.net/browse/HMS-2369\n */\nexport const MAX_TRANSPORT_RETRIES = 5;\nexport const MAX_TRANSPORT_RETRY_DELAY = 60;\n\nexport const DEFAULT_SIGNAL_PING_TIMEOUT = 10000;\nexport const SIGNAL_PING_INTERVAL = 1000;\n\nexport const SUBSCRIBE_ICE_CONNECTION_CALLBACK_ID = 'SUBSCRIBE_ICE_CONNECTION_CALLBACK_ID';\nexport const SUBSCRIBE_TIMEOUT = 60000;\n\nexport const RTC_STATS_MONITOR_INTERVAL = 1000;\n","import { HMSTrack } from '../tracks/HMSTrack';\n\nexport default class HMSMediaStream {\n  readonly nativeStream: MediaStream;\n  readonly id: string;\n\n  readonly tracks = new Array<HMSTrack>();\n\n  constructor(nativeStream: MediaStream) {\n    this.nativeStream = nativeStream;\n    this.id = nativeStream.id;\n  }\n}\n","export enum HMSVideoCodec {\n  VP8 = 'vp8',\n  VP9 = 'vp9',\n  H264 = 'h264',\n}\n\nexport enum HMSAudioCodec {\n  OPUS = 'opus',\n}\n\nexport interface HMSAudioTrackSettings {\n  volume: number;\n  codec: HMSAudioCodec;\n  maxBitrate: number;\n  deviceId: string;\n  advanced: Array<MediaTrackConstraintSet>;\n}\n\nexport interface HMSVideoTrackSettings {\n  width: number;\n  height: number;\n  codec: HMSVideoCodec;\n  maxFramerate: number;\n  maxBitrate?: number;\n  deviceId?: string;\n  advanced: Array<MediaTrackConstraintSet>;\n}\n","export enum HMSPlaylistType {\n  audio = 'audio',\n  video = 'video',\n}\n\nexport interface HMSPlaylistItem<T> {\n  name: string;\n  metadata?: T;\n  id: string;\n  url: string;\n  type: HMSPlaylistType;\n  /**\n   * duration in seconds\n   */\n  duration?: number;\n}\n\nexport interface HMSPlaylistProgressEvent {\n  type: HMSPlaylistType;\n  progress: number;\n}\n\nexport interface HMSPlaylistManager {\n  getList<T>(type: HMSPlaylistType): HMSPlaylistItem<T>[];\n  setList<T>(list: HMSPlaylistItem<T>[]): void;\n  playNext(type: HMSPlaylistType): Promise<void>;\n  playPrevious(type: HMSPlaylistType): Promise<void>;\n  removeItem<T>(item: HMSPlaylistItem<T>): void;\n  /**\n   * Seek forward/backward on selected type relative to currentTime\n   * @param value - number in seconds to go forward(if negative, it goes backwards)\n   * @param {HMSPlaylistType} type\n   */\n  seek(value: number, type: HMSPlaylistType): void;\n  /**\n   * Seek forward/backward on selected type - absolute value\n   * @param value - point in playlist item to go to\n   * @param {HMSPlaylistType} type\n   */\n  seekTo(value: number, type: HMSPlaylistType): void;\n  /**\n   * set volume on the selected type\n   * @param value - number between 0-100\n   * @param type\n   */\n  setVolume(value: number, type: HMSPlaylistType): void;\n  /**\n   * Get volume of selected type, between 0-100\n   * @param type\n   */\n  getVolume(type: HMSPlaylistType): number;\n  isPlaying(type: HMSPlaylistType): boolean;\n  getCurrentIndex(type: HMSPlaylistType): number;\n  getCurrentSelection<T>(type: HMSPlaylistType): HMSPlaylistItem<T> | undefined;\n  /**\n   * Returns a value between 0-100\n   * @param {HMSPlaylistType} type\n   */\n  getCurrentProgress(type: HMSPlaylistType): number;\n  /**\n   * Get the currentTime of audio/video based on type\n   * @param {HMSPlaylistType} type\n   */\n  getCurrentTime(type: HMSPlaylistType): number;\n  setEnabled(enabled: boolean, info: { id: string; type: HMSPlaylistType }): Promise<void>;\n  stop(type: HMSPlaylistType): Promise<void>;\n  /**\n   * Subscriber to progress event with a callback\n   * @param fn\n   */\n  onProgress(fn: (event: HMSPlaylistProgressEvent) => void): void;\n  /**\n   * This will be called when a new track is played\n   * @param fn\n   */\n  onNewTrackStart<T>(fn: (item: HMSPlaylistItem<T>) => void): void;\n\n  onPlaylistEnded(fn: (type: HMSPlaylistType) => void): void;\n}\n","export enum HMSTrackType {\n  AUDIO = 'audio',\n  VIDEO = 'video',\n}\n","import HMSSubscribeConnection from '../../connection/subscribe';\nimport HMSMediaStream from './HMSMediaStream';\nimport HMSLogger from '../../utils/logger';\nimport { HMSSimulcastLayer } from '../../interfaces';\n\n/** @internal */\nexport default class HMSRemoteStream extends HMSMediaStream {\n  private readonly connection: HMSSubscribeConnection;\n  private audio = true;\n  private video = HMSSimulcastLayer.NONE;\n  private frameRate = HMSSimulcastLayer.HIGH;\n\n  constructor(nativeStream: MediaStream, connection: HMSSubscribeConnection) {\n    super(nativeStream);\n    this.connection = connection;\n  }\n\n  setAudio(enabled: boolean) {\n    if (this.audio === enabled) return;\n\n    this.audio = enabled;\n    this.syncWithApiChannel();\n  }\n\n  setVideo(layer: HMSSimulcastLayer) {\n    if (this.video === layer) {\n      HMSLogger.d(`[Remote stream] ${this.id}`, `Already on ${layer} layer`);\n      return;\n    }\n\n    this.video = layer;\n    HMSLogger.d(`[Remote stream] ${this.id}`, `Switching to ${layer} layer`);\n    this.syncWithApiChannel();\n  }\n\n  getSimulcastLayer() {\n    return this.video;\n  }\n\n  isAudioSubscribed() {\n    return this.audio;\n  }\n\n  private syncWithApiChannel() {\n    const data = {\n      streamId: this.id,\n      video: this.video,\n      audio: this.audio,\n      framerate: this.frameRate,\n    };\n    this.connection.sendOverApiDataChannel(JSON.stringify(data));\n  }\n}\n","import HMSLogger from '../utils/logger';\n\nexport interface DataChannelObserver {\n  onMessage(value: string): void;\n}\n\nexport default class HMSDataChannel {\n  private readonly TAG = 'HMSDataChannel';\n  private readonly nativeChannel: RTCDataChannel;\n  private readonly observer: DataChannelObserver;\n  private readonly metadata: string;\n\n  public get id() {\n    return this.nativeChannel.id;\n  }\n\n  public get label() {\n    return this.nativeChannel.label;\n  }\n\n  public get readyState() {\n    return this.nativeChannel.readyState;\n  }\n\n  constructor(nativeChannel: RTCDataChannel, observer: DataChannelObserver, metadata: string = '') {\n    this.nativeChannel = nativeChannel;\n    this.observer = observer;\n    this.metadata = metadata;\n\n    nativeChannel.onmessage = (e) => {\n      // HMSLogger.d(this.TAG, `[${this.metadata}] onMessage: label=${this.label}, message=${e.data}`);\n      this.observer.onMessage(e.data);\n    };\n  }\n\n  send(message: string) {\n    HMSLogger.d(this.TAG, `[${this.metadata}] Sending [size=${message.length}] message=${message}`);\n    this.nativeChannel.send(message);\n  }\n\n  close() {\n    this.nativeChannel.close();\n  }\n}\n","import HMSMediaStream from '../streams/HMSMediaStream';\nimport { HMSTrackType } from './HMSTrackType';\n\nexport type HMSTrackSource = 'regular' | 'screen' | 'plugin' | 'audioplaylist' | 'videoplaylist' | string;\n\nexport abstract class HMSTrack {\n  /**\n   * @internal\n   */\n  readonly stream: HMSMediaStream;\n  source?: HMSTrackSource;\n  peerId?: string;\n\n  /** The native mediastream track, for local, this changes on mute/unmute(for video),\n   * and on device change.\n   * @internal */\n  nativeTrack: MediaStreamTrack;\n\n  /**\n   * Firefox doesn't respect the track id as sent from the backend when calling peerconnection.ontrack callback. This\n   * breaks correlation of future track updates from backend. So we're storing the sdp track id as present in the\n   * original offer along with the track as well and will let this override the native track id for any correlation\n   * purpose.\n   * This applies for remote tracks only.\n   * @internal */\n  private sdpTrackId?: string;\n\n  /**\n   * @internal\n   * The local track id is changed on mute/unmute or when device id changes, this is abstracted as an internal\n   * detail of HMSTrack and the variable is used for this enacapsulation where the first track id is remembered\n   * and treated as the fixed track id for this HMSTrack. This simplifies things for the user of the sdk who\n   * do not have to worry about changing track IDs.\n   * This applies for local tracks only.\n   */\n  private firstTrackId?: string;\n\n  abstract readonly type: HMSTrackType;\n\n  public get enabled(): boolean {\n    return this.nativeTrack.enabled;\n  }\n\n  /**\n   * firstTrackId => encapsulates change in local track ids\n   * sdpTrackId => fixes remote track updates correlation on firefox\n   */\n  public get trackId(): string {\n    return this.firstTrackId || this.sdpTrackId || this.nativeTrack.id;\n  }\n\n  getMediaTrackSettings(): MediaTrackSettings {\n    return this.nativeTrack.getSettings();\n  }\n\n  async setEnabled(value: boolean): Promise<void> {\n    this.nativeTrack.enabled = value;\n  }\n\n  protected constructor(stream: HMSMediaStream, track: MediaStreamTrack, source?: HMSTrackSource) {\n    this.stream = stream;\n    this.nativeTrack = track;\n    this.source = source;\n  }\n\n  /**\n   * @internal\n   */\n  setSdpTrackId(sdpTrackId: string) {\n    this.sdpTrackId = sdpTrackId;\n  }\n\n  /**\n   * @internal\n   */\n  protected setFirstTrackId(trackId: string) {\n    this.firstTrackId = trackId;\n  }\n\n  /**\n   * @internal\n   * take care of -\n   * 1. https://bugs.chromium.org/p/chromium/issues/detail?id=1232649\n   * 2. stopping any tracks\n   * 3. plugins related cleanups and stopping\n   */\n  cleanup() {\n    this.nativeTrack?.stop();\n  }\n}\n","import { HMSTrack, HMSTrackSource } from './HMSTrack';\nimport { HMSTrackType } from './HMSTrackType';\nimport HMSMediaStream from '../streams/HMSMediaStream';\nimport HMSRemoteStream from '../streams/HMSRemoteStream';\nimport HMSLogger from '../../utils/logger';\n\nexport class HMSAudioTrack extends HMSTrack {\n  readonly type: HMSTrackType = HMSTrackType.AUDIO;\n  private audioElement: HTMLAudioElement | null = null;\n  private outputDevice?: MediaDeviceInfo;\n\n  constructor(stream: HMSMediaStream, track: MediaStreamTrack, source?: string) {\n    super(stream, track, source as HMSTrackSource);\n    if (track.kind !== 'audio') throw new Error(\"Expected 'track' kind = 'audio'\");\n  }\n\n  getVolume() {\n    return this.audioElement ? this.audioElement.volume * 100 : null;\n  }\n\n  setVolume(value: number) {\n    if (value < 0 || value > 100) {\n      throw Error('Please pass a valid number between 0-100');\n    }\n    // Don't subscribe to audio when volume is 0\n    this.subscribeToAudio(value === 0 ? false : this.enabled);\n    if (this.audioElement) {\n      this.audioElement.volume = value / 100;\n    }\n  }\n\n  setAudioElement(element: HTMLAudioElement | null) {\n    this.audioElement = element;\n  }\n\n  /**\n   * @internal\n   * @returns {HTMLAudioElement | null}\n   */\n  getAudioElement(): HTMLAudioElement | null {\n    return this.audioElement;\n  }\n\n  getOutputDevice() {\n    return this.outputDevice;\n  }\n\n  cleanup() {\n    super.cleanup();\n    if (this.audioElement) {\n      this.audioElement.srcObject = null;\n      this.audioElement.remove();\n      this.audioElement = null;\n    }\n  }\n\n  async setOutputDevice(device: MediaDeviceInfo) {\n    if (!this.audioElement) {\n      HMSLogger.d('audio-track', 'no audio element to set output');\n      return;\n    }\n    try {\n      // @ts-ignore\n      if (typeof this.audioElement.setSinkId === 'function') {\n        // @ts-ignore\n        await this.audioElement?.setSinkId(device.deviceId);\n        this.outputDevice = device;\n      }\n    } catch {}\n  }\n\n  /**\n   * removes the track from the audio element of the track\n   * @experimental - Not production ready\n   */\n  removeSink() {\n    // @ts-ignore\n    if (this.audioElement && window.HMS?.AUDIO_SINK) {\n      this.audioElement.srcObject = null;\n      this.subscribeToAudio(false);\n    }\n  }\n\n  /**\n   * add track if not already added\n   * @experimental - Not production ready\n   */\n  addSink() {\n    // @ts-ignore\n    if (!this.nativeTrack || !this.audioElement || !window.HMS?.AUDIO_SINK) {\n      return;\n    }\n    const srcObject = this.audioElement.srcObject;\n    if (srcObject !== null && srcObject instanceof MediaStream) {\n      const existingTrackID = srcObject.getAudioTracks()[0]?.id;\n      if (existingTrackID === this.nativeTrack.id) {\n        // it's already attached, no need to attach again\n        return;\n      }\n    }\n    this.audioElement.srcObject = new MediaStream([this.nativeTrack]);\n    this.subscribeToAudio(true);\n  }\n\n  protected subscribeToAudio(value: boolean) {\n    if (this.stream instanceof HMSRemoteStream) {\n      this.stream.setAudio(value);\n    }\n  }\n}\n","import { HMSAudioTrack } from './HMSAudioTrack';\n\nexport class HMSRemoteAudioTrack extends HMSAudioTrack {\n  async setEnabled(value: boolean): Promise<void> {\n    if (value === this.enabled) return;\n    await super.setEnabled(value);\n    this.subscribeToAudio(value);\n  }\n}\n","import { HMSTrack, HMSTrackSource } from './HMSTrack';\nimport { HMSTrackType } from './HMSTrackType';\nimport HMSMediaStream from '../streams/HMSMediaStream';\n\nexport class HMSVideoTrack extends HMSTrack {\n  readonly type: HMSTrackType = HMSTrackType.VIDEO;\n  private sinkCount: number = 0;\n\n  hasSinks() {\n    return this.sinkCount > 0;\n  }\n\n  constructor(stream: HMSMediaStream, track: MediaStreamTrack, source?: string) {\n    super(stream, track, source as HMSTrackSource);\n    if (track.kind !== 'video') throw new Error(\"Expected 'track' kind = 'video'\");\n  }\n\n  /**\n   * attaches the track to the passed in video element\n   * @param videoElement\n   */\n  addSink(videoElement: HTMLVideoElement) {\n    this.addSinkInternal(videoElement, this.nativeTrack);\n  }\n\n  /**\n   * removes the track from the passed in video element\n   * @param videoElement\n   */\n  removeSink(videoElement: HTMLVideoElement) {\n    videoElement.srcObject = null;\n    if (this.sinkCount > 0) {\n      this.sinkCount--;\n    }\n  }\n\n  protected addSinkInternal(videoElement: HTMLVideoElement, track: MediaStreamTrack) {\n    const srcObject = videoElement.srcObject;\n    if (srcObject !== null && srcObject instanceof MediaStream) {\n      const existingTrackID = srcObject.getVideoTracks()[0]?.id;\n      if (existingTrackID === track.id) {\n        // it's already attached, attaching again would just cause flickering\n        return;\n      }\n    }\n    videoElement.srcObject = new MediaStream([track]);\n    this.sinkCount++;\n  }\n}\n","import { HMSVideoTrack } from './HMSVideoTrack';\nimport HMSRemoteStream from '../streams/HMSRemoteStream';\nimport { HMSSimulcastLayer, SimulcastLayerDefinition } from '../../interfaces/simulcast-layers';\n\nexport class HMSRemoteVideoTrack extends HMSVideoTrack {\n  private _degraded = false;\n  private _layerDefinitions: SimulcastLayerDefinition[] = [];\n\n  public get degraded() {\n    return this._degraded;\n  }\n\n  async setEnabled(value: boolean): Promise<void> {\n    if (value === this.enabled) return;\n\n    // If remote track is muted when degraded, reset degraded state\n    if (this._degraded && !value) {\n      this._degraded = false;\n    }\n\n    await super.setEnabled(value);\n  }\n\n  preferLayer(layer: HMSSimulcastLayer) {\n    (this.stream as HMSRemoteStream).setVideo(layer);\n  }\n\n  getSimulcastLayer() {\n    return (this.stream as HMSRemoteStream).getSimulcastLayer();\n  }\n\n  addSink(videoElement: HTMLVideoElement) {\n    super.addSink(videoElement);\n    this.updateLayer();\n  }\n\n  removeSink(videoElement: HTMLVideoElement) {\n    super.removeSink(videoElement);\n    this.updateLayer();\n  }\n\n  /**\n   * Method to get available simulcast definitions for the track\n   * @returns {SimulcastLayerDefinition[]}\n   */\n  getSimulcastDefinitions() {\n    // send a clone to store as it will freeze the object from further updates\n    return [...this._layerDefinitions];\n  }\n\n  /** @internal */\n  setSimulcastDefinitons(definitions: SimulcastLayerDefinition[]) {\n    this._layerDefinitions = definitions;\n  }\n\n  /** @internal */\n  setDegraded(value: boolean) {\n    this._degraded = value;\n    this.updateLayer();\n  }\n\n  private updateLayer() {\n    let newLayer = this.hasSinks() ? HMSSimulcastLayer.HIGH : HMSSimulcastLayer.NONE;\n    if (this.degraded) newLayer = HMSSimulcastLayer.NONE;\n    (this.stream as HMSRemoteStream).setVideo(newLayer);\n  }\n}\n","import HMSConnection from '../index';\nimport { ISignal } from '../../signal/ISignal';\nimport ISubscribeConnectionObserver from './ISubscribeConnectionObserver';\nimport { HMSConnectionRole } from '../model';\nimport HMSRemoteStream from '../../media/streams/HMSRemoteStream';\nimport HMSDataChannel from '../HMSDataChannel';\nimport { API_DATA_CHANNEL } from '../../utils/constants';\nimport { HMSRemoteAudioTrack } from '../../media/tracks/HMSRemoteAudioTrack';\nimport { HMSRemoteVideoTrack } from '../../media/tracks/HMSRemoteVideoTrack';\nimport HMSLogger from '../../utils/logger';\nimport { getSdpTrackIdForMid } from '../../utils/session-description';\n\nexport default class HMSSubscribeConnection extends HMSConnection {\n  private readonly TAG = '[HMSSubscribeConnection]';\n  private readonly remoteStreams = new Map<string, HMSRemoteStream>();\n\n  private readonly observer: ISubscribeConnectionObserver;\n  readonly nativeConnection: RTCPeerConnection;\n\n  private pendingMessageQueue: string[] = [];\n\n  private apiChannel?: HMSDataChannel;\n\n  private initNativeConnectionCallbacks() {\n    this.nativeConnection.oniceconnectionstatechange = () => {\n      this.observer.onIceConnectionChange(this.nativeConnection.iceConnectionState);\n    };\n\n    // @TODO(eswar): Remove this. Use iceconnectionstate change with interval and threshold.\n    this.nativeConnection.onconnectionstatechange = () => {\n      this.observer.onConnectionStateChange(this.nativeConnection.connectionState);\n    };\n\n    this.nativeConnection.ondatachannel = (e) => {\n      if (e.channel.label !== API_DATA_CHANNEL) {\n        // TODO: this.observer.onDataChannel(e.channel);\n        return;\n      }\n\n      this.apiChannel = new HMSDataChannel(\n        e.channel,\n        {\n          onMessage: (value: string) => {\n            this.observer.onApiChannelMessage(value);\n          },\n        },\n        `role=${this.role}`,\n      );\n\n      e.channel.onopen = this.handlePendingApiMessages;\n    };\n\n    this.nativeConnection.onicecandidate = (e) => {\n      if (e.candidate !== null) {\n        this.signal.trickle(this.role, e.candidate);\n      }\n    };\n\n    this.nativeConnection.ontrack = (e) => {\n      const stream = e.streams[0];\n      const streamId = stream.id;\n      if (!this.remoteStreams.has(streamId)) {\n        const remote = new HMSRemoteStream(stream, this);\n        this.remoteStreams.set(streamId, remote);\n\n        stream.onremovetrack = (e) => {\n          /*\n           * this match has to be with nativetrack.id instead of track.trackId as the latter refers to sdp track id for\n           * ease of correlating update messages coming from the backend. The two track ids are usually the same, but\n           * can be different for some browsers. checkout sdptrackid field in HMSTrack for more details.\n           */\n          const toRemoveTrackIdx = remote.tracks.findIndex((track) => track.nativeTrack.id === e.track.id);\n          if (toRemoveTrackIdx >= 0) {\n            const toRemoveTrack = remote.tracks[toRemoveTrackIdx];\n            this.observer.onTrackRemove(toRemoveTrack);\n            remote.tracks.splice(toRemoveTrackIdx, 1);\n\n            // If the length becomes 0 we assume that stream is removed entirely\n            if (remote.tracks.length === 0) {\n              this.remoteStreams.delete(streamId);\n            }\n          }\n        };\n      }\n\n      const remote = this.remoteStreams.get(streamId)!;\n      const TrackCls = e.track.kind === 'audio' ? HMSRemoteAudioTrack : HMSRemoteVideoTrack;\n      const track = new TrackCls(remote, e.track);\n      const trackId = getSdpTrackIdForMid(this.remoteDescription, e.transceiver?.mid);\n      trackId && track.setSdpTrackId(trackId);\n      remote.tracks.push(track);\n      this.observer.onTrackAdd(track);\n    };\n  }\n\n  constructor(signal: ISignal, config: RTCConfiguration, observer: ISubscribeConnectionObserver) {\n    super(HMSConnectionRole.Subscribe, signal);\n    this.observer = observer;\n\n    this.nativeConnection = new RTCPeerConnection(config);\n    this.initNativeConnectionCallbacks();\n  }\n\n  sendOverApiDataChannel(message: string) {\n    if (this.apiChannel && this.apiChannel.readyState === 'open') {\n      this.apiChannel.send(message);\n    } else {\n      HMSLogger.w(this.TAG, `API Data channel not ${this.apiChannel ? 'open' : 'present'}, queueing`, message);\n      this.pendingMessageQueue.push(message);\n    }\n  }\n\n  async close() {\n    await super.close();\n    this.apiChannel?.close();\n  }\n\n  private handlePendingApiMessages = () => {\n    if (this.pendingMessageQueue.length > 0) {\n      HMSLogger.d(this.TAG, 'Found pending message queue, sending messages');\n      this.pendingMessageQueue.forEach((msg) => this.sendOverApiDataChannel(msg));\n      this.pendingMessageQueue.length = 0;\n    }\n  };\n}\n","/**\n * Check only for presence(not truthy) of a value.\n * Use in places where 0, false need to be considered valid.\n */\nexport function isPresent(value: any) {\n  return value !== undefined && value !== null;\n}\n","import { UAParser } from 'ua-parser-js';\nimport { version } from './package.alias.json';\n\nexport const parsedUserAgent = new UAParser();\n\nexport const isNode = typeof process !== 'undefined' && process.versions != null && process.versions.node != null;\n\nexport const isBrowser = typeof window !== 'undefined';\n\nconst checkIsSupported = () => {\n  if (isNode) {\n    return false;\n  }\n  // @TODO: Get this from preview/init API from server\n  return true;\n};\n\nexport const isSupported = checkIsSupported();\n\nfunction createUserAgent(): string {\n  if (isNode) {\n    return `hmsclient/${version}`;\n  }\n  const device = parsedUserAgent.getDevice();\n  const browser = parsedUserAgent.getBrowser();\n  const os = parsedUserAgent.getOS();\n\n  if (device.type) {\n    return `hmsclient/${version} ${os.name}/${os.version} (${device.vendor}_${device.type}_/_${browser.name}_${browser.version})`;\n  } else {\n    return `hmsclient/${version} ${os.name}/${os.version} (${browser.name}_${browser.version})`;\n  }\n}\n\nexport const isMobile = () => parsedUserAgent.getDevice().type === 'mobile';\n\nexport const userAgent = createUserAgent();\n","import { HMSAction } from '../../error/ErrorFactory';\n\nexport interface JsonRpcRequest {\n  id: string;\n  method: string;\n  params: Map<string, any>;\n}\n\nexport interface JsonRpcResponse {\n  id: string;\n  result: any;\n  error: {\n    code: number;\n    message: string;\n  };\n}\n\nexport enum HMSSignalMethod {\n  JOIN = 'join',\n  OFFER = 'offer',\n  ANSWER = 'answer',\n  TRICKLE = 'trickle',\n  TRACK_UPDATE = 'track-update',\n  BROADCAST = 'broadcast',\n  ANALYTICS = 'analytics',\n  SERVER_ERROR = 'on-error',\n  SDK_NOTIFICATION = 'sdk-notification',\n  LEAVE = 'leave',\n  END_ROOM = 'end-room',\n  PING = 'ping',\n  ROLE_CHANGE_REQUEST = 'role-change-request',\n  ROLE_CHANGE = 'role-change',\n  TRACK_UPDATE_REQUEST = 'track-update-request',\n  PEER_LEAVE_REQUEST = 'peer-leave-request',\n  CHANGE_TRACK_MUTE_STATE_REQUEST = 'change-track-mute-state-request',\n  START_RTMP_OR_RECORDING_REQUEST = 'rtmp-start',\n  STOP_RTMP_AND_RECORDING_REQUEST = 'rtmp-stop',\n}\n\nexport function convertSignalMethodtoErrorAction(method: HMSSignalMethod): HMSAction {\n  switch (method) {\n    case HMSSignalMethod.JOIN:\n      return HMSAction.JOIN;\n    case HMSSignalMethod.OFFER:\n      return HMSAction.PUBLISH;\n    case HMSSignalMethod.ANSWER:\n      return HMSAction.SUBSCRIBE;\n    case HMSSignalMethod.TRACK_UPDATE:\n      return HMSAction.TRACK;\n    default:\n      return HMSAction.NONE;\n  }\n}\n","import { InitConfig } from './models';\nimport HMSLogger from '../../utils/logger';\nimport { userAgent } from '../../utils/support';\nimport { ErrorFactory, HMSAction } from '../../error/ErrorFactory';\n\nconst TAG = 'InitService';\n\nexport default class InitService {\n  static async fetchInitConfig(\n    token: string,\n    initEndpoint: string = 'https://prod-init.100ms.live',\n    region: string = '',\n  ): Promise<InitConfig> {\n    HMSLogger.d(TAG, `fetchInitConfig: initEndpoint=${initEndpoint} token=${token} region=${region}`);\n    const url = getUrl(initEndpoint, region);\n    let response, config;\n    try {\n      response = await fetch(url, {\n        headers: {\n          Authorization: `Bearer ${token}`,\n        },\n      });\n      const body = await response.json();\n      if (response.status === 404) {\n        throw ErrorFactory.InitAPIErrors.EndpointUnreachable(HMSAction.INIT, body.message || response.statusText);\n      }\n      if (response?.status !== 200) {\n        throw ErrorFactory.InitAPIErrors.ServerErrors(\n          body.code || response.status,\n          HMSAction.INIT,\n          body.message || response?.statusText,\n        );\n      }\n      config = body;\n      HMSLogger.d(TAG, `config is ${JSON.stringify(config, null, 2)}`);\n    } catch (err) {\n      const error = err as Error;\n      if (error.message === 'Failed to fetch') {\n        throw ErrorFactory.InitAPIErrors.ConnectionLost(HMSAction.INIT, error.message);\n      }\n      throw error;\n    }\n    return transformInitConfig(config);\n  }\n}\n\nexport function getUrl(endpoint: string, region?: string) {\n  try {\n    const url = new URL('/init', endpoint);\n\n    if (region && region.trim().length > 0) {\n      url.searchParams.set('region', region.trim());\n    }\n    url.searchParams.set('user_agent', userAgent);\n    return url.toString();\n  } catch (err) {\n    const error = err as Error;\n    HMSLogger.e(TAG, error.name, error.message);\n    throw error;\n  }\n}\n\nexport function transformInitConfig(config: any): InitConfig {\n  return {\n    ...config,\n    rtcConfiguration: { ...config.rtcConfiguration, iceServers: config.rtcConfiguration.ice_servers },\n  };\n}\n","import adapter from 'webrtc-adapter';\nimport { ErrorFactory, HMSAction } from './ErrorFactory';\nimport { HMSException } from './HMSException';\n\nexport enum HMSGetMediaActions {\n  AUDIO = 'audio',\n  VIDEO = 'video',\n  AV = 'audio, video',\n  SCREEN = 'screen',\n}\n\n/**\n * # Edge Cases:\n * - Screenshare error: The problem is when block at OS level, chrome throws NotAllowedError(HMS code - 3001) while firefox throws NotFoundError(HMS code - 3002),\n * we will handle this internally and throw error as User block - 3001 and OS block - 3002 for all browsers.\n * Chrome -\n * User blocked - NotAllowedError - Permission denied\n * System blocked - NotAllowedError - Permission denied by system\n */\nfunction convertMediaErrorToHMSException(err: Error, deviceInfo: string): HMSException {\n  const message = err.message.toLowerCase();\n\n  /**\n   * Note: Adapter detects all chromium browsers as 'chrome'\n   */\n  if (\n    deviceInfo === 'screen' &&\n    adapter.browserDetails.browser === 'chrome' &&\n    err.name === 'NotAllowedError' &&\n    err.message.includes('denied by system')\n  ) {\n    return ErrorFactory.TracksErrors.DeviceNotAvailable(HMSAction.TRACK, deviceInfo, err.message);\n  }\n\n  switch (err.name) {\n    case 'OverconstrainedError':\n      return ErrorFactory.TracksErrors.GenericTrack(HMSAction.TRACK, err.message);\n    case 'NotAllowedError':\n      return ErrorFactory.TracksErrors.CantAccessCaptureDevice(HMSAction.TRACK, deviceInfo, err.message);\n    case 'NotFoundError':\n      return ErrorFactory.TracksErrors.DeviceNotAvailable(HMSAction.TRACK, deviceInfo, err.message);\n    case 'NotReadableError':\n      return ErrorFactory.TracksErrors.DeviceInUse(HMSAction.TRACK, deviceInfo, err.message);\n    case 'TypeError':\n      return ErrorFactory.TracksErrors.NothingToReturn(HMSAction.TRACK, err.message);\n    default:\n      if (message.includes('device not found')) {\n        return ErrorFactory.TracksErrors.DeviceNotAvailable(HMSAction.TRACK, deviceInfo, err.message);\n      } else if (message.includes('permission denied')) {\n        return ErrorFactory.TracksErrors.CantAccessCaptureDevice(HMSAction.TRACK, deviceInfo, err.message);\n      } else {\n        return ErrorFactory.TracksErrors.GenericTrack(HMSAction.TRACK, err.message);\n      }\n  }\n}\n\nexport function BuildGetMediaError(err: Error, deviceInfo: string): HMSException {\n  const exception = convertMediaErrorToHMSException(err, deviceInfo);\n  exception.addNativeError(err);\n  return exception;\n}\n","import { BuildGetMediaError, HMSGetMediaActions } from '../error/utils';\nimport { HMSAudioTrackSettings, HMSVideoTrackSettings } from '../media/settings';\n\nexport async function getAudioTrack(settings: HMSAudioTrackSettings): Promise<MediaStreamTrack> {\n  try {\n    const stream = await navigator.mediaDevices.getUserMedia({\n      audio: settings ? settings.toConstraints() : false,\n    });\n    return stream.getAudioTracks()[0];\n  } catch (err) {\n    throw BuildGetMediaError(err as Error, HMSGetMediaActions.AUDIO);\n  }\n}\n\nexport async function getVideoTrack(settings: HMSVideoTrackSettings): Promise<MediaStreamTrack> {\n  try {\n    const stream = await navigator.mediaDevices.getUserMedia({\n      video: settings ? settings.toConstraints() : false,\n    });\n    return stream.getVideoTracks()[0];\n  } catch (err) {\n    throw BuildGetMediaError(err as Error, HMSGetMediaActions.VIDEO);\n  }\n}\n\n// To differentiate between normal track and empty track.\nexport function isEmptyTrack(track: MediaStreamTrack) {\n  // Firefox gives '' as label for empty track(created from audio context)\n  return 'canvas' in track || track.label === 'MediaStreamAudioDestinationNode' || track.label === '';\n}\n\nlet blankCanvas: any;\n\n// the dimensions of the passed in track are used to create the empty video track\n// a dummy change(toggling a pixel value) is done periodically to keep on sending bytes\nexport function getEmptyVideoTrack(prevTrack?: MediaStreamTrack): MediaStreamTrack {\n  const width = prevTrack?.getSettings()?.width || 320;\n  const height = prevTrack?.getSettings()?.height || 240;\n  const frameRate = 10; // fps TODO: experiment, see if this can be reduced\n  if (!blankCanvas) {\n    blankCanvas = Object.assign(document.createElement('canvas'), { width, height });\n    blankCanvas.getContext('2d')?.fillRect(0, 0, width, height);\n  }\n  const stream = blankCanvas.captureStream(frameRate);\n  const emptyTrack = stream.getVideoTracks()[0];\n  const intervalID = setInterval(() => {\n    if (emptyTrack.readyState === 'ended') {\n      clearInterval(intervalID);\n      return;\n    }\n    const ctx = blankCanvas.getContext('2d');\n    if (ctx) {\n      const pixel = ctx.getImageData(0, 0, 1, 1).data;\n      const red = pixel[0] === 0 ? 1 : 0; // toggle red in pixel\n      ctx.fillStyle = `rgb(${red}, 0, 0)`;\n      ctx.fillRect(0, 0, 1, 1);\n    }\n  }, 1000 / frameRate);\n  emptyTrack.onended = () => {\n    clearInterval(intervalID);\n  };\n  emptyTrack.enabled = false;\n  return emptyTrack;\n}\n\nexport function getEmptyAudioTrack(): MediaStreamTrack {\n  const ctx = new AudioContext();\n  const oscillator = ctx.createOscillator();\n  const dst = oscillator.connect(ctx.createMediaStreamDestination());\n  oscillator.start();\n  // @ts-expect-error\n  const emptyTrack = dst.stream.getAudioTracks()[0];\n  emptyTrack.enabled = false;\n  return emptyTrack;\n}\n","import { v4 as uuid } from 'uuid';\nimport { ISignal } from '../ISignal';\nimport { ISignalEventsObserver } from '../ISignalEventsObserver';\nimport {\n  Track,\n  AcceptRoleChangeParams,\n  RequestForRoleChangeParams,\n  TrackUpdateRequestParams,\n  RemovePeerRequest,\n  MultiTrackUpdateRequestParams,\n  StartRTMPOrRecordingRequestParams,\n} from '../interfaces';\nimport { HMSConnectionRole, HMSTrickle } from '../../connection/model';\nimport { convertSignalMethodtoErrorAction, HMSSignalMethod, JsonRpcRequest, JsonRpcResponse } from './models';\nimport { PromiseCallbacks } from '../../utils/promise';\nimport HMSLogger from '../../utils/logger';\nimport { ErrorFactory, HMSAction } from '../../error/ErrorFactory';\nimport AnalyticsEvent from '../../analytics/AnalyticsEvent';\nimport { DEFAULT_SIGNAL_PING_TIMEOUT, SIGNAL_PING_INTERVAL } from '../../utils/constants';\nimport Message from '../../sdk/models/HMSMessage';\nimport { HMSException } from '../../error/HMSException';\n\nexport default class JsonRpcSignal implements ISignal {\n  private readonly TAG = '[ SIGNAL ]: ';\n  readonly observer: ISignalEventsObserver;\n\n  /**\n   * Sometimes before [join] is completed, there could be a lot of trickles\n   * Sending [HMSTrickle]` before [join] web socket message leads to\n   * error: [500] no rtc transport exists for this Peer\n   *\n   * We keep a list of pending trickles and send them immediately after [join]\n   * is done.\n   */\n  private isJoinCompleted: boolean = false;\n  private pendingTrickle: Array<HMSTrickle> = [];\n\n  private socket: WebSocket | null = null;\n\n  private callbacks = new Map<string, PromiseCallbacks<string>>();\n\n  private _isConnected: boolean = false;\n\n  public get isConnected(): boolean {\n    return this._isConnected;\n  }\n\n  private id = 0;\n\n  public set isConnected(newValue: boolean) {\n    HMSLogger.d(this.TAG, 'isConnected set', { id: this.id, old: this._isConnected, new: newValue });\n    if (this._isConnected === newValue) return;\n\n    if (this._isConnected && !newValue) {\n      // went offline\n      this._isConnected = newValue;\n      this.observer.onOffline();\n    } else if (!this._isConnected && newValue) {\n      // went online\n      this._isConnected = newValue;\n      this.observer.onOnline();\n    }\n  }\n\n  constructor(observer: ISignalEventsObserver) {\n    this.observer = observer;\n    window.addEventListener('offline', () => {\n      HMSLogger.d(this.TAG, 'Window network offline');\n      this.isConnected = false;\n    });\n\n    window.addEventListener('online', () => {\n      HMSLogger.d(this.TAG, 'Window network online');\n    });\n\n    this.onCloseHandler = this.onCloseHandler.bind(this);\n    this.onMessageHandler = this.onMessageHandler.bind(this);\n  }\n\n  private async call<T>(method: string, params: any): Promise<T> {\n    const id = uuid();\n    const message = { method, params, id, jsonrpc: '2.0' } as JsonRpcRequest;\n\n    this.socket!.send(JSON.stringify(message));\n\n    try {\n      const response = await new Promise<any>((resolve, reject) => {\n        this.callbacks.set(id, { resolve, reject });\n      });\n\n      return response;\n    } catch (ex) {\n      const error = ex as HMSException;\n      throw ErrorFactory.WebsocketMethodErrors.ServerErrors(\n        Number((error as HMSException).code),\n        convertSignalMethodtoErrorAction(method as HMSSignalMethod),\n        (error as HMSException).message,\n      );\n    }\n  }\n\n  private notify(method: string, params: any) {\n    const message = { method, params };\n\n    this.socket!.send(JSON.stringify(message));\n  }\n\n  open(uri: string): Promise<void> {\n    return new Promise((resolve, reject) => {\n      // cleanup\n      if (this.socket) {\n        this.socket.removeEventListener('close', this.onCloseHandler);\n        this.socket.removeEventListener('message', this.onMessageHandler);\n      }\n\n      this.socket = new WebSocket(uri); // @DISCUSS: Inject WebSocket as a dependency so that it can be easier to mock and test\n\n      const errorListener = (error: Event) => {\n        HMSLogger.d(this.TAG, 'Error opening socket connection', error);\n        reject(\n          ErrorFactory.WebSocketConnectionErrors.GenericConnect(HMSAction.JOIN, 'Error opening socket connection'),\n        );\n      };\n      this.socket.addEventListener('error', errorListener);\n\n      const openHandler = () => {\n        resolve();\n        this.isConnected = true;\n        this.id++;\n        this.socket!.removeEventListener('open', openHandler);\n        this.socket!.removeEventListener('error', errorListener);\n        this.pingPongLoop(this.id);\n      };\n\n      this.socket.addEventListener('open', openHandler);\n      this.socket.addEventListener('close', this.onCloseHandler);\n      this.socket.addEventListener('message', this.onMessageHandler);\n    });\n  }\n\n  async close(): Promise<void> {\n    const p = new Promise<void>((resolve) => {\n      this.socket!.addEventListener('close', () => resolve());\n    });\n    // @TODO: Clean up: Remove event listeners.\n\n    // For `1000` Refer: https://tools.ietf.org/html/rfc6455#section-7.4.1\n    this.socket!.close(1000, 'Normal Close');\n    this.isConnected = false;\n    this.socket!.removeEventListener('close', this.onCloseHandler);\n    this.socket!.removeEventListener('message', this.onMessageHandler);\n    return p;\n  }\n\n  async join(\n    name: string,\n    data: string,\n    offer: RTCSessionDescriptionInit,\n    disableVidAutoSub: boolean,\n  ): Promise<RTCSessionDescriptionInit> {\n    const params = { name, disableVidAutoSub, data, offer };\n    const response: RTCSessionDescriptionInit = await this.call(HMSSignalMethod.JOIN, params);\n\n    this.isJoinCompleted = true;\n    this.pendingTrickle.forEach(({ target, candidate }) => this.trickle(target, candidate));\n    this.pendingTrickle.length = 0;\n\n    HMSLogger.d(this.TAG, `join: response=${JSON.stringify(response, null, 1)}`);\n    return response;\n  }\n\n  trickle(target: HMSConnectionRole, candidate: RTCIceCandidateInit) {\n    if (this.isJoinCompleted) {\n      this.notify(HMSSignalMethod.TRICKLE, { target, candidate });\n    } else {\n      this.pendingTrickle.push({ target, candidate });\n    }\n  }\n\n  async offer(desc: RTCSessionDescriptionInit, tracks: Map<string, any>): Promise<RTCSessionDescriptionInit> {\n    const response = await this.call(HMSSignalMethod.OFFER, {\n      desc,\n      tracks: Object.fromEntries(tracks),\n    });\n    return response as RTCSessionDescriptionInit;\n  }\n\n  answer(desc: RTCSessionDescriptionInit) {\n    this.notify(HMSSignalMethod.ANSWER, { desc });\n  }\n\n  trackUpdate(tracks: Map<string, Track>) {\n    this.notify(HMSSignalMethod.TRACK_UPDATE, { version: '1.0', tracks: Object.fromEntries(tracks) });\n  }\n\n  async broadcast(message: Message) {\n    await this.call(HMSSignalMethod.BROADCAST, { version: '1.0', ...message.toSignalParams() });\n  }\n\n  recordStart() {}\n\n  recordEnd() {}\n\n  leave() {\n    this.notify(HMSSignalMethod.LEAVE, { version: '1.0' });\n  }\n\n  async endRoom(lock: boolean, reason: string) {\n    await this.call(HMSSignalMethod.END_ROOM, { lock, reason });\n  }\n\n  sendEvent(event: AnalyticsEvent) {\n    if (!this.isConnected) {\n      throw Error(`${this.TAG} not connected. Could not send event ${event}`);\n    }\n    this.notify(HMSSignalMethod.ANALYTICS, event.toSignalParams());\n  }\n\n  ping(timeout: number): Promise<number> {\n    const pingTime = Date.now();\n    const timer: Promise<number> = new Promise((resolve) => {\n      setTimeout(() => {\n        resolve(Date.now() - pingTime);\n      }, timeout + 1);\n    });\n    const pongTimeDiff = this.call(HMSSignalMethod.PING, { timestamp: pingTime })\n      .then(() => Date.now() - pingTime)\n      .catch(() => Date.now() - pingTime);\n\n    return Promise.race([timer, pongTimeDiff]);\n  }\n\n  async requestRoleChange(params: RequestForRoleChangeParams) {\n    await this.call(HMSSignalMethod.ROLE_CHANGE_REQUEST, params);\n  }\n\n  async acceptRoleChangeRequest(params: AcceptRoleChangeParams) {\n    await this.call(HMSSignalMethod.ROLE_CHANGE, params);\n  }\n\n  async requestTrackStateChange(params: TrackUpdateRequestParams) {\n    await this.call(HMSSignalMethod.TRACK_UPDATE_REQUEST, params);\n  }\n\n  async requestMultiTrackStateChange(params: MultiTrackUpdateRequestParams) {\n    await this.call(HMSSignalMethod.CHANGE_TRACK_MUTE_STATE_REQUEST, params);\n  }\n\n  async removePeer(params: RemovePeerRequest) {\n    await this.call(HMSSignalMethod.PEER_LEAVE_REQUEST, params);\n  }\n\n  async startRTMPOrRecording(params: StartRTMPOrRecordingRequestParams) {\n    await this.call(HMSSignalMethod.START_RTMP_OR_RECORDING_REQUEST, { version: '1.0', ...params });\n  }\n\n  async stopRTMPAndRecording() {\n    await this.call(HMSSignalMethod.STOP_RTMP_AND_RECORDING_REQUEST, { version: '1.0' });\n  }\n\n  private onCloseHandler(event: CloseEvent) {\n    HMSLogger.d(`Websocket closed code=${event.code}`);\n    this.isConnected = false;\n    // https://stackoverflow.com/questions/18803971/websocket-onerror-how-to-read-error-description\n\n    // @DISCUSS: onOffline would have thrown error already.\n    // if (event.code !== 1000) {\n    //   HMSLogger.e(`Websocket closed code=${event.code}, reason=${event.reason}`);\n    //   // 1000 code indicated `Normal Closure` [https://tools.ietf.org/html/rfc6455#section-7.4.1]\n    //   const error = ErrorFactory.WebSocketConnectionErrors.WebSocketConnectionLost(\n    //     HMSAction.INIT,\n    //     `${event.reason} [${event.code}]`,\n    //   );\n    //   this.observer.onFailure(error);\n    // }\n  }\n\n  private onMessageHandler(event: MessageEvent) {\n    const text: string = event.data;\n    const response = JSON.parse(text);\n\n    if (response.hasOwnProperty('id')) {\n      /** This is a response to [call] */\n      const typedResponse = response as JsonRpcResponse;\n      const id: string = typedResponse.id;\n      if (this.callbacks.has(id)) {\n        const cb = this.callbacks.get(id)!;\n        this.callbacks.delete(id);\n        if (typedResponse.result) {\n          cb.resolve(typedResponse.result);\n        } else {\n          cb.reject(typedResponse.error);\n        }\n      } else {\n        this.observer.onNotification(typedResponse);\n      }\n    } else if (response.hasOwnProperty('method')) {\n      if (response.method === HMSSignalMethod.OFFER) {\n        this.observer.onOffer(response.params);\n      } else if (response.method === HMSSignalMethod.TRICKLE) {\n        this.observer.onTrickle(response.params);\n      } else if (response.method === HMSSignalMethod.SERVER_ERROR) {\n        this.observer.onServerError(\n          ErrorFactory.WebsocketMethodErrors.ServerErrors(\n            Number(response.params.code),\n            HMSAction.NONE,\n            response.params.message,\n          ),\n        );\n      } else {\n        this.observer.onNotification(response);\n      }\n    } else throw Error(`WebSocket message has no 'method' or 'id' field, message=${response}`);\n  }\n\n  private async pingPongLoop(id: number) {\n    const pingTimeout = DEFAULT_SIGNAL_PING_TIMEOUT;\n    if (this.isConnected) {\n      const pongTimeDiff = await this.ping(pingTimeout);\n      if (pongTimeDiff > pingTimeout) {\n        HMSLogger.d(this.TAG, 'Pong timeout', { id });\n        if (this.id === id) {\n          this.isConnected = false;\n        }\n      } else {\n        setTimeout(() => this.pingPongLoop(id), SIGNAL_PING_INTERVAL);\n      }\n    }\n  }\n}\n","import { HMSAudioTrackSettings as IHMSAudioTrackSettings, HMSAudioCodec } from '../../interfaces';\nimport { IAnalyticsPropertiesProvider } from '../../analytics/IAnalyticsPropertiesProvider';\n\nexport class HMSAudioTrackSettingsBuilder {\n  private _volume: number = 1.0;\n  private _codec: HMSAudioCodec = HMSAudioCodec.OPUS;\n  private _maxBitrate: number = 32;\n  private _deviceId: string = 'default';\n  private _advanced: Array<MediaTrackConstraintSet> = [\n    // @ts-ignore\n    { googEchoCancellation: { exact: true } },\n    // @ts-ignore\n    { googExperimentalEchoCancellation: { exact: true } },\n    // @ts-ignore\n    { autoGainControl: { exact: true } },\n    // @ts-ignore\n    { noiseSuppression: { exact: true } },\n    // @ts-ignore\n    { googHighpassFilter: { exact: true } },\n    // @ts-ignore\n    { googAudioMirroring: { exact: true } },\n  ];\n\n  volume(volume: number) {\n    if (!(0.0 <= volume && volume <= 1.0)) throw Error('volume can only be in range [0.0, 1.0]');\n    this._volume = volume;\n    return this;\n  }\n\n  codec(codec: HMSAudioCodec) {\n    this._codec = codec;\n    return this;\n  }\n\n  maxBitrate(maxBitrate: number) {\n    if (maxBitrate <= 0) throw Error('maxBitrate should be >= 1');\n    this._maxBitrate = maxBitrate;\n    return this;\n  }\n\n  deviceId(deviceId: string) {\n    // TODO: Validate if device-id is OK\n    this._deviceId = deviceId;\n    return this;\n  }\n\n  advanced(advanced: Array<MediaTrackConstraintSet>) {\n    this._advanced = advanced;\n    return this;\n  }\n\n  build() {\n    return new HMSAudioTrackSettings(this._volume, this._codec, this._maxBitrate, this._deviceId, this._advanced);\n  }\n}\n\nexport class HMSAudioTrackSettings implements IHMSAudioTrackSettings, IAnalyticsPropertiesProvider {\n  readonly volume: number;\n  readonly codec: HMSAudioCodec;\n  readonly maxBitrate: number;\n  readonly deviceId: string;\n  readonly advanced: Array<MediaTrackConstraintSet>;\n\n  constructor(\n    volume: number,\n    codec: HMSAudioCodec,\n    maxBitrate: number,\n    deviceId: string,\n    advanced: Array<MediaTrackConstraintSet>,\n  ) {\n    this.volume = volume;\n    this.codec = codec;\n    this.maxBitrate = maxBitrate;\n    this.deviceId = deviceId;\n    this.advanced = advanced;\n  }\n\n  toConstraints(): MediaTrackConstraints {\n    return {\n      deviceId: this.deviceId,\n      advanced: this.advanced,\n    };\n  }\n\n  toAnalyticsProperties() {\n    return {\n      audio_bitrate: this.maxBitrate,\n      audio_codec: this.codec,\n    };\n  }\n}\n","import { IAnalyticsPropertiesProvider } from '../../analytics/IAnalyticsPropertiesProvider';\nimport { HMSVideoTrackSettings as IHMSVideoTrackSettings, HMSVideoCodec } from '../../interfaces';\n\nexport class HMSVideoTrackSettingsBuilder {\n  private _width: number = 320;\n  private _height: number = 180;\n  private _codec: HMSVideoCodec = HMSVideoCodec.VP8;\n  private _maxFramerate: number = 30;\n  private _maxBitrate?: number = 150;\n  private _deviceId?: string;\n  private _advanced: Array<MediaTrackConstraintSet> = [];\n\n  setWidth(width: number) {\n    this._width = width;\n    return this;\n  }\n\n  setHeight(height: number) {\n    this._height = height;\n    return this;\n  }\n\n  codec(codec: HMSVideoCodec) {\n    this._codec = codec;\n    return this;\n  }\n\n  maxFramerate(maxFramerate: number) {\n    if (maxFramerate <= 0) throw Error('maxFramerate should be >= 1');\n    this._maxFramerate = maxFramerate;\n    return this;\n  }\n\n  /**\n   * @param useDefault Ignored if maxBitrate is valid.\n   * If true and maxBitrate is undefined - sets a default value.\n   * If false and maxBitrate is undefined - sets undefined.\n   */\n  maxBitrate(maxBitrate?: number, useDefault = true) {\n    if (typeof maxBitrate === 'number' && maxBitrate <= 0) throw Error('maxBitrate should be >= 1');\n    this._maxBitrate = maxBitrate;\n    if (!this._maxBitrate && useDefault) this._maxBitrate = 150_000;\n    return this;\n  }\n\n  deviceId(deviceId: string) {\n    // TODO: Validate if device-id is OK\n    this._deviceId = deviceId;\n    return this;\n  }\n\n  advanced(advanced: Array<MediaTrackConstraintSet>) {\n    this._advanced = advanced;\n    return this;\n  }\n\n  build() {\n    return new HMSVideoTrackSettings(\n      this._width,\n      this._height,\n      this._codec,\n      this._maxFramerate,\n      this._deviceId,\n      this._advanced,\n      this._maxBitrate,\n    );\n  }\n}\n\nexport class HMSVideoTrackSettings implements IHMSVideoTrackSettings, IAnalyticsPropertiesProvider {\n  readonly width: number;\n  readonly height: number;\n  readonly codec: HMSVideoCodec;\n  readonly maxFramerate: number;\n  readonly maxBitrate?: number;\n  readonly deviceId?: string;\n  readonly advanced: Array<MediaTrackConstraintSet>;\n\n  constructor(\n    width: number,\n    height: number,\n    codec: HMSVideoCodec,\n    maxFramerate: number,\n    deviceId: string | undefined,\n    advanced: Array<MediaTrackConstraintSet>,\n    maxBitrate?: number,\n  ) {\n    this.width = width;\n    this.height = height;\n    this.codec = codec;\n    this.maxFramerate = maxFramerate;\n    this.maxBitrate = maxBitrate;\n    this.deviceId = deviceId;\n    this.advanced = advanced;\n  }\n\n  toConstraints(): MediaTrackConstraints {\n    return {\n      width: this.width,\n      height: this.height,\n      frameRate: this.maxFramerate,\n      deviceId: this.deviceId,\n    };\n  }\n\n  toAnalyticsProperties() {\n    return {\n      width: this.width,\n      height: this.height,\n      video_bitrate: this.maxBitrate,\n      framerate: this.maxFramerate,\n      video_codec: this.codec,\n    };\n  }\n}\n","import { HMSVideoTrackSettings, HMSVideoTrackSettingsBuilder } from './HMSVideoTrackSettings';\nimport { HMSAudioTrackSettings, HMSAudioTrackSettingsBuilder } from './HMSAudioTrackSettings';\nimport { ErrorFactory, HMSAction } from '../../error/ErrorFactory';\nimport { IAnalyticsPropertiesProvider } from '../../analytics/IAnalyticsPropertiesProvider';\n\nexport class HMSTrackSettingsBuilder {\n  private _video: HMSVideoTrackSettings | null = new HMSVideoTrackSettingsBuilder().build();\n  private _audio: HMSAudioTrackSettings | null = new HMSAudioTrackSettingsBuilder().build();\n  private _screen: HMSVideoTrackSettings | null = new HMSVideoTrackSettingsBuilder().build();\n  private _simulcast = false;\n\n  video(video: HMSVideoTrackSettings | null) {\n    this._video = video;\n    return this;\n  }\n\n  audio(audio: HMSAudioTrackSettings | null) {\n    this._audio = audio;\n    return this;\n  }\n\n  screen(screen: HMSVideoTrackSettings | null) {\n    this._screen = screen;\n    return this;\n  }\n\n  simulcast(enabled: boolean) {\n    this._simulcast = enabled;\n    return this;\n  }\n\n  build() {\n    if (this._audio === null && this._video === null) {\n      throw ErrorFactory.TracksErrors.NothingToReturn(HMSAction.TRACK);\n    }\n\n    if (this._video === null && this._simulcast) {\n      throw ErrorFactory.TracksErrors.InvalidVideoSettings(\n        HMSAction.TRACK,\n        'Cannot enable simulcast when no video settings are provided',\n      );\n    }\n\n    return new HMSTrackSettings(this._video, this._audio, this._simulcast, this._screen || undefined);\n  }\n}\n\nexport class HMSTrackSettings implements IAnalyticsPropertiesProvider {\n  readonly video: HMSVideoTrackSettings | null;\n  readonly audio: HMSAudioTrackSettings | null;\n  readonly screen: HMSVideoTrackSettings | null;\n  readonly simulcast: boolean;\n\n  constructor(\n    video: HMSVideoTrackSettings | null,\n    audio: HMSAudioTrackSettings | null,\n    simulcast: boolean,\n    screen: HMSVideoTrackSettings | null = null,\n  ) {\n    this.video = video;\n    this.audio = audio;\n    this.simulcast = simulcast;\n    this.screen = screen;\n  }\n\n  toAnalyticsProperties() {\n    let properties = {\n      audio_enabled: this.audio !== null,\n      video_enabled: this.video !== null,\n    };\n\n    if (this.audio) {\n      properties = { ...this.audio.toAnalyticsProperties(), ...properties };\n    }\n\n    if (this.video) {\n      properties = { ...this.video.toAnalyticsProperties(), ...properties };\n    }\n\n    return properties;\n  }\n}\n","/**\n * A plugin implementing this interface can be registered with HMSLocalAudioTrack to transform, process or\n * analyze the local audio track.These can include applications like background noise removal, speech commands, live\n * analysis of audio etc. The below functions are required for the sdk to properly use the plugin, usually\n * the plugin would also be exposing some public functions of its own for the UI to control its working.\n */\n\nexport interface HMSAudioPlugin {\n  /**\n   * This function will be called by the SDK for audio track which the plugin needs to process.\n\n   */\n  processAudioTrack(ctx: AudioContext, source: AudioNode): Promise<AudioNode>;\n\n  /**\n   * This function will be called before the call to init, it is used to check whether the plugin supports current\n   * OS and device or not. An error will be thrown back to the user if they try to use an unsupported plugin.\n   */\n  isSupported(): boolean;\n\n  /**\n   * This function will be called in the beginning for initialization which may include tasks like setting up\n   * variables, loading ML models etc. This can be used by a plugin to ensure it's prepared at the time\n   * processAudio is called.\n   */\n  init(): Promise<void> | void;\n\n  /**\n   * The name is meant to uniquely specify a plugin instance. This will be used to track number of plugins\n   * added to the track, and same name won't be allowed twice.\n   */\n  getName(): string;\n\n  /**\n   This sets the Plugin type @see HMSAudioPluginType, processing will happen\n   based on the type of plugin\n   */\n  getPluginType(): HMSAudioPluginType;\n  /*\n   * the plugin can use this function to dispose off its resources. It'll be called when the plugin instance is\n   * no longer needed at the end.\n   */\n  stop(): void;\n}\n\n/**\n * Specifies the type of the plugin a transforming plugin will get an output audio node to give the resulting\n * transformation. While an analyzing plugin will only be passed the input node.\n */\nexport enum HMSAudioPluginType {\n  TRANSFORM = 'TRANSFORM',\n  ANALYZE = 'ANALYZE',\n}\n","export enum DomainCategory {\n  CUSTOM = 'CUSTOM',\n  LOCAL = 'LOCAL',\n  HMS = 'HMS',\n}\n","import { EventEmitter } from 'events';\n\n/**\n * Typed Event Emitter Reference:\n * https://rjzaworski.com/2019/10/event-emitters-in-typescript#a-typescript-event-emitter-interface\n */\n\nexport type EventMap = Record<string, any>;\n\nexport type EventKey<T extends EventMap> = string & keyof T;\nexport type EventReceiver<T> = (params: T) => void;\n\n// interface Emitter<T extends EventMap> {\n//   on<K extends EventKey<T>>(eventName: K, fn: EventReceiver<T[K]>): void;\n//   off<K extends EventKey<T>>(eventName: K, fn: EventReceiver<T[K]>): void;\n//   emit<K extends EventKey<T>>(eventName: K, params: T[K]): void;\n// }\n\nexport abstract class TypedEventEmitter<T extends EventMap> extends EventEmitter {\n  on<K extends EventKey<T>>(eventName: K, fn: EventReceiver<T[K]>) {\n    return super.on(eventName, fn);\n  }\n\n  off<K extends EventKey<T>>(eventName: K, fn: EventReceiver<T[K]>) {\n    return super.off(eventName, fn);\n  }\n\n  emit<K extends EventKey<T>>(eventName: K, params: T[K]) {\n    return super.emit(eventName, params);\n  }\n\n  listeners<K extends EventKey<T>>(eventName: K): EventReceiver<T[K]>[] {\n    return super.listeners(eventName) as EventReceiver<T[K]>[];\n  }\n}\n","/**\n * Refer: https://github.com/cwilso/volume-meter/blob/master/volume-meter.js\n */\n\nimport { HMSAudioTrack } from '../media/tracks';\nimport { TypedEventEmitter } from './typed-event-emitter';\n\nconst THRESHOLD = 35;\nconst UPDATE_THRESHOLD = 5;\n\nexport interface ITrackAudioLevelUpdate {\n  track: HMSAudioTrack;\n  audioLevel: number;\n}\n\nexport class TrackAudioLevelMonitor extends TypedEventEmitter<{\n  AUDIO_LEVEL_UPDATE: ITrackAudioLevelUpdate | undefined;\n}> {\n  private interval?: number;\n  private audioContext: AudioContext;\n  private audioSource: MediaStreamAudioSourceNode;\n  // @TODO: ScriptProcessorNode Deprecated - Replace with audio analyer node\n  private processor: ScriptProcessorNode;\n  private averaging = 0.99;\n  private audioLevel = 0;\n  private rawLevel = 0;\n\n  private updateAudioLevel(value: number) {\n    const audioLevel = Math.ceil(Math.min(value * 400, 100));\n    if (audioLevel < this.audioLevel - UPDATE_THRESHOLD || audioLevel > this.audioLevel + UPDATE_THRESHOLD) {\n      this.audioLevel = audioLevel > THRESHOLD ? audioLevel : 0;\n      const audioLevelUpdate = this.audioLevel ? { track: this.track, audioLevel: this.audioLevel } : undefined;\n      this.emit('AUDIO_LEVEL_UPDATE', audioLevelUpdate);\n    }\n  }\n\n  constructor(private track: HMSAudioTrack) {\n    super();\n    this.audioContext = new AudioContext();\n    this.audioSource = this.audioContext.createMediaStreamSource(new MediaStream([this.track.nativeTrack]));\n    this.processor = this.audioContext.createScriptProcessor(512);\n    this.processor.addEventListener('audioprocess', this.processVolume);\n    this.audioSource.connect(this.processor);\n    this.processor.connect(this.audioContext.destination);\n  }\n\n  private processVolume = (event: AudioProcessingEvent) => {\n    const input = event.inputBuffer.getChannelData(0);\n    // Calculating root mean square\n    let sum = 0.0;\n    for (let i = 0; i < input.length; ++i) {\n      sum += input[i] * input[i];\n    }\n    const rms = Math.sqrt(sum / input.length);\n    this.rawLevel = Math.max(rms, this.rawLevel * this.averaging);\n  };\n\n  start() {\n    let prev = -1;\n    this.interval = window.setTimeout(() => {\n      if (this.rawLevel !== prev) {\n        // only send an update when there is a change\n        prev = this.rawLevel;\n        this.updateAudioLevel(this.rawLevel);\n      }\n      this.start();\n    }, 1000);\n  }\n\n  stop() {\n    this.updateAudioLevel(0);\n    window.clearInterval(this.interval);\n    this.interval = undefined;\n  }\n}\n","import { DomainCategory } from './AnalyticsEventDomains';\nimport { isBrowser } from '../utils/support';\n\nfunction getDomainCategory() {\n  // this function gives us the domain category(sutom, hms , local) of the base url.\n  // below if statement checks if it's running in a browser ; or if we can use 'window' safely\n\n  if (isBrowser && window) {\n    const baseurl = window.location.hostname;\n\n    if (baseurl === 'localhost' || baseurl === '127.0.0.1') {\n      return DomainCategory.LOCAL;\n    }\n\n    if (baseurl.includes('app.100ms.live')) {\n      return DomainCategory.HMS;\n    } else {\n      return DomainCategory.CUSTOM;\n    }\n  }\n\n  return DomainCategory.CUSTOM;\n}\n\nexport const domainCategory = getDomainCategory();\n","export enum HMSAnalyticsLevel {\n  VERBOSE,\n  INFO,\n  ERROR,\n  OFF,\n}\n\nexport enum AnalyticsEventLevel {\n  VERBOSE,\n  INFO,\n  ERROR,\n  OFF,\n}\n","import { ISignalParamsProvider } from '../signal/ISignalSendParamsProvider';\nimport { domainCategory } from './domain-analytics';\nimport { AnalyticsEventLevel } from './AnalyticsEventLevel';\n\ninterface AnalyticsEventInit {\n  name: string;\n  level: AnalyticsEventLevel;\n  includesPII?: boolean;\n  properties?: Record<string, any>;\n  timestamp?: number;\n}\n\ninterface SignalEventParams {\n  name: string;\n  info: any;\n  timestamp: number;\n}\n\nexport default class AnalyticsEvent implements ISignalParamsProvider<SignalEventParams> {\n  name: string;\n  level: AnalyticsEventLevel;\n  includesPII: boolean;\n  properties: Record<string, any>;\n  timestamp: number;\n\n  constructor({ name, level, properties, includesPII, timestamp }: AnalyticsEventInit) {\n    this.name = name;\n    this.level = level;\n    this.includesPII = includesPII || false;\n    this.properties = properties || {};\n    this.timestamp = timestamp || new Date().getTime(); // Timestamp of generating the event\n  }\n\n  toSignalParams() {\n    return {\n      name: this.name,\n      info: { ...this.properties, timestamp: this.timestamp, domain: domainCategory },\n      timestamp: new Date().getTime(), // Timestamp of sending the event\n    };\n  }\n}\n","import AnalyticsEvent from './AnalyticsEvent';\nimport { AnalyticsEventLevel } from './AnalyticsEventLevel';\nimport { HMSException } from '../error/HMSException';\n\nexport default class MediaPluginsAnalyticsFactory {\n  static failure(pluginName: string, error: HMSException) {\n    const name = 'mediaPlugin.failed';\n    const level = AnalyticsEventLevel.ERROR;\n    const properties = { plugin_name: pluginName, ...error.toAnalyticsProperties() };\n\n    return new AnalyticsEvent({ name, level, properties });\n  }\n\n  static audioPluginStats({\n    pluginName,\n    duration,\n    loadTime,\n  }: {\n    pluginName: string;\n    duration: number;\n    loadTime: number;\n  }) {\n    const name = 'mediaPlugin.stats';\n    const level = AnalyticsEventLevel.INFO;\n    const properties = {\n      plugin_name: pluginName,\n      duration: duration,\n      load_time: loadTime,\n    };\n    return new AnalyticsEvent({ name, level, properties });\n  }\n\n  static stats({\n    pluginName,\n    duration,\n    loadTime,\n    avgPreProcessingTime,\n    avgProcessingTime,\n    inputFrameRate,\n    pluginFrameRate,\n  }: {\n    pluginName: string;\n    duration: number;\n    loadTime: number;\n    avgPreProcessingTime: number;\n    avgProcessingTime: number;\n    inputFrameRate: number;\n    pluginFrameRate: number;\n  }) {\n    const name = 'mediaPlugin.stats';\n    const level = AnalyticsEventLevel.INFO;\n    const properties = {\n      plugin_name: pluginName,\n      duration: duration,\n      load_time: loadTime,\n      avg_preprocessing_time: avgPreProcessingTime,\n      avg_processing_time: avgProcessingTime,\n      input_frame_rate: inputFrameRate,\n      plugin_frame_rate: pluginFrameRate,\n    };\n    return new AnalyticsEvent({ name, level, properties });\n  }\n}\n","import { HMSAnalyticsLevel } from './AnalyticsEventLevel';\nimport { ANALYTICS_BUFFER_SIZE } from '../utils/constants';\nimport HMSLogger from '../utils/logger';\nimport AnalyticsEvent from './AnalyticsEvent';\nimport { AnalyticsTransport } from './AnalyticsTransport';\n\nconst TAG = 'AnalyticsEventsService';\n\nexport class AnalyticsEventsService {\n  private bufferSize = ANALYTICS_BUFFER_SIZE;\n\n  private transports: AnalyticsTransport[] = [];\n  private pendingEvents: AnalyticsEvent[] = [];\n\n  level: HMSAnalyticsLevel = HMSAnalyticsLevel.INFO;\n\n  addTransport(transport: AnalyticsTransport) {\n    this.transports.push(transport);\n  }\n\n  removeTransport(transport: AnalyticsTransport) {\n    this.transports.splice(this.transports.indexOf(transport), 1);\n  }\n\n  queue(event: AnalyticsEvent) {\n    if (event.level >= this.level) {\n      this.pendingEvents.push(event);\n\n      if (this.pendingEvents.length > this.bufferSize) {\n        const removedEvent = this.pendingEvents.shift();\n        HMSLogger.d(TAG, 'Max buffer size reached', 'Removed event to accommodate new events', removedEvent);\n      }\n    }\n    return this;\n  }\n\n  flush() {\n    if (this.transports.length === 0) {\n      HMSLogger.w(TAG, 'No valid signalling API found to flush analytics');\n      return;\n    }\n\n    try {\n      while (this.pendingEvents.length > 0) {\n        const event = this.pendingEvents.shift();\n        if (event) {\n          this.transports.forEach((transport) => transport.sendEvent(event));\n        }\n      }\n    } catch (error) {\n      HMSLogger.w(TAG, 'Flush Failed', error);\n    }\n  }\n}\n\nconst analyticsEventsService = new AnalyticsEventsService();\nexport default analyticsEventsService;\n","import MediaPluginsAnalyticsFactory from '../../analytics/MediaPluginsAnalyticsFactory';\nimport analyticsEventsService from '../../analytics/AnalyticsEventsService';\nimport HMSLogger from '../../utils/logger';\nimport { ErrorFactory, HMSAction } from '../../error/ErrorFactory';\nimport { HMSException } from '../../error/HMSException';\n\nconst TAG = 'AudioPluginsAnalytics';\n\nexport class AudioPluginsAnalytics {\n  private readonly initTime: Record<string, number>;\n  private readonly addedTimestamps: Record<string, number>;\n  private readonly pluginAdded: Record<string, boolean>;\n\n  constructor() {\n    this.initTime = {};\n    this.addedTimestamps = {};\n    this.pluginAdded = {};\n  }\n\n  added(name: string) {\n    this.pluginAdded[name] = true;\n    this.addedTimestamps[name] = Date.now();\n    this.initTime[name] = 0;\n  }\n\n  removed(name: string) {\n    //send stats\n    if (this.pluginAdded[name]) {\n      const stats = {\n        pluginName: name,\n        // duration in seconds\n        duration: Math.floor((Date.now() - this.addedTimestamps[name]) / 1000),\n        loadTime: this.initTime[name],\n      };\n      //send stats\n      analyticsEventsService.queue(MediaPluginsAnalyticsFactory.audioPluginStats(stats)).flush();\n      //clean the plugin details\n      this.clean(name);\n    }\n  }\n\n  failure(name: string, error: HMSException) {\n    // send failure event\n    if (this.pluginAdded[name]) {\n      analyticsEventsService.queue(MediaPluginsAnalyticsFactory.failure(name, error)).flush();\n      //clean the plugin details\n      this.clean(name);\n    }\n  }\n\n  async initWithTime<T>(name: string, initFn: () => Promise<T>) {\n    if (this.initTime[name]) {\n      HMSLogger.i(TAG, `Plugin Already loaded ${name}, time it took: ${this.initTime[name]}`);\n      return;\n    }\n    let time: number | undefined = undefined;\n    try {\n      time = await this.timeInMs(initFn);\n      HMSLogger.i(TAG, `Time taken for Plugin ${name} initialization : ${time}`);\n    } catch (e) {\n      //Failed during initialization of plugin(model loading etc...)\n      const err = ErrorFactory.MediaPluginErrors.InitFailed(\n        HMSAction.AUDIO_PLUGINS,\n        'failed during initialization of plugin' + ((e as Error).message || e),\n      );\n      HMSLogger.e(TAG, err);\n      this.failure(name, err);\n      throw err;\n    }\n    if (time) {\n      this.initTime[name] = time;\n    }\n  }\n\n  private async timeInMs<T>(fn: () => Promise<T>): Promise<number> {\n    const start = Date.now();\n    await fn();\n    return Math.floor(Date.now() - start);\n  }\n\n  private clean(name: string) {\n    delete this.addedTimestamps[name];\n    delete this.initTime[name];\n    delete this.pluginAdded[name];\n  }\n}\n","import { HMSAudioPlugin } from './HMSAudioPlugin'; //HMSAudioPluginType\nimport { HMSLocalAudioTrack } from '../../media/tracks';\nimport HMSLogger from '../../utils/logger';\nimport { ErrorFactory, HMSAction } from '../../error/ErrorFactory';\nimport { AudioPluginsAnalytics } from './AudioPluginsAnalytics';\n\nconst TAG = 'AudioPluginsManager';\n\nexport class HMSAudioPluginsManager {\n  private readonly hmsTrack: HMSLocalAudioTrack;\n  private readonly plugins: string[]; // plugin names in order they were added\n  private readonly pluginsMap: Record<string, HMSAudioPlugin>; // plugin names to their instance mapping\n  private audioContext?: AudioContext;\n\n  private sourceNode?: MediaStreamAudioSourceNode;\n  private destinationNode?: MediaStreamAudioDestinationNode;\n  private intermediateNode?: any;\n  private analytics: AudioPluginsAnalytics;\n  private outputTrack?: MediaStreamTrack;\n  private pluginAddInProgress: boolean = false;\n\n  constructor(track: HMSLocalAudioTrack) {\n    this.hmsTrack = track;\n    this.plugins = [];\n    this.pluginsMap = {};\n    this.analytics = new AudioPluginsAnalytics();\n  }\n\n  getPlugins(): string[] {\n    return [...this.plugins];\n  }\n\n  async addPlugin(plugin: HMSAudioPlugin) {\n    if (this.pluginAddInProgress) {\n      const name = plugin.getName?.();\n      if (!name || name === '') {\n        HMSLogger.w('no name provided by the plugin');\n        return;\n      }\n      const err = ErrorFactory.MediaPluginErrors.AddAlreadyInProgress(\n        HMSAction.AUDIO_PLUGINS,\n        'Add Plugin is already in Progress',\n      );\n      this.analytics.failure(name, err);\n      HMSLogger.w(\"can't add another plugin when previous add is in progress\");\n      throw err;\n    }\n\n    this.pluginAddInProgress = true;\n\n    try {\n      await this.addPluginInternal(plugin);\n    } catch (err) {\n      throw err;\n    } finally {\n      this.pluginAddInProgress = false;\n    }\n  }\n\n  private async addPluginInternal(plugin: HMSAudioPlugin) {\n    const name = plugin.getName?.();\n    if (!name || name === '') {\n      HMSLogger.w('no name provided by the plugin');\n      return;\n    }\n    if (this.pluginsMap[name]) {\n      HMSLogger.w(TAG, `plugin - ${plugin.getName()} already added.`);\n      return;\n    }\n\n    if (this.plugins.length > 0) {\n      HMSLogger.w(TAG, 'An audio plugin is already added, currently supporting only one plugin at a time');\n      //TODO: throw err here to notify UI\n      return;\n    }\n\n    if (!plugin.isSupported()) {\n      let err = ErrorFactory.MediaPluginErrors.PlatformNotSupported(HMSAction.AUDIO_PLUGINS, 'platform not supported ');\n      this.analytics.failure(name, err);\n      HMSLogger.i(TAG, `Platform is not supported for plugin - ${plugin.getName()}`);\n      return;\n    }\n    try {\n      this.analytics.added(name);\n      await this.analytics.initWithTime(name, async () => plugin.init());\n      this.plugins.push(name);\n      this.pluginsMap[name] = plugin;\n      await this.startPluginsProcess();\n    } catch (err) {\n      HMSLogger.e(TAG, 'failed to add plugin', err);\n      await this.removePlugin(plugin);\n      throw err;\n    }\n  }\n\n  async removePlugin(plugin: HMSAudioPlugin) {\n    const name = plugin.getName();\n    if (!this.pluginsMap[name]) {\n      HMSLogger.w(TAG, `plugin - ${name} not found to remove.`);\n      return;\n    }\n    HMSLogger.i(TAG, `removing plugin ${name}`);\n    this.removePluginEntry(name);\n    if (this.plugins.length === 0) {\n      HMSLogger.i(TAG, `No plugins left, stopping plugins loop`);\n      await this.stopPluginsProcess();\n    }\n    if (this.intermediateNode) {\n      this.intermediateNode.disconnect();\n      this.intermediateNode = null;\n    }\n\n    plugin.stop();\n    this.analytics.removed(name);\n  }\n\n  removePluginEntry(name: string) {\n    const index = this.plugins.indexOf(name);\n    if (index !== -1) {\n      this.plugins.splice(index, 1);\n    }\n    if (this.pluginsMap[name]) {\n      delete this.pluginsMap[name];\n    }\n  }\n\n  async cleanup() {\n    for (const name of this.plugins) {\n      await this.removePlugin(this.pluginsMap[name]);\n    }\n    // memory cleanup\n    this.outputTrack?.stop();\n  }\n\n  private initElementsAndStream() {\n    if (!this.audioContext) {\n      this.audioContext = new AudioContext();\n    }\n\n    if (!this.sourceNode) {\n      const audioStream = new MediaStream([this.hmsTrack.nativeTrack]);\n      this.sourceNode = this.audioContext.createMediaStreamSource(audioStream);\n    }\n    if (!this.destinationNode) {\n      this.destinationNode = this.audioContext.createMediaStreamDestination();\n      this.outputTrack = this.destinationNode.stream.getAudioTracks()[0];\n    }\n  }\n\n  private async startPluginsProcess() {\n    this.initElementsAndStream();\n    if (!this.audioContext) {\n      HMSLogger.w(TAG, `Audio context is not defined`);\n      return;\n    }\n    try {\n      await this.hmsTrack.setProcessedTrack(this.outputTrack);\n    } catch (err) {\n      HMSLogger.e(TAG, 'error in setting processed track', err);\n      throw err;\n    }\n    try {\n      await this.processAudioThroughPlugins();\n    } catch (err) {\n      HMSLogger.e(TAG, 'error in processing audio plugins', err);\n      throw err;\n    }\n  }\n\n  private async processAudioThroughPlugins() {\n    for (const name of this.plugins) {\n      const plugin = this.pluginsMap[name];\n      if (!plugin) {\n        continue;\n      }\n\n      try {\n        if (this.audioContext) {\n          this.intermediateNode = await plugin.processAudioTrack(\n            this.audioContext,\n            this.intermediateNode || this.sourceNode,\n          );\n        }\n      } catch (err) {\n        //TODO error happened on processing of plugin notify UI\n        HMSLogger.e(TAG, `error in processing plugin ${name}`, err);\n        //remove plugin from loop and stop analytics for it\n        await this.removePlugin(plugin);\n      }\n      try {\n        if (\n          this.intermediateNode &&\n          this.destinationNode &&\n          this.intermediateNode.context === this.destinationNode.context\n        ) {\n          this.intermediateNode.connect(this.destinationNode);\n        }\n      } catch (err) {\n        HMSLogger.e(TAG, `error in processing plugin ${name}`, err);\n        //remove plugin from loop and stop analytics for it\n        await this.removePlugin(plugin);\n      }\n    }\n  }\n\n  private async stopPluginsProcess() {\n    await this.hmsTrack.setProcessedTrack(undefined);\n  }\n}\n","import { isBrowser } from './support';\n\nexport class LocalStorage<T> {\n  private storage: Storage | null = null;\n\n  constructor(public readonly key: string) {}\n\n  /**\n   * localstorage is not available in SSR, so get it only at time of use\n   */\n  getStorage() {\n    if (isBrowser) {\n      this.storage = window.localStorage;\n    }\n    return this.storage;\n  }\n\n  get(): T | undefined {\n    const stringItem = this.getStorage()?.getItem(this.key);\n    if (!stringItem) {\n      return;\n    }\n    const item = JSON.parse(stringItem) as T;\n    return item;\n  }\n\n  set(value: T) {\n    const stringValue = JSON.stringify(value);\n    this.getStorage()?.setItem(this.key, stringValue);\n  }\n\n  clear() {\n    this.getStorage()?.removeItem(this.key);\n  }\n}\n","import { DeviceMap } from '../interfaces';\nimport { LocalStorage } from '../utils/local-storage';\nimport { SelectedDevices } from './DeviceManager';\n\ntype DeviceInfo = { deviceId?: string; groupId?: string };\n/**\n * This class is to manage storing and retrieving selected devices\n * from localstorage\n * @internal\n */\nclass DeviceStorage {\n  private storage = new LocalStorage<SelectedDevices>('hms-device-selection');\n  private remember = false;\n  private devices?: DeviceMap;\n\n  setDevices(devices: DeviceMap) {\n    this.devices = devices;\n  }\n\n  rememberDevices(value: boolean) {\n    this.remember = value;\n  }\n\n  /**\n   * This will update the passed in type value in storage\n   * @param {string} type - One of audioInput | videoInput | audioOutput\n   * @param {DeviceInfo} param\n   * @returns {void}\n   */\n  updateSelection(type: 'audioInput' | 'videoInput' | 'audioOutput', { deviceId, groupId }: DeviceInfo) {\n    if (!this.devices || !this.remember) {\n      return;\n    }\n    const newSelection = this.devices[type].find((device) => this.isSame({ deviceId, groupId }, device));\n    if (!newSelection) {\n      return;\n    }\n    const selectedDevices = this.storage.get() || {};\n    if (type === 'audioOutput') {\n      selectedDevices[type] = newSelection as MediaDeviceInfo;\n    } else {\n      selectedDevices[type] = newSelection as MediaDeviceInfo;\n    }\n    this.storage.set(selectedDevices);\n  }\n\n  getSelection() {\n    if (!this.remember) {\n      return undefined;\n    }\n    return this.storage.get();\n  }\n\n  cleanup() {\n    this.remember = false;\n    this.devices = undefined;\n  }\n\n  private isSame(current: DeviceInfo, device: DeviceInfo) {\n    // Safari doesn't give groupId from nativeTrack. Check if groupId's match or current groupId is not present\n    return current.deviceId === device.deviceId && (current.groupId === device.groupId || !current.groupId);\n  }\n}\n\nexport const DeviceStorageManager = new DeviceStorage();\n","import { HMSAudioTrack } from './HMSAudioTrack';\nimport HMSLocalStream from '../streams/HMSLocalStream';\nimport { HMSAudioTrackSettings, HMSAudioTrackSettingsBuilder } from '../settings';\nimport { getAudioTrack, isEmptyTrack } from '../../utils/track';\nimport { ITrackAudioLevelUpdate, TrackAudioLevelMonitor } from '../../utils/track-audio-level-monitor';\nimport { EventReceiver } from '../../utils/typed-event-emitter';\nimport HMSLogger from '../../utils/logger';\nimport { HMSAudioPlugin } from '../../plugins';\nimport { HMSAudioPluginsManager } from '../../plugins/audio';\nimport { HMSAudioTrackSettings as IHMSAudioTrackSettings } from '../../interfaces';\nimport { DeviceStorageManager } from '../../device-manager/DeviceStorage';\n\nfunction generateHasPropertyChanged(newSettings: Partial<HMSAudioTrackSettings>, oldSettings: HMSAudioTrackSettings) {\n  return function hasChanged(prop: 'codec' | 'volume' | 'maxBitrate' | 'deviceId' | 'advanced') {\n    return prop in newSettings && newSettings[prop] !== oldSettings[prop];\n  };\n}\n\nconst TAG = 'HMSLocalAudioTrack';\n\nexport class HMSLocalAudioTrack extends HMSAudioTrack {\n  settings: HMSAudioTrackSettings;\n  private pluginsManager: HMSAudioPluginsManager;\n  private processedTrack?: MediaStreamTrack;\n\n  audioLevelMonitor?: TrackAudioLevelMonitor;\n\n  /**\n   * @internal\n   */\n  publishedTrackId: string;\n\n  constructor(\n    stream: HMSLocalStream,\n    track: MediaStreamTrack,\n    source: string,\n    settings: HMSAudioTrackSettings = new HMSAudioTrackSettingsBuilder().build(),\n  ) {\n    super(stream, track, source);\n    stream.tracks.push(this);\n\n    this.settings = settings;\n    this.pluginsManager = new HMSAudioPluginsManager(this);\n    this.publishedTrackId = this.trackId;\n    this.setFirstTrackId(track.id);\n  }\n\n  private async replaceTrackWith(settings: HMSAudioTrackSettings) {\n    const prevTrack = this.nativeTrack;\n    const prevState = this.enabled;\n    /**\n     * Stop has to be called before getting newTrack as it would cause NotReadableError\n     */\n    prevTrack?.stop();\n    const newTrack = await getAudioTrack(settings);\n    newTrack.enabled = prevState;\n\n    const localStream = this.stream as HMSLocalStream;\n    // change nativeTrack so plugin can start its work\n    await localStream.replaceSenderTrack(prevTrack, this.processedTrack || newTrack);\n    await localStream.replaceStreamTrack(prevTrack, newTrack);\n    this.nativeTrack = newTrack;\n  }\n\n  async setEnabled(value: boolean) {\n    if (value === this.enabled) return;\n\n    // Replace silent empty track with an actual audio track, if enabled.\n    if (value && isEmptyTrack(this.nativeTrack)) {\n      await this.replaceTrackWith(this.settings);\n    }\n    await super.setEnabled(value);\n    (this.stream as HMSLocalStream).trackUpdate(this);\n  }\n\n  async setSettings(settings: Partial<IHMSAudioTrackSettings>, internal = false) {\n    const { volume, codec, maxBitrate, deviceId, advanced } = { ...this.settings, ...settings };\n    const newSettings = new HMSAudioTrackSettings(volume, codec, maxBitrate, deviceId, advanced);\n\n    if (isEmptyTrack(this.nativeTrack)) {\n      // if it is an empty track, cache the settings for when it is unmuted\n      this.settings = newSettings;\n      return;\n    }\n\n    const stream = this.stream as HMSLocalStream;\n    const hasPropertyChanged = generateHasPropertyChanged(settings, this.settings);\n\n    if (hasPropertyChanged('deviceId')) {\n      const isLevelMonitored = Boolean(this.audioLevelMonitor);\n      const eventListeners = this.audioLevelMonitor?.listeners('AUDIO_LEVEL_UPDATE');\n      HMSLogger.d(TAG, 'Device change', { isLevelMonitored });\n      isLevelMonitored && this.destroyAudioLevelMonitor();\n      await this.replaceTrackWith(newSettings);\n      isLevelMonitored && this.initAudioLevelMonitor(eventListeners);\n      if (!internal) {\n        DeviceStorageManager.updateSelection('audioInput', {\n          deviceId: settings.deviceId,\n          groupId: this.nativeTrack.getSettings().groupId,\n        });\n      }\n    }\n\n    if (hasPropertyChanged('maxBitrate')) {\n      await stream.setMaxBitrate(newSettings.maxBitrate, this);\n    }\n\n    if (hasPropertyChanged('advanced')) {\n      await this.nativeTrack.applyConstraints(newSettings.toConstraints());\n    }\n\n    this.settings = newSettings;\n  }\n\n  /**\n   * @see HMSAudioPlugin\n   */\n  getPlugins(): string[] {\n    return this.pluginsManager.getPlugins();\n  }\n\n  /**\n   * @see HMSAudioPlugin\n   */\n  async addPlugin(plugin: HMSAudioPlugin): Promise<void> {\n    return this.pluginsManager.addPlugin(plugin);\n  }\n\n  /**\n   * @see HMSAudioPlugin\n   */\n  async removePlugin(plugin: HMSAudioPlugin): Promise<void> {\n    return this.pluginsManager.removePlugin(plugin);\n  }\n\n  /**\n   * @internal\n   */\n  async setProcessedTrack(processedTrack?: MediaStreamTrack) {\n    // if all plugins are removed reset everything back to native track\n    if (!processedTrack) {\n      if (this.processedTrack) {\n        // remove, reset back to the native track\n        await (this.stream as HMSLocalStream).replaceSenderTrack(this.processedTrack, this.nativeTrack);\n      }\n      this.processedTrack = undefined;\n      return;\n    }\n    if (processedTrack !== this.processedTrack) {\n      if (this.processedTrack) {\n        // replace previous processed track with new one\n        await (this.stream as HMSLocalStream).replaceSenderTrack(this.processedTrack, processedTrack);\n      } else {\n        // there is no prev processed track, replace native with new one\n        await (this.stream as HMSLocalStream).replaceSenderTrack(this.nativeTrack, processedTrack);\n      }\n      this.processedTrack = processedTrack;\n    }\n  }\n\n  initAudioLevelMonitor(listeners?: EventReceiver<ITrackAudioLevelUpdate | undefined>[] | undefined) {\n    HMSLogger.d(TAG, 'Monitor Audio Level for', this, this.getMediaTrackSettings().deviceId);\n    this.audioLevelMonitor = new TrackAudioLevelMonitor(this);\n    listeners?.forEach((listener) => this.audioLevelMonitor?.on('AUDIO_LEVEL_UPDATE', listener));\n    this.audioLevelMonitor.start();\n  }\n\n  destroyAudioLevelMonitor() {\n    this.audioLevelMonitor?.stop();\n    this.audioLevelMonitor = undefined;\n  }\n\n  async cleanup() {\n    super.cleanup();\n    await this.pluginsManager.cleanup();\n    this.processedTrack?.stop();\n    this.destroyAudioLevelMonitor();\n  }\n\n  /**\n   * @internal\n   * published track id will be different in case there was some processing done using plugins.\n   */\n  getTrackIDBeingSent() {\n    return this.processedTrack ? this.processedTrack.id : this.nativeTrack.id;\n  }\n}\n","/**\n * A plugin implementing this interface can be registered with HMSLocalVideoTrack to transform, process or\n * analyze the local video track.These can include applications like video filters, virtual background, live\n * analysis of video etc. The below functions are required for the sdk to properly use the plugin, usually\n * the plugin would also be exposing some public functions of its own for the UI to control its working.\n */\nexport interface HMSVideoPlugin {\n  /**\n   * The name is meant to uniquely specify a plugin instance. This will be used to track number of plugins\n   * added to the track, and same name won't be allowed twice.\n   */\n  getName(): string;\n\n  /**\n   * This function will be called before the call to init, it is used to check whether the plugin supports current\n   * OS and device or not. An error will be thrown back to the user if they try to use an unsupported plugin.\n   */\n  isSupported(): boolean;\n\n  /**\n   * This function will be called in the beginning for initialization which may include tasks like setting up\n   * variables, loading ML models etc. This can be used by a plugin to ensure it's prepared at the time\n   * processVideoFrame is called.\n   */\n  init(): Promise<void>;\n\n  /**\n   * @see HMSVideoPluginType\n   */\n  getPluginType(): HMSVideoPluginType;\n\n  /**\n   * This function will be called by the SDK for every video frame which the plugin needs to process.\n   * PluginFrameRate - the rate at which the plugin is expected to process the video frames. This is not necessarily\n   * equal to the capture frame rate. The user can specify this rate, and the sdk might also change it on basis of\n   * device type, or CPU usage.\n   * For an analyzing plugin, the below function will be called at plugin framerate.\n   * For a transforming plugin, the sdk will pass in the input and output at real frame rate with an additional boolean\n   * pass. The expectation is that the plugin should use results of previous runs instead of doing a complex processing\n   * again when pass is set to true. This helps in maintaining the framerate of the video as well as bringing down\n   * CPU usage in case of complex processing.\n   * @param input input canvas containing the input frame\n   * @param output the output canvas which should contain the output frame\n   * @param skipProcessing use results from previous run if true\n   */\n  processVideoFrame(\n    input: HTMLCanvasElement,\n    output?: HTMLCanvasElement,\n    skipProcessing?: boolean,\n  ): Promise<void> | void;\n\n  /**\n   * the plugin can use this function to dispose off its resources. It'll be called when the processor instance is\n   * no longer needed at the end.\n   */\n  stop(): void;\n}\n\n/**\n * Specifies the type of the plugin a transforming plugin will get an output canvas to give the resulting\n * transformation. While an analyzing plugin will only be passed the input canvas.\n */\nexport enum HMSVideoPluginType {\n  TRANSFORM = 'TRANSFORM',\n  ANALYZE = 'ANALYZE',\n}\n","/**\n * Delay for a @see ms amount of time\n * @param ms -- time in milliseconds\n */\nexport function sleep(ms: number): Promise<void> {\n  if (ms < 0) throw Error('`ms` should be a positive integer');\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\n/**\n * Debounce Fn - Function to limit the number of executions of the passed in\n * function in a given time duration\n * @param fn Function to be called\n * @param delay time by which the function execution has to be delayed\n * @returns {void}\n */\nexport function debounce(fn: () => void, delay: number = 300) {\n  let timer: any | undefined;\n  return function (...args: []) {\n    clearTimeout(timer);\n    timer = undefined;\n    //@ts-ignore\n    const context = this;\n    timer = setTimeout(() => {\n      fn.apply(context, args);\n    }, delay);\n  };\n}\n","export class RunningAverage {\n  private total: number = 0;\n  private count: number = 0;\n\n  add(item: number) {\n    this.count++;\n    this.total += item;\n  }\n\n  getAvg(): number {\n    return Math.floor(this.total / this.count);\n  }\n\n  reset() {\n    this.total = 0;\n    this.count = 0;\n  }\n}\n","import { RunningAverage } from '../../utils/math';\nimport MediaPluginsAnalyticsFactory from '../../analytics/MediaPluginsAnalyticsFactory';\nimport analyticsEventsService from '../../analytics/AnalyticsEventsService';\nimport HMSLogger from '../../utils/logger';\nimport { ErrorFactory, HMSAction } from '../../error/ErrorFactory';\nimport { HMSException } from '../../error/HMSException';\n\nconst TAG = 'VideoPluginsAnalytics';\n\nexport class VideoPluginsAnalytics {\n  private readonly initTime: Record<string, number>;\n  private readonly addedTimestamps: Record<string, number>;\n  private readonly preProcessingAvgs: RunningAverage;\n  private readonly processingAvgs: Record<string, RunningAverage>;\n  private readonly pluginAdded: Record<string, boolean>;\n  private readonly pluginInputFrameRate: Record<string, number>;\n  private readonly pluginFrameRate: Record<string, number>;\n\n  constructor() {\n    this.initTime = {};\n    this.preProcessingAvgs = new RunningAverage();\n    this.addedTimestamps = {};\n    this.processingAvgs = {};\n    this.pluginAdded = {};\n    this.pluginInputFrameRate = {};\n    this.pluginFrameRate = {};\n  }\n\n  added(name: string, inputFrameRate: number, pluginFrameRate?: number) {\n    this.pluginAdded[name] = true;\n    this.addedTimestamps[name] = Date.now();\n    this.initTime[name] = 0;\n    this.processingAvgs[name] = new RunningAverage();\n    this.pluginInputFrameRate[name] = inputFrameRate;\n    this.pluginFrameRate[name] = pluginFrameRate || inputFrameRate;\n  }\n\n  removed(name: string) {\n    //send stats\n    if (this.pluginAdded[name]) {\n      const stats = {\n        pluginName: name,\n        // duration in seconds\n        duration: Math.floor((Date.now() - this.addedTimestamps[name]) / 1000),\n        loadTime: this.initTime[name],\n        avgPreProcessingTime: this.preProcessingAvgs.getAvg(), //Do we need this in stat not plugin specific\n        avgProcessingTime: this.processingAvgs[name]?.getAvg(),\n        inputFrameRate: this.pluginInputFrameRate[name],\n        pluginFrameRate: this.pluginFrameRate[name],\n      };\n      //send stats\n      analyticsEventsService.queue(MediaPluginsAnalyticsFactory.stats(stats)).flush();\n      //clean the plugin details\n      this.clean(name);\n    }\n  }\n\n  failure(name: string, error: HMSException) {\n    // send failure event\n    if (this.pluginAdded[name]) {\n      analyticsEventsService.queue(MediaPluginsAnalyticsFactory.failure(name, error)).flush();\n      //clean the plugin details\n      this.clean(name);\n    }\n  }\n\n  async initWithTime<T>(name: string, initFn: () => Promise<T>) {\n    if (this.initTime[name]) {\n      HMSLogger.i(TAG, `Plugin Already loaded ${name}, time it took: ${this.initTime[name]}`);\n      return;\n    }\n    let time: number | undefined = undefined;\n    try {\n      time = await this.timeInMs(initFn);\n      HMSLogger.i(TAG, `Time taken for Plugin ${name} initialization : ${time}`);\n    } catch (e) {\n      //Failed during initialization of plugin(model loading etc...)\n      const err = ErrorFactory.MediaPluginErrors.InitFailed(\n        HMSAction.VIDEO_PLUGINS,\n        'failed during initialization of plugin' + ((e as Error).message || e),\n      );\n      HMSLogger.e(TAG, err);\n      this.failure(name, err);\n      throw err;\n    }\n    if (time) {\n      this.initTime[name] = time;\n    }\n  }\n\n  async preProcessWithTime<T>(preProcessFn: () => Promise<T>) {\n    //TODO: check if it is required to maintain and shall we handle preprocess failures\n    const time = await this.timeInMs(preProcessFn);\n    this.preProcessingAvgs.add(time);\n  }\n\n  async processWithTime<T>(name: string, processFn: () => Promise<T>) {\n    let time: number | undefined = undefined;\n    try {\n      time = await this.timeInMs(processFn);\n    } catch (e) {\n      //Failed during processing of plugin\n      const err = ErrorFactory.MediaPluginErrors.ProcessingFailed(\n        HMSAction.VIDEO_PLUGINS,\n        'Failed during processing of plugin' + ((e as Error).message || e),\n      );\n      HMSLogger.e(TAG, err);\n      this.failure(name, err);\n      throw err;\n    }\n    if (time) {\n      this.processingAvgs[name]?.add(time);\n    }\n  }\n\n  private async timeInMs<T>(fn: () => Promise<T>): Promise<number> {\n    const start = Date.now();\n    await fn();\n    return Math.floor(Date.now() - start);\n  }\n\n  private clean(name: string) {\n    delete this.addedTimestamps[name];\n    delete this.initTime[name];\n    delete this.processingAvgs[name];\n    delete this.pluginAdded[name];\n    delete this.pluginInputFrameRate[name];\n    delete this.pluginFrameRate[name];\n  }\n}\n","import { HMSVideoPlugin, HMSVideoPluginType } from './HMSVideoPlugin';\nimport { HMSLocalVideoTrack } from '../../media/tracks';\nimport HMSLogger from '../../utils/logger';\nimport { sleep } from '../../utils/timer-utils';\nimport { VideoPluginsAnalytics } from './VideoPluginsAnalytics';\nimport { ErrorFactory, HMSAction } from '../../error/ErrorFactory';\n\nconst DEFAULT_FRAME_RATE = 24;\nconst TAG = 'VideoPluginsManager';\n\ninterface CanvasElement extends HTMLCanvasElement {\n  captureStream(frameRate?: number): MediaStream;\n}\n\n/**\n * This class manages applying different plugins on a local video track. Plugins which need to modify the video\n * are called in the order they were added. Plugins which do not need to modify the video frames are called\n * with the original input.\n *\n * Concepts -\n * Video Plugin - A module which can take in input video painted on a canvas, do some processing on it and optionally\n * render its output on a passed in output canvas which will be shown in the UI.\n *\n * frameRate - the frame rate of the input video as present in track.getSettings, this is the rate at which new frames\n * are being produced and the rate we need to maintain in output as well.\n *\n * pluginFrameRate - this is the rate at which the plugin is supposed to do its processing. The processing can be an\n * expensive operation and can result in high usage of resources like CPU. This rate would usually be lower than the\n * real frame rate.\n *\n * pluginsLoop - a loop is run at framerate in this class, on each loop if the original track is unmuted all added\n * plugins are called one by one in the order they were called.\n *\n * @see HMSVideoPlugin\n */\nexport class HMSVideoPluginsManager {\n  /**\n   * plugins loop is the loop in which all plugins are applied\n   */\n  private pluginsLoopRunning: boolean = false;\n  private pluginsLoopState: 'paused' | 'running' = 'paused';\n  private readonly hmsTrack: HMSLocalVideoTrack;\n  private readonly plugins: string[]; // plugin names in order they were added\n  private readonly pluginsMap: Record<string, HMSVideoPlugin>; // plugin names to their instance mapping\n  private inputVideo?: HTMLVideoElement;\n  private inputCanvas?: CanvasElement;\n  private outputCanvas?: CanvasElement;\n  private outputTrack?: MediaStreamTrack;\n  private analytics: VideoPluginsAnalytics;\n  private pluginAddInProgress: boolean = false;\n  private pluginNumFramesToSkip: Record<string, number>;\n  private pluginNumFramesSkipped: Record<string, number>;\n\n  constructor(track: HMSLocalVideoTrack) {\n    this.hmsTrack = track;\n    this.plugins = [];\n    this.pluginsMap = {};\n    this.pluginNumFramesToSkip = {};\n    this.pluginNumFramesSkipped = {};\n    this.analytics = new VideoPluginsAnalytics();\n  }\n\n  getPlugins(): string[] {\n    return [...this.plugins];\n  }\n\n  /**\n   * @param plugin\n   * @param pluginFrameRate\n   */\n  async addPlugin(plugin: HMSVideoPlugin, pluginFrameRate?: number) {\n    if (this.pluginAddInProgress) {\n      const name = plugin.getName?.();\n      if (!name || name === '') {\n        HMSLogger.w('no name provided by the plugin');\n        return;\n      }\n\n      const err = ErrorFactory.MediaPluginErrors.AddAlreadyInProgress(\n        HMSAction.VIDEO_PLUGINS,\n        'Add Plugin is already in Progress',\n      );\n      this.analytics.failure(name, err);\n\n      HMSLogger.w(\"can't add another plugin when previous add is in progress\");\n      throw err;\n    }\n\n    this.pluginAddInProgress = true;\n\n    try {\n      await this.addPluginInternal(plugin, pluginFrameRate);\n    } catch (err) {\n      throw err;\n    } finally {\n      this.pluginAddInProgress = false;\n    }\n  }\n\n  private async addPluginInternal(plugin: HMSVideoPlugin, pluginFrameRate?: number) {\n    const name = plugin.getName?.();\n    if (!name || name === '') {\n      HMSLogger.w('no name provided by the plugin');\n      return;\n    }\n    if (this.pluginsMap[name]) {\n      HMSLogger.w(TAG, `plugin - ${plugin.getName()} already added.`);\n      return;\n    }\n    const { width, height } = this.hmsTrack.getMediaTrackSettings();\n    if (!width || !height || width <= 0 || height <= 0) {\n      HMSLogger.i(TAG, 'Track width/height is not valid');\n      return;\n    }\n\n    //TODO: assuming this inputFrameRate from getMediaTrackSettings will not change once set\n    //TODO: even if it changes will not have the info/params to know the change\n    const inputFrameRate = this.hmsTrack.getMediaTrackSettings().frameRate || DEFAULT_FRAME_RATE;\n\n    let numFramesToSkip = 0;\n    if (pluginFrameRate && pluginFrameRate > 0) {\n      HMSLogger.i(TAG, `adding plugin ${plugin.getName()} with framerate ${pluginFrameRate}`);\n      if (pluginFrameRate < inputFrameRate) {\n        numFramesToSkip = Math.ceil(inputFrameRate / pluginFrameRate) - 1;\n      }\n      this.analytics.added(name, inputFrameRate, pluginFrameRate);\n    } else {\n      HMSLogger.i(TAG, `adding plugin ${plugin.getName()}`);\n      this.analytics.added(name, inputFrameRate);\n    }\n\n    HMSLogger.i(TAG, 'numFrames to skip processing', numFramesToSkip);\n    this.pluginNumFramesToSkip[name] = numFramesToSkip;\n    this.pluginNumFramesSkipped[name] = numFramesToSkip;\n\n    if (!plugin.isSupported()) {\n      let err = ErrorFactory.MediaPluginErrors.PlatformNotSupported(HMSAction.VIDEO_PLUGINS, 'platform not supported ');\n      this.analytics.failure(name, err);\n      HMSLogger.i(TAG, `Platform is not supported for plugin - ${plugin.getName()}`);\n      return;\n    }\n    try {\n      await this.analytics.initWithTime(name, async () => await plugin.init());\n      this.plugins.push(name);\n      this.pluginsMap[name] = plugin;\n      await this.startPluginsLoop();\n    } catch (err) {\n      HMSLogger.e(TAG, 'failed to add plugin', err);\n      await this.removePlugin(plugin);\n      throw err;\n    }\n  }\n\n  async removePlugin(plugin: HMSVideoPlugin) {\n    const name = plugin.getName();\n    if (!this.pluginsMap[name]) {\n      HMSLogger.w(TAG, `plugin - ${name} not found to remove.`);\n      return;\n    }\n    HMSLogger.i(TAG, `removing plugin ${name}`);\n    this.removePluginEntry(name);\n    if (this.plugins.length === 0) {\n      HMSLogger.i(TAG, `No plugins left, stopping plugins loop`);\n      await this.stopPluginsLoop();\n    }\n    plugin.stop();\n    this.analytics.removed(name);\n  }\n\n  removePluginEntry(name: string) {\n    const index = this.plugins.indexOf(name);\n    if (index !== -1) {\n      this.plugins.splice(index, 1);\n    }\n    if (this.pluginsMap[name]) {\n      delete this.pluginsMap[name];\n    }\n    if (this.pluginNumFramesToSkip[name]) {\n      delete this.pluginNumFramesToSkip[name];\n    }\n    if (this.pluginNumFramesSkipped[name]) {\n      delete this.pluginNumFramesSkipped[name];\n    }\n  }\n\n  /**\n   * when video is unmuted it takes some time for all the plugins to be re run and an output stream to be\n   * produced. It can await on this function to confirm and tell the new unmuted state.\n   * If this is not awaited on video will freeze with a frame from past run.\n   */\n  async waitForRestart() {\n    if (!this.pluginsLoopRunning || this.pluginsLoopState === 'running') {\n      return;\n    }\n    while (this.pluginsLoopState === 'paused') {\n      await sleep(100);\n    }\n  }\n\n  /**\n   * remove every plugin one by one\n   */\n  async cleanup() {\n    for (const name of this.plugins) {\n      await this.removePlugin(this.pluginsMap[name]);\n    }\n    // memory cleanup\n    this.outputTrack?.stop();\n  }\n\n  private initElementsAndStream() {\n    if (!this.inputCanvas) {\n      this.inputCanvas = document.createElement('canvas') as CanvasElement;\n    }\n    if (!this.outputCanvas) {\n      this.outputCanvas = document.createElement('canvas') as CanvasElement;\n    }\n    if (!this.inputVideo) {\n      this.inputVideo = document.createElement('video');\n    }\n    // FF issue https://bugzilla.mozilla.org/show_bug.cgi?id=1388974\n    this.inputCanvas.getContext('2d');\n    this.outputCanvas.getContext('2d');\n    // capture stream automatically uses the framerate at which the output canvas is changing\n    const outputStream = this.outputCanvas.captureStream();\n    this.outputTrack = outputStream.getVideoTracks()[0];\n  }\n\n  private async startPluginsLoop() {\n    if (this.pluginsLoopRunning) {\n      return;\n    }\n    this.initElementsAndStream();\n    this.pluginsLoopRunning = true;\n    try {\n      await this.hmsTrack.setProcessedTrack(this.outputTrack);\n    } catch (err) {\n      this.pluginsLoopRunning = false;\n      HMSLogger.e(TAG, 'error in setting processed track', err);\n      throw err;\n    }\n    // can't await on pluginsLoop as it'll run for a long long time\n    this.pluginsLoop().then(() => {\n      HMSLogger.d(TAG, 'processLoop stopped');\n    });\n  }\n\n  private async stopPluginsLoop() {\n    this.pluginsLoopRunning = false;\n    await this.hmsTrack.setProcessedTrack(undefined);\n    this.resetCanvases();\n    this.outputTrack?.stop();\n    if (this.inputVideo) {\n      this.inputVideo.srcObject = null;\n      this.inputVideo = undefined;\n    }\n  }\n\n  private async pluginsLoop() {\n    while (this.pluginsLoopRunning) {\n      const inputFrameRate = this.hmsTrack.getMediaTrackSettings().frameRate || DEFAULT_FRAME_RATE;\n      const sleepTimeMs = Math.floor(1000 / inputFrameRate);\n      if (!this.hmsTrack.enabled || this.hmsTrack.nativeTrack.readyState === 'ended') {\n        if (this.pluginsLoopState === 'running') {\n          // mute just happened, reset canvases to black so even if it is sent to remote, it\n          // is a black screen instead of a stucked frame from previous run\n          this.resetCanvases();\n        }\n        this.pluginsLoopState = 'paused';\n        await sleep(sleepTimeMs);\n        continue;\n      }\n      let processingTime: number = 0;\n      try {\n        await this.analytics.preProcessWithTime(async () => await this.doPreProcessing());\n        const start = Date.now();\n        await this.processFramesThroughPlugins();\n        processingTime = Math.floor(Date.now() - start);\n        if (processingTime > sleepTimeMs) {\n          processingTime = sleepTimeMs;\n        }\n      } catch (err) {\n        // TODO: handle failures properly, detect which plugin failed, stop it and notify back to the UI\n        HMSLogger.e(TAG, 'error in plugins loop', err);\n      }\n      this.pluginsLoopState = 'running';\n      // take into account processing time to decide time to wait for the next loop\n      await sleep(sleepTimeMs - processingTime);\n    }\n  }\n\n  private async doPreProcessing() {\n    await this.addTrackToVideo(); // ensure current native track is playing in video\n    await this.updateInputCanvas(); // put the latest video frame on input canvas\n  }\n\n  /**\n   * pass the input canvas through all plugins in a loop\n   * @private\n   */\n  private async processFramesThroughPlugins() {\n    for (const name of this.plugins) {\n      const plugin = this.pluginsMap[name];\n      if (!plugin) {\n        continue;\n      }\n      try {\n        const skipProcessing = this.checkIfSkipRequired(name);\n        // TODO: should we use output of previous to pass in to next, instead of passing initial everytime?\n        if (plugin.getPluginType() === HMSVideoPluginType.TRANSFORM) {\n          const process = async () => {\n            await plugin.processVideoFrame(this.inputCanvas!, this.outputCanvas, skipProcessing);\n          };\n          if (!skipProcessing) {\n            await this.analytics.processWithTime(name, process);\n          } else {\n            await process();\n          }\n        } else if (plugin.getPluginType() === HMSVideoPluginType.ANALYZE && !skipProcessing) {\n          // there is no need to await for this case\n          await this.analytics.processWithTime(name, async () => await plugin.processVideoFrame(this.inputCanvas!));\n        }\n      } catch (err) {\n        //TODO error happened on processing of plugin notify UI\n        HMSLogger.e(TAG, `error in processing plugin ${name}`, err);\n        //remove plugin from loop and stop analytics for it\n        await this.removePlugin(plugin);\n      }\n    }\n  }\n\n  /**\n   * add the current native track to the inputVideoElement if it's not already added.\n   * @private\n   */\n  private async addTrackToVideo() {\n    if (!this.inputVideo) {\n      return;\n    }\n    const srcObject = this.inputVideo.srcObject;\n    if (srcObject !== null && srcObject instanceof MediaStream) {\n      const existingTrackID = srcObject.getVideoTracks()[0]?.id;\n      if (existingTrackID === this.hmsTrack.nativeTrack.id) {\n        // it's already attached\n        return;\n      }\n    }\n    this.inputVideo.pause();\n    this.inputVideo.srcObject = new MediaStream([this.hmsTrack.nativeTrack]);\n    this.inputVideo.muted = true;\n    await this.inputVideo.play();\n  }\n\n  /**\n   * get the new video frame from input video element and put it on canvas\n   * @private\n   */\n  private async updateInputCanvas() {\n    if (!this.inputCanvas || !this.inputVideo) {\n      return;\n    }\n    const { width, height } = this.hmsTrack.getMediaTrackSettings();\n    if (!width || !height || width <= 0 || height <= 0) {\n      HMSLogger.w(TAG, 'Invalid width/height of videoTrack', width, height);\n      return;\n    }\n    // TODO: should we reduce height/width to optimize?\n    if (this.inputCanvas.height !== height) {\n      this.inputCanvas.height = height;\n    }\n    if (this.inputCanvas.width !== width) {\n      this.inputCanvas.width = width;\n    }\n    const ctx = this.inputCanvas.getContext('2d');\n    ctx!.drawImage(this.inputVideo, 0, 0, width, height);\n  }\n\n  private resetCanvases() {\n    if (!this.outputCanvas || !this.inputCanvas) {\n      return;\n    }\n    const outputCtx = this.outputCanvas.getContext('2d');\n    if (outputCtx) {\n      outputCtx.fillStyle = `rgb(0, 0, 0)`;\n      outputCtx.fillRect(0, 0, this.outputCanvas.width, this.outputCanvas.height);\n    }\n    const inputCtx = this.inputCanvas.getContext('2d');\n    if (inputCtx) {\n      inputCtx.fillStyle = `rgb(0, 0, 0)`;\n      inputCtx.fillRect(0, 0, this.outputCanvas.width, this.outputCanvas.height);\n    }\n  }\n\n  /**\n    N = ceil(inputFrameRate/pluginFrameRate) - 1\n    N = this.pluginNumFramesToSkip[name] = frames to skip for every processed frame\n    all the frames we are skipping are using the previous frame output\n   **/\n  private checkIfSkipRequired(name: string) {\n    let skip = false;\n\n    if (this.pluginNumFramesSkipped[name] < this.pluginNumFramesToSkip[name]) {\n      this.pluginNumFramesSkipped[name]++;\n      skip = true;\n    } else {\n      skip = false;\n      this.pluginNumFramesSkipped[name] = 0;\n    }\n\n    return skip;\n  }\n}\n","import { HMSVideoTrack } from './HMSVideoTrack';\nimport HMSLocalStream from '../streams/HMSLocalStream';\nimport { HMSVideoTrackSettings, HMSVideoTrackSettingsBuilder } from '../settings';\nimport { getEmptyVideoTrack, getVideoTrack } from '../../utils/track';\nimport { HMSVideoPlugin } from '../../plugins';\nimport { HMSVideoPluginsManager } from '../../plugins/video';\nimport { HMSVideoTrackSettings as IHMSVideoTrackSettings } from '../../interfaces';\nimport { DeviceStorageManager } from '../../device-manager/DeviceStorage';\n\nfunction generateHasPropertyChanged(newSettings: Partial<HMSVideoTrackSettings>, oldSettings: HMSVideoTrackSettings) {\n  return function hasChanged(\n    prop: 'codec' | 'width' | 'height' | 'maxFramerate' | 'maxBitrate' | 'deviceId' | 'advanced',\n  ) {\n    return prop in newSettings && newSettings[prop] !== oldSettings[prop];\n  };\n}\n\nexport class HMSLocalVideoTrack extends HMSVideoTrack {\n  settings: HMSVideoTrackSettings;\n  private pluginsManager: HMSVideoPluginsManager;\n  private processedTrack?: MediaStreamTrack;\n\n  /**\n   * @internal\n   * This is required for handling remote mute/unmute as the published track will not necessarily be same as\n   * the first track id or current native track's id.\n   * It won't be same as first track id if the native track was changed after preview started but before join happened,\n   * with device change, or mute/unmute.\n   * It won't be same as native track id, as the native track can change post join(and publish), when the nativetrack\n   * changes, replacetrack is used which doesn't involve republishing which means from server's point of view, the track id\n   * is same as what was initially published.\n   */\n  publishedTrackId: string;\n\n  constructor(\n    stream: HMSLocalStream,\n    track: MediaStreamTrack,\n    source: string,\n    settings: HMSVideoTrackSettings = new HMSVideoTrackSettingsBuilder().build(),\n  ) {\n    super(stream, track, source);\n    stream.tracks.push(this);\n    this.settings = settings;\n    this.pluginsManager = new HMSVideoPluginsManager(this);\n    this.publishedTrackId = this.trackId;\n    this.setFirstTrackId(this.trackId);\n  }\n\n  /**\n   * use this function to set the enabled state of a track. If true the track will be unmuted and muted otherwise.\n   * @param value\n   */\n  async setEnabled(value: boolean): Promise<void> {\n    if (value === this.enabled) return;\n    if (this.source === 'regular') {\n      if (value) {\n        await this.replaceTrackWith(this.settings);\n      } else {\n        await this.replaceTrackWithBlank();\n      }\n    }\n    await super.setEnabled(value);\n    (this.stream as HMSLocalStream).trackUpdate(this);\n  }\n\n  /**\n   * @see HMSVideoTrack#addSink()\n   */\n  addSink(videoElement: HTMLVideoElement) {\n    this.addSinkInternal(videoElement, this.processedTrack || this.nativeTrack);\n  }\n\n  /**\n   * This function can be used to set media track settings. Frequent options -\n   * deviceID: can be used to change to different input source\n   * width, height - can be used to change capture dimensions\n   * maxFramerate - can be used to control the capture framerate\n   * @param settings\n   */\n  async setSettings(settings: Partial<IHMSVideoTrackSettings>, internal = false) {\n    const { width, height, codec, maxFramerate, maxBitrate, deviceId, advanced } = { ...this.settings, ...settings };\n    const newSettings = new HMSVideoTrackSettings(width, height, codec, maxFramerate, deviceId, advanced, maxBitrate);\n\n    if (!this.enabled) {\n      // if track is muted, we just cache the settings for when it is unmuted\n      this.settings = newSettings;\n      return;\n    }\n\n    const stream = this.stream as HMSLocalStream;\n    const hasPropertyChanged = generateHasPropertyChanged(settings, this.settings);\n\n    if (hasPropertyChanged('deviceId') && this.source === 'regular') {\n      if (this.enabled) {\n        await this.replaceTrackWith(newSettings);\n        if (!internal) {\n          DeviceStorageManager.updateSelection('videoInput', {\n            deviceId: settings.deviceId,\n            groupId: this.nativeTrack.getSettings().groupId,\n          });\n        }\n      }\n    }\n\n    if (hasPropertyChanged('maxBitrate') && newSettings.maxBitrate) {\n      await stream.setMaxBitrate(newSettings.maxBitrate, this);\n    }\n\n    if (hasPropertyChanged('width') || hasPropertyChanged('height') || hasPropertyChanged('advanced')) {\n      await this.nativeTrack.applyConstraints(newSettings.toConstraints());\n    }\n\n    this.settings = newSettings;\n  }\n\n  /**\n   * @see HMSVideoPlugin\n   */\n  getPlugins(): string[] {\n    return this.pluginsManager.getPlugins();\n  }\n\n  /**\n   * @see HMSVideoPlugin\n   */\n  async addPlugin(plugin: HMSVideoPlugin, pluginFrameRate?: number): Promise<void> {\n    return this.pluginsManager.addPlugin(plugin, pluginFrameRate);\n  }\n\n  /**\n   * @see HMSVideoPlugin\n   */\n  async removePlugin(plugin: HMSVideoPlugin): Promise<void> {\n    return this.pluginsManager.removePlugin(plugin);\n  }\n\n  /**\n   * @internal\n   */\n  async cleanup() {\n    super.cleanup();\n    await this.pluginsManager.cleanup();\n    this.processedTrack?.stop();\n  }\n\n  /**\n   * once the plugin manager has done its processing it can set or remove processed track via this method\n   * note that replacing sender track only makes sense if the native track is enabled. if it's disabled there is\n   * no point in replacing it. We'll update the processed track variable though so next time unmute happens\n   * it's set properly.\n   * @internal\n   */\n  async setProcessedTrack(processedTrack?: MediaStreamTrack) {\n    // required replacement will happen when video is unmuted\n    if (!this.nativeTrack.enabled) {\n      this.processedTrack = processedTrack;\n      return;\n    }\n    // if all plugins are removed reset everything back to native track\n    if (!processedTrack) {\n      if (this.processedTrack) {\n        // remove, reset back to the native track\n        await (this.stream as HMSLocalStream).replaceSenderTrack(this.processedTrack, this.nativeTrack);\n      }\n      this.processedTrack = undefined;\n      return;\n    }\n    if (processedTrack !== this.processedTrack) {\n      if (this.processedTrack) {\n        // replace previous processed track with new one\n        await (this.stream as HMSLocalStream).replaceSenderTrack(this.processedTrack, processedTrack);\n      } else {\n        // there is no prev processed track, replace native with new one\n        await (this.stream as HMSLocalStream).replaceSenderTrack(this.nativeTrack, processedTrack);\n      }\n      this.processedTrack = processedTrack;\n    }\n  }\n\n  /**\n   * @internal\n   * sent track id will be different in case there was some processing done using plugins.\n   * replace track is used to, start sending data from a new track without un publishing the prior one. There\n   * are thus two track ids - the one which was initially published and should be unpublished when required.\n   * The one whose data is currently being sent, which will be used when removing from connection senders.\n   */\n  getTrackIDBeingSent() {\n    return this.processedTrack ? this.processedTrack.id : this.nativeTrack.id;\n  }\n\n  /**\n   * called when the video is unmuted\n   * @private\n   */\n  private async replaceTrackWith(settings: HMSVideoTrackSettings) {\n    const prevTrack = this.nativeTrack;\n    prevTrack?.stop();\n    const newTrack = await getVideoTrack(settings);\n    const localStream = this.stream as HMSLocalStream;\n    // change nativeTrack so plugin can start its work\n    await localStream.replaceSenderTrack(prevTrack, this.processedTrack || newTrack);\n    await localStream.replaceStreamTrack(prevTrack, newTrack);\n    this.nativeTrack = newTrack;\n    await this.pluginsManager.waitForRestart();\n  }\n\n  /**\n   * called when the video is muted. A blank track is used to replace the original track. This is in order to\n   * turn off the camera light and keep the bytes flowing to avoid av sync, timestamp issues.\n   * @private\n   */\n  private async replaceTrackWithBlank() {\n    const prevTrack = this.nativeTrack;\n    prevTrack?.stop();\n    const newTrack = getEmptyVideoTrack(prevTrack);\n    const localStream = this.stream as HMSLocalStream;\n    await localStream.replaceSenderTrack(this.processedTrack || this.nativeTrack, newTrack);\n    await localStream.replaceStreamTrack(this.nativeTrack, newTrack);\n    this.nativeTrack = newTrack;\n  }\n}\n","/**\n * Method names for incoming RPC messages from BIZ Signal through Websocket.\n * Used to call the corresponding handler/manager in NotificationManager\n * which will call the corresponding HMSUpdateListener callbacks.\n */\n\nexport enum HMSNotificationMethod {\n  PEER_JOIN = 'on-peer-join',\n  PEER_LEAVE = 'on-peer-leave',\n  PEER_LIST = 'peer-list',\n  TRACK_METADATA_ADD = 'on-track-add',\n  TRACK_UPDATE = 'on-track-update',\n  CHANGE_TRACK_MUTE_STATE_UPDATE = 'on-change-track-mute-state-request',\n  ACTIVE_SPEAKERS = 'active-speakers',\n  BROADCAST = 'on-broadcast',\n  ROLE_CHANGE = 'on-role-change',\n  POLICY_CHANGE = 'on-policy-change',\n  ROLE_CHANGE_REQUEST = 'on-role-change-request',\n  TRACK_UPDATE_REQUEST = 'on-track-update-request',\n  PEER_UPDATE = 'on-peer-update',\n  PEER_LEAVE_REQUEST = 'on-peer-leave-request',\n  UNSUPPORTED = 'unsupported',\n  RTMP_START = 'on-rtmp-start',\n  RTMP_STOP = 'on-rtmp-stop',\n  RECORDING_START = 'on-record-start',\n  RECORDING_STOP = 'on-record-stop',\n}\n","import HMSMediaStream from './HMSMediaStream';\nimport { HMSLocalTrack, HMSLocalAudioTrack, HMSLocalVideoTrack } from '../tracks';\nimport HMSPublishConnection from '../../connection/publish';\nimport { HMSTrackSettings, HMSVideoTrackSettings, HMSAudioTrackSettings } from '../settings';\nimport HMSLogger from '../../utils/logger';\nimport { BuildGetMediaError, HMSGetMediaActions } from '../../error/utils';\nimport { getAudioTrack, getEmptyAudioTrack, getEmptyVideoTrack, getVideoTrack } from '../../utils/track';\nimport { IFetchAVTrackOptions } from '../../transport/ITransport';\nimport { SimulcastLayer } from '../../interfaces';\nimport { isNode } from '../../utils/support';\n\nconst TAG = 'HMSLocalStream';\n\nexport default class HMSLocalStream extends HMSMediaStream {\n  /** Connection set when publish is called for the first track */\n  private connection: HMSPublishConnection | null = null;\n\n  setConnection(connection: HMSPublishConnection) {\n    this.connection = connection;\n  }\n\n  static async getLocalScreen(videosettings: HMSVideoTrackSettings, audioSettings: HMSAudioTrackSettings) {\n    const audioConstraints: MediaTrackConstraints = audioSettings.toConstraints();\n    // remove advanced constraints as it not supported for screenshare audio\n    delete audioConstraints.advanced;\n    const constraints = {\n      video: videosettings.toConstraints(),\n      audio: {\n        ...audioConstraints,\n        autoGainControl: false,\n        noiseSuppression: false,\n        googAutoGainControl: false,\n        echoCancellation: false,\n      },\n    } as MediaStreamConstraints;\n    let stream;\n    try {\n      // @ts-ignore [https://github.com/microsoft/TypeScript/issues/33232]\n      stream = (await navigator.mediaDevices.getDisplayMedia(constraints)) as MediaStream;\n    } catch (err) {\n      throw BuildGetMediaError(err as Error, HMSGetMediaActions.SCREEN);\n    }\n\n    const tracks: Array<HMSLocalTrack> = [];\n    const local = new HMSLocalStream(stream);\n    const nativeVideoTrack = stream.getVideoTracks()[0];\n    const videoTrack = new HMSLocalVideoTrack(local, nativeVideoTrack, 'screen', videosettings);\n    tracks.push(videoTrack);\n    const nativeAudioTrack = stream.getAudioTracks()[0];\n    if (nativeAudioTrack) {\n      const audioTrack = new HMSLocalAudioTrack(local, nativeAudioTrack, 'screen', audioSettings);\n      tracks.push(audioTrack);\n    }\n\n    HMSLogger.v(TAG, 'getLocalScreen', tracks);\n    return tracks;\n  }\n\n  static async getLocalTracks(settings: HMSTrackSettings): Promise<Array<HMSLocalTrack>> {\n    return await this.getEmptyLocalTracks({ audio: true, video: true }, settings);\n  }\n\n  static async getEmptyLocalTracks(\n    fetchTrackOptions: IFetchAVTrackOptions = { audio: true, video: true },\n    settings?: HMSTrackSettings,\n  ): Promise<Array<HMSLocalTrack>> {\n    const nativeTracks = await this.getNativeLocalTracks(fetchTrackOptions, settings);\n    const nativeVideoTrack = nativeTracks.find((track) => track.kind === 'video');\n    const nativeAudioTrack = nativeTracks.find((track) => track.kind === 'audio');\n    const local = new HMSLocalStream(new MediaStream(nativeTracks));\n\n    const tracks: Array<HMSLocalTrack> = [];\n    if (nativeAudioTrack && settings?.audio) {\n      const audioTrack = new HMSLocalAudioTrack(local, nativeAudioTrack, 'regular', settings.audio);\n      tracks.push(audioTrack);\n    }\n\n    if (nativeVideoTrack && settings?.video) {\n      const videoTrack = new HMSLocalVideoTrack(local, nativeVideoTrack, 'regular', settings.video);\n      tracks.push(videoTrack);\n    }\n\n    HMSLogger.v(TAG, 'getEmptyLocalTracks', tracks);\n    return tracks;\n  }\n\n  addTransceiver(track: HMSLocalTrack, simulcastLayers: SimulcastLayer[]) {\n    let trackEncodings: RTCRtpEncodingParameters[] = [];\n    if (track instanceof HMSLocalVideoTrack) {\n      if (simulcastLayers.length > 0) {\n        HMSLogger.v(TAG, 'Simulcast enabled with layers', simulcastLayers);\n        trackEncodings.push(...simulcastLayers);\n      } else {\n        const encodings: RTCRtpEncodingParameters = { active: this.nativeStream.active };\n        if (track.settings.maxBitrate && !isNode) {\n          encodings.maxBitrate = track.settings.maxBitrate;\n        }\n        trackEncodings.push(encodings);\n      }\n    }\n\n    const transceiver = this.connection!.addTransceiver(track.nativeTrack, {\n      streams: [this.nativeStream],\n      direction: 'sendonly',\n      sendEncodings: trackEncodings,\n    });\n    this.setPreferredCodec(transceiver, track.nativeTrack.kind);\n    return transceiver;\n  }\n\n  async setMaxBitrate(maxBitrate: number, track: HMSLocalTrack): Promise<void> {\n    await this.connection?.setMaxBitrate(maxBitrate, track);\n  }\n\n  // @ts-ignore\n  setPreferredCodec(transceiver: RTCRtpTransceiver, kind: string) {\n    // TODO: Some browsers don't support setCodecPreferences, resort to SDPMunging?\n  }\n\n  /**\n   * On mute and unmute of video tracks as well as for changing cameras, we replace the track using replaceTrack api\n   * so as to avoid a renegotiation with the backend and reflect changes faster.\n   * @param track - the current track\n   * @param withTrack - the track to replace it with\n   */\n  async replaceTrack(track: MediaStreamTrack, withTrack: MediaStreamTrack) {\n    await this.replaceSenderTrack(track, withTrack);\n    track.stop(); // If the track is already stopped, this does not throw any error. 😉\n    this.replaceStreamTrack(track, withTrack);\n  }\n\n  replaceStreamTrack(track: MediaStreamTrack, withTrack: MediaStreamTrack) {\n    this.nativeStream.addTrack(withTrack);\n    this.nativeStream.removeTrack(track);\n  }\n\n  /**\n   * In case of video plugins we need to replace the track sent to remote without stopping the original one. As\n   * if the original is stopped, plugin would stop getting input frames to process. So only the track in the\n   * sender needs to be replaced.\n   */\n  async replaceSenderTrack(track: MediaStreamTrack, withTrack: MediaStreamTrack) {\n    const sender = this.connection?.getSenders().find((sender) => sender.track && sender.track!.id === track.id);\n\n    if (sender === undefined) {\n      HMSLogger.w(TAG, `No sender found for trackId=${track.id}`);\n      return;\n    }\n    await sender.replaceTrack(withTrack);\n  }\n\n  removeSender(track: HMSLocalTrack) {\n    let removedSenderCount = 0;\n    this.connection!.getSenders().forEach((sender) => {\n      if (sender.track?.id === track.trackId || sender.track?.id === track.getTrackIDBeingSent()) {\n        this.connection!.removeTrack(sender);\n        removedSenderCount += 1;\n\n        // Remove the local reference as well\n        const toRemoveLocalTrackIdx = this.tracks.indexOf(track);\n        if (toRemoveLocalTrackIdx !== -1) {\n          this.tracks.splice(toRemoveLocalTrackIdx, 1);\n        } else {\n          HMSLogger.e(TAG, `Cannot find ${track.trackId} in locally stored tracks`);\n        }\n      }\n    });\n    if (removedSenderCount !== 1) {\n      HMSLogger.e(TAG, `Removed ${removedSenderCount} sender's, expected to remove 1`);\n    }\n  }\n\n  trackUpdate(track: HMSLocalTrack) {\n    this.connection?.trackUpdate(track);\n  }\n\n  private static async getNativeLocalTracks(\n    fetchTrackOptions: IFetchAVTrackOptions = { audio: false, video: false },\n    settings?: HMSTrackSettings,\n  ) {\n    const nativeVideoTrack =\n      fetchTrackOptions.video === 'empty'\n        ? getEmptyVideoTrack()\n        : fetchTrackOptions.video && settings?.video && (await getVideoTrack(settings.video));\n    const nativeAudioTrack =\n      fetchTrackOptions.audio === 'empty'\n        ? getEmptyAudioTrack()\n        : fetchTrackOptions.audio && settings?.audio && (await getAudioTrack(settings.audio));\n\n    const nativeTracks: MediaStreamTrack[] = [];\n    if (nativeAudioTrack) nativeTracks.push(nativeAudioTrack);\n    if (nativeVideoTrack) nativeTracks.push(nativeVideoTrack);\n    return nativeTracks;\n  }\n}\n","import { HMSAudioListener, HMSPeerUpdate, HMSSpeaker, HMSUpdateListener } from '../../interfaces';\nimport { HMSAudioTrack } from '../../media/tracks';\nimport { IStore } from '../../sdk/store';\nimport { SpeakerList } from '../HMSNotifications';\n\nexport class ActiveSpeakerManager {\n  constructor(private store: IStore, public listener?: HMSUpdateListener, public audioListener?: HMSAudioListener) {}\n\n  handleActiveSpeakers(speakerList: SpeakerList) {\n    const speakers = speakerList['speaker-list'];\n    const hmsSpeakers: HMSSpeaker[] = speakers.map((speaker) => ({\n      audioLevel: speaker.level,\n      peer: this.store.getPeerById(speaker.peer_id)!,\n      track: this.store.getTrackById(speaker.track_id) as HMSAudioTrack,\n    }));\n\n    this.audioListener?.onAudioLevelUpdate(hmsSpeakers);\n    this.store.updateSpeakers(hmsSpeakers);\n    const dominantSpeaker = speakers[0];\n\n    if (dominantSpeaker) {\n      const dominantSpeakerPeer = this.store.getPeerById(dominantSpeaker.peer_id);\n      this.listener?.onPeerUpdate(HMSPeerUpdate.BECAME_DOMINANT_SPEAKER, dominantSpeakerPeer!);\n    } else {\n      this.listener?.onPeerUpdate(HMSPeerUpdate.RESIGNED_DOMINANT_SPEAKER, null);\n    }\n  }\n}\n","import { HMSRole } from '../../interfaces';\nimport { HMSMessage } from '../../interfaces/message';\nimport { ISignalParamsProvider } from '../../signal/ISignalSendParamsProvider';\nimport { SendMessage } from '../../notification-manager';\nimport { HMSPeer } from './peer';\n\nexport default class Message implements HMSMessage, ISignalParamsProvider<SendMessage> {\n  sender: HMSPeer;\n  recipientPeer?: HMSPeer;\n  recipientRoles?: HMSRole[];\n  message: any;\n  time: Date;\n  type: string;\n\n  constructor({ sender, message, type = 'chat', recipientPeer, recipientRoles, time }: HMSMessage) {\n    this.sender = sender;\n    this.message = message;\n    this.type = type;\n    this.recipientPeer = recipientPeer;\n    this.recipientRoles = recipientRoles;\n    this.time = time;\n  }\n\n  toSignalParams() {\n    const roles = this.recipientRoles?.map((role) => role.name);\n    const peer = this.recipientPeer?.peerId;\n    const sendParams: SendMessage = {\n      info: {\n        sender: this.sender.peerId,\n        message: this.message,\n        type: this.type,\n      },\n    };\n    if (roles?.length) {\n      sendParams.roles = roles;\n    }\n    if (peer) {\n      sendParams.peer_id = peer;\n    }\n    return sendParams;\n  }\n}\n","import { HMSPeer as IHMSPeer } from '../../../interfaces/peer';\nimport { HMSRole } from '../../../interfaces/role';\nimport { HMSAudioTrack, HMSTrack, HMSVideoTrack } from '../../../media/tracks';\n\nexport type HMSPeerInit = {\n  peerId: string;\n  name: string;\n  isLocal: boolean;\n  customerUserId?: string;\n  customerDescription?: string;\n  role?: HMSRole;\n};\n\nexport class HMSPeer implements IHMSPeer {\n  readonly peerId: string;\n  readonly isLocal: boolean;\n  name: string;\n  customerUserId?: string = '';\n  customerDescription?: string = '';\n  audioTrack?: HMSAudioTrack;\n  videoTrack?: HMSVideoTrack;\n  auxiliaryTracks: HMSTrack[] = [];\n  role?: HMSRole;\n\n  constructor({ peerId, name, isLocal, customerUserId, customerDescription, role }: HMSPeerInit) {\n    this.name = name;\n    this.peerId = peerId;\n    this.isLocal = isLocal;\n    this.customerUserId = customerUserId;\n    this.customerDescription = customerDescription;\n\n    if (role) {\n      this.role = role;\n    }\n  }\n\n  updateRole(newRole: HMSRole) {\n    this.role = newRole;\n  }\n}\n","import { v4 as uuidv4 } from 'uuid';\n\nexport default class HMSIdFactory {\n  static makePeerId = () => uuidv4();\n}\n","export enum TransportState {\n  Disconnected,\n  Connecting,\n  Joined,\n  Failed,\n  Reconnecting,\n  Leaving,\n}\n","import { HMSLocalPeer as IHMSLocalPeer } from '../../../interfaces/peer';\nimport { HMSPeer, HMSPeerInit } from './HMSPeer';\nimport { HMSLocalAudioTrack, HMSLocalTrack, HMSLocalVideoTrack } from '../../../media/tracks';\nimport HMSIdFactory from '../../../utils/id-factory';\n\ntype HMSLocalPeerInit = Omit<HMSPeerInit, 'isLocal' | 'peerId'>;\n\nexport class HMSLocalPeer extends HMSPeer implements IHMSLocalPeer {\n  isLocal: boolean = true;\n  audioTrack?: HMSLocalAudioTrack;\n  videoTrack?: HMSLocalVideoTrack;\n  auxiliaryTracks: HMSLocalTrack[] = [];\n\n  constructor(peerData: HMSLocalPeerInit) {\n    super({ ...peerData, peerId: HMSIdFactory.makePeerId(), isLocal: true });\n  }\n}\n","import { HMSRemotePeer as IHMSRemotePeer } from '../../../interfaces/peer';\nimport { HMSPeer, HMSPeerInit } from './HMSPeer';\nimport { HMSRemoteAudioTrack, HMSRemoteTrack, HMSRemoteVideoTrack } from '../../../media/tracks';\n\ntype HMSRemotePeerInit = Omit<HMSPeerInit, 'isLocal'>;\n\nexport class HMSRemotePeer extends HMSPeer implements IHMSRemotePeer {\n  isLocal: boolean = false;\n  audioTrack?: HMSRemoteAudioTrack;\n  videoTrack?: HMSRemoteVideoTrack;\n  auxiliaryTracks: HMSRemoteTrack[] = [];\n\n  constructor(peerData: HMSRemotePeerInit) {\n    super({ ...peerData, isLocal: false });\n  }\n}\n","import { HMSUpdateListener } from '../../interfaces';\nimport Message from '../../sdk/models/HMSMessage';\nimport { HMSPeer } from '../../sdk/models/peer';\nimport { IStore } from '../../sdk/store';\nimport HMSLogger from '../../utils/logger';\nimport { MessageNotification } from '../HMSNotifications';\n\nexport class BroadcastManager {\n  constructor(private store: IStore, public listener?: HMSUpdateListener) {}\n\n  private get TAG() {\n    return `[${this.constructor.name}]`;\n  }\n\n  handleBroadcast(messageNotification: MessageNotification) {\n    const notifPeer = messageNotification.peer;\n    const notifMessage = messageNotification.info;\n    const notifRoles = messageNotification.roles;\n    // If sender peerId is available in store, use that peer.\n    let sender = this.store.getPeerById(notifPeer.peer_id);\n    // If not available in store, use peer data from received broadcast message from Biz\n    if (!sender) {\n      sender = new HMSPeer({\n        peerId: notifPeer.peer_id,\n        name: notifPeer.info.name,\n        isLocal: false,\n        customerUserId: notifPeer.info.user_id,\n        customerDescription: notifPeer.info.data,\n      });\n    }\n\n    let recipientPeer;\n    const recipientRoles = [];\n\n    if (notifRoles?.length) {\n      const knownRoles = this.store.getKnownRoles();\n      for (const role of notifRoles) {\n        if (knownRoles[role]) {\n          recipientRoles.push(knownRoles[role]);\n        }\n      }\n    }\n\n    if (messageNotification.private) {\n      const peer = this.store.getLocalPeer();\n      recipientPeer = peer;\n    }\n\n    const hmsMessage = new Message({\n      ...notifMessage,\n      sender,\n      recipientRoles,\n      recipientPeer,\n      time: new Date(messageNotification.timestamp),\n    });\n    HMSLogger.d(this.TAG, `Received Message:: `, hmsMessage);\n    this.listener?.onMessageReceived(hmsMessage);\n  }\n}\n","import { HMSUpdateListener } from '../..';\nimport { HMSTrackUpdate } from '../../interfaces';\nimport { HMSPeer } from '../../sdk/models/peer';\nimport { IStore } from '../../sdk/store';\nimport HMSLogger from '../../utils/logger';\nimport { PeerListNotification, PeerNotification } from '../HMSNotifications';\nimport { PeerManager } from './PeerManager';\nimport { TrackManager } from './TrackManager';\n\n/**\n * Handles:\n * - Initial Peer List - get peer and track meta-data for peers who are already in the room when you join\n * - Reconnect Peer List - Handle peer and track changes in the room missed out due to reconnection\n *\n * Cases to handle in reconnect peer list:\n * - Add additional peers as peer join\n * - Remove missing peers as peer leave\n * - For existing peers:\n *    - Add new tracks as track add\n *    - Remove missing tracks as track remove\n *    - Track state change(enabled) as track update\n */\nexport class PeerListManager {\n  constructor(\n    private store: IStore,\n    private peerManager: PeerManager,\n    private trackManager: TrackManager,\n    public listener?: HMSUpdateListener,\n  ) {}\n\n  private get TAG() {\n    return `[${this.constructor.name}]`;\n  }\n\n  handleInitialPeerList = (peerList: PeerListNotification) => {\n    const peers = Object.values(peerList.peers);\n    this.peerManager.handlePeerList(peers);\n  };\n\n  handleReconnectPeerList = (peerList: PeerListNotification) => {\n    const currentPeerList = this.store.getRemotePeers();\n    const peers = Object.values(peerList.peers);\n    const peersToRemove = currentPeerList.filter((hmsPeer) => !peerList.peers.hasOwnProperty(hmsPeer.peerId));\n\n    HMSLogger.d(this.TAG, { peersToRemove });\n\n    // Send peer-leave updates to all the missing peers\n    peersToRemove.forEach((peer) => {\n      const peerNotification: PeerNotification = {\n        peer_id: peer.peerId,\n        role: peer.role?.name || '',\n        info: {\n          name: peer.name,\n          data: peer.customerDescription || '',\n          user_id: peer.customerUserId || '',\n        },\n        tracks: {},\n      };\n\n      this.peerManager.handlePeerLeave(peerNotification);\n    });\n\n    // Check for any tracks which are added/removed\n    peers.forEach((newPeerNotification) => {\n      const oldPeer = this.store.getPeerById(newPeerNotification.peer_id);\n      const newPeerTrackStates = Object.values(newPeerNotification.tracks);\n\n      if (oldPeer) {\n        // Peer already present in room, we take diff between the tracks\n        const tracks = this.store.getPeerTracks(oldPeer.peerId);\n\n        // Remove all the tracks which are not present in the peer.tracks\n        tracks.forEach((track) => {\n          if (!newPeerNotification.tracks.hasOwnProperty(track.trackId)) {\n            this.removePeerTrack(oldPeer, track.trackId);\n            this.listener?.onTrackUpdate(HMSTrackUpdate.TRACK_REMOVED, track, oldPeer);\n          }\n        });\n\n        // Add track-metadata for all the new tracks\n        newPeerTrackStates.forEach((trackData) => {\n          if (!this.store.getTrackById(trackData.track_id)) {\n            // NOTE: We assume that, once the connection is re-established,\n            //  transport layer will send a native onTrackAdd\n            this.store.setTrackState({\n              peerId: oldPeer.peerId,\n              trackInfo: trackData,\n            });\n          }\n        });\n\n        // Handle RTC track add and track state change.\n        this.trackManager.handleTrackUpdate({\n          peer: { info: newPeerNotification.info, peer_id: newPeerNotification.peer_id },\n          tracks: newPeerNotification.tracks,\n        });\n      } else {\n        // New peer joined while reconnecting\n        this.peerManager.handlePeerJoin(newPeerNotification);\n      }\n    });\n  };\n\n  private removePeerTrack(peer: HMSPeer, trackId: string) {\n    if (peer.audioTrack?.trackId === trackId) {\n      peer.audioTrack = undefined;\n    } else if (peer.videoTrack?.trackId === trackId) {\n      peer.videoTrack = undefined;\n    } else {\n      const trackIndex = peer.auxiliaryTracks.findIndex((track) => track.trackId === trackId);\n      trackIndex >= 0 && peer.auxiliaryTracks.splice(trackIndex, 1);\n    }\n  }\n}\n","import { HMSPeerUpdate, HMSTrackUpdate, HMSUpdateListener } from '../../interfaces';\nimport { HMSRemotePeer } from '../../sdk/models/peer';\nimport { IStore } from '../../sdk/store';\nimport HMSLogger from '../../utils/logger';\nimport { PeerNotification } from '../HMSNotifications';\nimport { TrackManager } from './TrackManager';\n\n/**\n * Handles:\n * - New peer join\n * - Peer Leave\n * - Role update for peer\n *\n * Notes:\n * - Peer join comes with track meta-data,\n * we add it to the store and call TrackManager to process it when RTC Track comes in.\n */\nexport class PeerManager {\n  constructor(private store: IStore, private trackManager: TrackManager, public listener?: HMSUpdateListener) {}\n\n  private get TAG() {\n    return `[${this.constructor.name}]`;\n  }\n\n  handlePeerList = (peers: PeerNotification[]) => {\n    if (peers.length === 0) return;\n    let hmsPeers: HMSRemotePeer[] = [];\n    for (let peer of peers) {\n      hmsPeers.push(this.makePeer(peer));\n    }\n    this.listener?.onPeerUpdate(HMSPeerUpdate.PEER_LIST, hmsPeers);\n    this.trackManager.processPendingTracks();\n  };\n\n  handlePeerJoin = (peer: PeerNotification) => {\n    const hmsPeer = this.makePeer(peer);\n\n    this.listener?.onPeerUpdate(HMSPeerUpdate.PEER_JOINED, hmsPeer);\n    this.trackManager.processPendingTracks();\n  };\n\n  handlePeerLeave = (peer: PeerNotification) => {\n    const hmsPeer = this.store.getPeerById(peer.peer_id);\n    this.store.removePeer(peer.peer_id);\n    HMSLogger.d(this.TAG, `PEER_LEAVE event`, peer, this.store.getPeers());\n\n    if (!hmsPeer) {\n      return;\n    }\n\n    if (hmsPeer.audioTrack) {\n      this.listener?.onTrackUpdate(HMSTrackUpdate.TRACK_REMOVED, hmsPeer.audioTrack, hmsPeer);\n    }\n\n    if (hmsPeer.videoTrack) {\n      this.listener?.onTrackUpdate(HMSTrackUpdate.TRACK_REMOVED, hmsPeer.videoTrack, hmsPeer);\n    }\n\n    hmsPeer.auxiliaryTracks?.forEach((track) => {\n      this.listener?.onTrackUpdate(HMSTrackUpdate.TRACK_REMOVED, track, hmsPeer);\n    });\n\n    this.listener?.onPeerUpdate(HMSPeerUpdate.PEER_LEFT, hmsPeer);\n  };\n\n  handlePeerUpdate(notification: PeerNotification) {\n    const peer = this.store.getPeerById(notification.peer_id);\n\n    if (!peer) {\n      return;\n    }\n\n    if (peer.role && peer.role.name !== notification.role) {\n      const newRole = this.store.getPolicyForRole(notification.role);\n      peer.updateRole(newRole);\n      this.listener?.onPeerUpdate(HMSPeerUpdate.ROLE_UPDATED, peer);\n    }\n  }\n\n  private makePeer(peer: PeerNotification) {\n    const hmsPeer = new HMSRemotePeer({\n      peerId: peer.peer_id,\n      name: peer.info.name,\n      customerUserId: peer.info.user_id,\n      customerDescription: peer.info.data,\n      role: this.store.getPolicyForRole(peer.role),\n    });\n\n    this.store.addPeer(hmsPeer);\n    HMSLogger.d(this.TAG, `adding to the peerList`, hmsPeer);\n\n    for (const trackId in peer.tracks) {\n      this.store.setTrackState({\n        peerId: peer.peer_id,\n        trackInfo: peer.tracks[trackId],\n      });\n    }\n    return hmsPeer;\n  }\n}\n","import EventEmitter from 'events';\nimport { IStore } from '../../sdk/store';\nimport { PolicyParams } from '../HMSNotifications';\n\n/**\n * Handles:\n * - Set policy with publishParams, simulcast layers to store\n * - Emit 'local-peer-role-update' to trigger RoleChangeManager to publish/unpublish local tracks\n * - Emit 'policy-change' to finish preview before calling listener.onPreview\n */\nexport class PolicyChangeManager {\n  constructor(private store: IStore, private eventEmitter: EventEmitter) {}\n\n  handlePolicyChange(params: PolicyParams) {\n    const localPeer = this.store.getLocalPeer();\n\n    if (localPeer && !localPeer.role) {\n      const newRole = params.known_roles[params.name];\n      localPeer.updateRole(newRole);\n    }\n\n    this.store.setKnownRoles(params.known_roles);\n    // handle when role is not present in known_roles\n    const publishParams = params.known_roles[params.name]?.publishParams;\n    this.store.setPublishParams(publishParams);\n    if (publishParams && Object.keys(publishParams).length > 0) {\n      const { videoSimulcastLayers, screenSimulcastLayers } = publishParams;\n      this.store.setVideoSimulcastLayers(videoSimulcastLayers);\n      this.store.setScreenshareSimulcastLayers(screenSimulcastLayers);\n    }\n\n    if (localPeer?.role && localPeer.role.name !== params.name) {\n      const newRole = this.store.getPolicyForRole(params.name);\n      const oldRole = localPeer.role;\n      localPeer.updateRole(newRole);\n      this.eventEmitter.emit('local-peer-role-update', { detail: { oldRole, newRole } });\n    }\n    this.eventEmitter.emit('policy-change', { detail: { params } });\n  }\n}\n","import { HMSLocalTrack } from '../../media/tracks';\nimport { HMSRemotePeer, HMSRoleChangeRequest, HMSUpdateListener } from '../../interfaces';\nimport { IStore } from '../../sdk/store';\nimport {\n  RoleChangeRequestParams,\n  TrackUpdateRequestNotification,\n  ChangeTrackMuteStateNotification,\n} from '../HMSNotifications';\n\n/**\n * Handles request from remote peers to change something on the local side. For eg. role change, track mute/unmute.\n */\nexport class RequestManager {\n  constructor(private store: IStore, public listener?: HMSUpdateListener) {}\n\n  handleRoleChangeRequest(notification: RoleChangeRequestParams) {\n    const request: HMSRoleChangeRequest = {\n      requestedBy: this.store.getPeerById(notification.requested_by) as HMSRemotePeer,\n      role: this.store.getPolicyForRole(notification.role),\n      token: notification.token,\n    };\n\n    this.listener?.onRoleChangeRequest(request);\n  }\n\n  handleTrackUpdateRequest(trackUpdateRequest: TrackUpdateRequestNotification) {\n    const { requested_by, track_id, mute } = trackUpdateRequest;\n    const peer = this.store.getPeerById(requested_by);\n    const track = this.store.getLocalPeerTracks().find((track) => track.publishedTrackId === track_id);\n\n    if (!peer || peer.isLocal || !track) {\n      return;\n    }\n\n    const sendNotification = () => {\n      this.listener?.onChangeTrackStateRequest({ requestedBy: peer as HMSRemotePeer, track, enabled: !mute });\n    };\n\n    if (mute) {\n      // if track is already in the same state as change state, do nothing\n      if (track.enabled === !mute) {\n        return;\n      }\n      /**\n       * Directly mute track when request arrives\n       */\n      track.setEnabled(!mute).then(sendNotification);\n    } else {\n      /**\n       * Notify UI to unmute for requesting consent\n       */\n      sendNotification();\n    }\n  }\n\n  handleChangeTrackStateRequest(request: ChangeTrackMuteStateNotification) {\n    const { type, source, value, requested_by } = request;\n    const peer = this.store.getPeerById(requested_by);\n\n    if (!peer) {\n      return;\n    }\n    // value true means the track has to be muted\n    const enabled = !value;\n    const localPeerTracks = this.store.getLocalPeerTracks();\n    let tracks: HMSLocalTrack[] = localPeerTracks;\n    if (type) {\n      tracks = tracks.filter((track) => track.type === type);\n    }\n\n    if (source) {\n      tracks = tracks.filter((track) => track.source === source);\n    }\n\n    const tracksToBeUpdated = tracks.filter((track) => track.enabled !== enabled);\n    //Do nothing if all tracks are already in same state as the request\n    if (tracksToBeUpdated.length === 0) {\n      return;\n    }\n    // if track is to be muted, mute and send the notification, otherwise send notification\n    if (!enabled) {\n      const promises: Promise<void>[] = [];\n\n      for (let track of tracksToBeUpdated) {\n        promises.push(track.setEnabled(false));\n      }\n      Promise.all(promises).then(() => {\n        this.listener?.onChangeMultiTrackStateRequest({\n          requestedBy: peer as HMSRemotePeer,\n          tracks: tracksToBeUpdated,\n          enabled: false,\n        });\n      });\n    } else {\n      this.listener?.onChangeMultiTrackStateRequest({\n        requestedBy: peer as HMSRemotePeer,\n        tracks: tracksToBeUpdated,\n        type,\n        source,\n        enabled: true,\n      });\n    }\n  }\n}\n","import { RecordingNotification, PeerListNotification } from '../HMSNotifications';\nimport { HMSUpdateListener, HMSRoomUpdate } from '../../interfaces';\nimport { IStore } from '../../sdk/store';\n\nexport class RoomUpdateManager {\n  constructor(private store: IStore, public listener?: HMSUpdateListener) {}\n\n  onPeerList(notification: PeerListNotification) {\n    const { recording, streaming } = notification.room;\n    const room = this.store.getRoom();\n    if (!room.recording) {\n      room.recording = this.getDefaultRecordingState();\n    }\n    if (!room.rtmp) {\n      room.rtmp = {\n        running: false,\n      };\n    }\n    room.recording.server.running = recording.sfu.enabled;\n    room.recording.browser.running = recording.beam.enabled;\n    room.rtmp.running = streaming.enabled;\n    this.listener?.onRoomUpdate(HMSRoomUpdate.RECORDING_STATE_UPDATED, room);\n  }\n\n  onRTMPStart() {\n    this.setRTMPStatus(true);\n  }\n\n  onRTMPStop() {\n    this.setRTMPStatus(false);\n  }\n\n  onRecordingStart(notification: RecordingNotification) {\n    this.setRecordingStatus(notification.type, true);\n  }\n\n  onRecordingStop(notification: RecordingNotification) {\n    this.setRecordingStatus(notification.type, false);\n  }\n\n  private setRecordingStatus(type: 'sfu' | 'Browser', running: boolean) {\n    const room = this.store.getRoom();\n    if (!room.recording) {\n      room.recording = this.getDefaultRecordingState();\n    }\n    let action: number = -1;\n    if (type === 'sfu') {\n      room.recording.server.running = running;\n      action = HMSRoomUpdate.SERVER_RECORDING_STATE_UPDATED;\n    } else {\n      room.recording.browser.running = running;\n      action = HMSRoomUpdate.BROWSER_RECORDING_STATE_UPDATED;\n    }\n    this.listener?.onRoomUpdate(action, room);\n  }\n\n  private setRTMPStatus(running: boolean) {\n    const room = this.store.getRoom();\n    if (!room.rtmp) {\n      room.rtmp = {\n        running: false,\n      };\n    }\n    room.rtmp.running = running;\n    this.listener?.onRoomUpdate(HMSRoomUpdate.RTMP_STREAMING_STATE_UPDATED, room);\n  }\n\n  private getDefaultRecordingState() {\n    return {\n      browser: {\n        running: false,\n      },\n      server: {\n        running: false,\n      },\n    };\n  }\n}\n","import { EventEmitter } from 'events';\nimport { HMSTrackUpdate, HMSUpdateListener } from '../../interfaces';\nimport { HMSRemoteAudioTrack, HMSRemoteTrack, HMSRemoteVideoTrack, HMSTrackType } from '../../media/tracks';\nimport { IStore } from '../../sdk/store';\nimport HMSLogger from '../../utils/logger';\nimport { TrackStateNotification } from '../HMSNotifications';\n\n/**\n * Handles:\n * - Incoming track meta-data from BIZ(signal) to match a track to a peer.\n * - Incoming MediaStreamTracks(wrapped in HMSTracks) from RTCMediaChannel.\n * - Mute/unmute track meta-data updates from BIZ.\n *\n * Since track meta-data and RTC tracks come in asynchronously,\n * we store the track meta-data(TrackState) in SDK Store and tracks temporarily here in tracksToProcess.\n *\n * Once we have both TrackState and track,\n * we add it to peer, send listener.onTrackUpdate and remove it from tracksToProcess.\n *\n * Gotchas:\n * - TRACK_UPDATE comes before TRACK_ADD -> update state, process pending tracks when TRACK_ADD arrives.\n */\nexport class TrackManager {\n  private tracksToProcess: Map<string, HMSRemoteTrack> = new Map();\n\n  private get TAG() {\n    return `[${this.constructor.name}]`;\n  }\n\n  constructor(private store: IStore, private eventEmitter: EventEmitter, public listener?: HMSUpdateListener) {}\n\n  handleTrackMetadataAdd(params: TrackStateNotification) {\n    HMSLogger.d(this.TAG, `TRACK_METADATA_ADD`, params);\n\n    for (const trackId in params.tracks) {\n      this.store.setTrackState({\n        peerId: params.peer.peer_id,\n        trackInfo: params.tracks[trackId],\n      });\n    }\n\n    this.processPendingTracks();\n  }\n\n  /**\n   * Sets the tracks to peer and returns the peer\n   */\n  handleTrackAdd = (track: HMSRemoteTrack) => {\n    HMSLogger.d(this.TAG, `ONTRACKADD`, track, track.nativeTrack);\n    this.store.addTrack(track);\n    this.tracksToProcess.set(track.trackId, track);\n    this.processPendingTracks();\n  };\n\n  /**\n   * Sets the track of corresponding peer to null and returns the peer\n   */\n  handleTrackRemove = (track: HMSRemoteTrack) => {\n    HMSLogger.d(this.TAG, `ONTRACKREMOVE`, track, track.nativeTrack);\n    const trackStateEntry = this.store.getTrackState(track.trackId);\n\n    if (!trackStateEntry) return;\n\n    // emit this event here as peer will already be removed(if left the room) by the time this event is received\n    track.type === HMSTrackType.AUDIO && this.eventEmitter.emit('track-removed', { detail: track });\n    const hmsPeer = this.store.getPeerById(trackStateEntry.peerId);\n    if (!hmsPeer) {\n      return;\n    }\n\n    const removeAuxiliaryTrack = () => {\n      const auxiliaryTrackIndex = hmsPeer.auxiliaryTracks.indexOf(track);\n      if (auxiliaryTrackIndex > -1) {\n        hmsPeer.auxiliaryTracks.splice(auxiliaryTrackIndex, 1);\n      }\n    };\n\n    switch (track.type) {\n      case HMSTrackType.AUDIO:\n        if (track.source !== 'regular') {\n          removeAuxiliaryTrack();\n        } else {\n          hmsPeer.audioTrack = undefined;\n        }\n        break;\n      case HMSTrackType.VIDEO: {\n        if (track.source !== 'regular') {\n          removeAuxiliaryTrack();\n        } else {\n          hmsPeer.videoTrack = undefined;\n        }\n      }\n    }\n\n    this.store.removeTrack(track.trackId);\n    this.listener?.onTrackUpdate(HMSTrackUpdate.TRACK_REMOVED, track, hmsPeer);\n  };\n\n  handleTrackUpdate = (params: TrackStateNotification) => {\n    HMSLogger.d(this.TAG, `TRACK_UPDATE`, params);\n\n    const hmsPeer = this.store.getPeerById(params.peer.peer_id);\n    if (!hmsPeer) {\n      return;\n    }\n\n    for (const trackId in params.tracks) {\n      const currentTrackStateInfo = Object.assign({}, this.store.getTrackState(trackId)?.trackInfo);\n\n      const trackEntry = params.tracks[trackId];\n      const track = this.store.getTrackById(trackId);\n\n      this.store.setTrackState({\n        peerId: params.peer.peer_id,\n        trackInfo: { ...currentTrackStateInfo, ...trackEntry },\n      });\n\n      // TRACK_UPDATE came before TRACK_ADD -> update state, process pending tracks when TRACK_ADD arrives.\n      if (!track || this.tracksToProcess.has(trackId)) {\n        this.processPendingTracks();\n      } else {\n        track.setEnabled(!trackEntry.mute);\n        if (currentTrackStateInfo.mute !== trackEntry.mute) {\n          if (trackEntry.mute) {\n            this.listener?.onTrackUpdate(HMSTrackUpdate.TRACK_MUTED, track, hmsPeer);\n          } else {\n            this.listener?.onTrackUpdate(HMSTrackUpdate.TRACK_UNMUTED, track, hmsPeer);\n          }\n          track.type === HMSTrackType.AUDIO &&\n            this.eventEmitter.emit('track-updated', { detail: { track, enabled: !trackEntry.mute } });\n        } else if (currentTrackStateInfo.description !== trackEntry.description) {\n          this.listener?.onTrackUpdate(HMSTrackUpdate.TRACK_DESCRIPTION_CHANGED, track, hmsPeer);\n        }\n      }\n    }\n  };\n\n  processPendingTracks() {\n    const tracksCopy = new Map(this.tracksToProcess);\n\n    tracksCopy.forEach((track) => {\n      const state = this.store.getTrackState(track.trackId);\n      if (!state) {\n        return;\n      }\n\n      const hmsPeer = this.store.getPeerById(state.peerId);\n      if (!hmsPeer) {\n        return;\n      }\n\n      track.source = state.trackInfo.source;\n      track.peerId = hmsPeer.peerId;\n      track.setEnabled(!state.trackInfo.mute);\n\n      switch (track.type) {\n        case HMSTrackType.AUDIO:\n          if (!hmsPeer.audioTrack && track.source === 'regular') {\n            hmsPeer.audioTrack = track as HMSRemoteAudioTrack;\n          } else {\n            hmsPeer.auxiliaryTracks.push(track);\n          }\n          break;\n        case HMSTrackType.VIDEO:\n          const remoteTrack = track as HMSRemoteVideoTrack;\n          const simulcastDefinitions = this.store.getSimulcastDefinitionsForPeer(hmsPeer, remoteTrack.source!);\n          remoteTrack.setSimulcastDefinitons(simulcastDefinitions);\n          if (!hmsPeer.videoTrack && track.source === 'regular') {\n            hmsPeer.videoTrack = remoteTrack;\n          } else {\n            hmsPeer.auxiliaryTracks.push(remoteTrack);\n          }\n      }\n\n      /**\n       * Don't call onTrackUpdate for audio elements immediately because the operations(eg: setVolume) performed\n       * on onTrackUpdate can be overriden in AudioSinkManager when audio element is created\n       **/\n      track.type === HMSTrackType.AUDIO\n        ? this.eventEmitter.emit('track-added', { detail: { track, peer: hmsPeer } })\n        : this.listener?.onTrackUpdate(HMSTrackUpdate.TRACK_ADDED, track, hmsPeer);\n      this.tracksToProcess.delete(track.trackId);\n    });\n  }\n}\n","import EventEmitter from 'events';\nimport { HMSAudioListener, HMSUpdateListener } from '../interfaces';\nimport { HMSRemoteTrack } from '../media/tracks';\nimport { IStore } from '../sdk/store';\nimport HMSLogger from '../utils/logger';\nimport { HMSNotificationMethod } from './HMSNotificationMethod';\nimport {\n  MessageNotification,\n  PeerNotification,\n  PeerListNotification,\n  PolicyParams,\n  RoleChangeRequestParams,\n  SpeakerList,\n  TrackStateNotification,\n  TrackUpdateRequestNotification,\n  ChangeTrackMuteStateNotification,\n  RecordingNotification,\n} from './HMSNotifications';\nimport { ActiveSpeakerManager } from './managers/ActiveSpeakerManager';\nimport { BroadcastManager } from './managers/BroadcastManager';\nimport { PeerListManager } from './managers/PeerListManager';\nimport { PeerManager } from './managers/PeerManager';\nimport { PolicyChangeManager } from './managers/PolicyChangeManager';\nimport { RequestManager } from './managers/RequestManager';\nimport { RoomUpdateManager } from './managers/RoomUpdateManager';\nimport { TrackManager } from './managers/TrackManager';\n\nexport class NotificationManager {\n  private TAG = '[HMSNotificationManager]';\n  private trackManager: TrackManager;\n  private peerManager: PeerManager;\n  private peerListManager: PeerListManager;\n  private activeSpeakerManager: ActiveSpeakerManager;\n  private broadcastManager: BroadcastManager;\n  private policyChangeManager: PolicyChangeManager;\n  private requestManager: RequestManager;\n  private roomUpdateManager: RoomUpdateManager;\n  private eventEmitter: EventEmitter = new EventEmitter();\n\n  constructor(private store: IStore, private listener?: HMSUpdateListener, private audioListener?: HMSAudioListener) {\n    this.trackManager = new TrackManager(this.store, this.eventEmitter, this.listener);\n    this.peerManager = new PeerManager(this.store, this.trackManager, this.listener);\n    this.peerListManager = new PeerListManager(this.store, this.peerManager, this.trackManager, this.listener);\n    this.broadcastManager = new BroadcastManager(this.store, this.listener);\n    this.policyChangeManager = new PolicyChangeManager(this.store, this.eventEmitter);\n    this.requestManager = new RequestManager(this.store, this.listener);\n    this.activeSpeakerManager = new ActiveSpeakerManager(this.store, this.listener, this.audioListener);\n    this.roomUpdateManager = new RoomUpdateManager(this.store, this.listener);\n  }\n\n  setListener(listener?: HMSUpdateListener) {\n    this.listener = listener;\n    this.trackManager.listener = listener;\n    this.peerManager.listener = listener;\n    this.peerListManager.listener = listener;\n    this.broadcastManager.listener = listener;\n    this.requestManager.listener = listener;\n    this.activeSpeakerManager.listener = listener;\n    this.roomUpdateManager.listener = listener;\n  }\n\n  setAudioListener(audioListener?: HMSAudioListener) {\n    this.audioListener = audioListener;\n    this.activeSpeakerManager.audioListener = audioListener;\n  }\n\n  addEventListener(event: string, listener: EventListener) {\n    this.eventEmitter.addListener(event, listener);\n  }\n\n  removeEventListener(event: string, listener: EventListener) {\n    this.eventEmitter.removeListener(event, listener);\n  }\n\n  once(event: string, listener: EventListener) {\n    this.eventEmitter.once(event, listener);\n  }\n\n  handleNotification(message: { method: string; params: any }, isReconnecting = false) {\n    const method = message.method as HMSNotificationMethod;\n    const notification = message.params;\n\n    if (method !== HMSNotificationMethod.ACTIVE_SPEAKERS) {\n      HMSLogger.d(this.TAG, 'Received notification', { method, notification });\n    }\n\n    switch (method) {\n      case HMSNotificationMethod.PEER_JOIN: {\n        const peer = notification as PeerNotification;\n        this.peerManager.handlePeerJoin(peer);\n        break;\n      }\n\n      case HMSNotificationMethod.PEER_LEAVE: {\n        const peer = notification as PeerNotification;\n        this.peerManager.handlePeerLeave(peer);\n        break;\n      }\n      case HMSNotificationMethod.PEER_LIST: {\n        const peerList = notification as PeerListNotification;\n        if (isReconnecting) {\n          HMSLogger.d(this.TAG, `RECONNECT_PEER_LIST event`, peerList);\n          this.peerListManager.handleReconnectPeerList(peerList);\n        } else {\n          HMSLogger.d(this.TAG, `PEER_LIST event`, peerList);\n          this.peerListManager.handleInitialPeerList(peerList);\n        }\n        this.roomUpdateManager.onPeerList(peerList);\n        break;\n      }\n      case HMSNotificationMethod.TRACK_METADATA_ADD: {\n        this.trackManager.handleTrackMetadataAdd(notification as TrackStateNotification);\n        break;\n      }\n      case HMSNotificationMethod.TRACK_UPDATE: {\n        this.trackManager.handleTrackUpdate(notification as TrackStateNotification);\n        break;\n      }\n      case HMSNotificationMethod.ACTIVE_SPEAKERS:\n        this.activeSpeakerManager.handleActiveSpeakers(notification as SpeakerList);\n        break;\n\n      case HMSNotificationMethod.BROADCAST:\n        this.broadcastManager.handleBroadcast(notification as MessageNotification);\n        break;\n\n      case HMSNotificationMethod.POLICY_CHANGE:\n        this.policyChangeManager.handlePolicyChange(notification as PolicyParams);\n        break;\n\n      case HMSNotificationMethod.ROLE_CHANGE_REQUEST:\n        this.requestManager.handleRoleChangeRequest(notification as RoleChangeRequestParams);\n        break;\n\n      case HMSNotificationMethod.TRACK_UPDATE_REQUEST:\n        this.requestManager.handleTrackUpdateRequest(notification as TrackUpdateRequestNotification);\n        break;\n\n      case HMSNotificationMethod.CHANGE_TRACK_MUTE_STATE_UPDATE:\n        this.requestManager.handleChangeTrackStateRequest(notification as ChangeTrackMuteStateNotification);\n        break;\n\n      case HMSNotificationMethod.PEER_UPDATE:\n        this.peerManager.handlePeerUpdate(notification as PeerNotification);\n        break;\n\n      case HMSNotificationMethod.RTMP_START:\n        this.roomUpdateManager.onRTMPStart();\n        break;\n      case HMSNotificationMethod.RTMP_STOP:\n        this.roomUpdateManager.onRTMPStop();\n        break;\n      case HMSNotificationMethod.RECORDING_START:\n        this.roomUpdateManager.onRecordingStart(notification as RecordingNotification);\n        break;\n      case HMSNotificationMethod.RECORDING_STOP:\n        this.roomUpdateManager.onRecordingStop(notification as RecordingNotification);\n        break;\n      default:\n        return;\n    }\n  }\n\n  handleTrackAdd = (track: HMSRemoteTrack) => {\n    this.trackManager.handleTrackAdd(track);\n  };\n\n  handleTrackRemove = (track: HMSRemoteTrack) => {\n    this.trackManager.handleTrackRemove(track);\n  };\n}\n","import { HMSTrack, HMSTrackSource } from '../media/tracks/HMSTrack';\nimport { HMSRole } from '../interfaces/role';\nimport { Track } from '../signal/interfaces';\nimport { HMSLocalTrack } from '../media/tracks';\n\n/**\n * Interfaces for message received from BIZ Signal through Websocket.\n * These messages are handled by NotificationManager\n * which will call the corresponding HMSUpdateListener callbacks.\n */\n\nexport interface TrackStateNotification {\n  tracks: {\n    [track_id: string]: TrackState;\n  };\n  peer: PeerNotificationInfo;\n}\n\nexport interface PeerNotificationInfo {\n  peer_id: string;\n  info: Info;\n}\n\nexport interface Info {\n  name: string;\n  data: string;\n  user_id: string;\n}\n\nexport interface PolicyParams {\n  name: string;\n  known_roles: {\n    [role: string]: HMSRole;\n  };\n}\n\n/**\n * This is in a format biz sends/received the track metadata\n */\nexport class TrackState implements Track {\n  mute: boolean;\n  type: 'audio' | 'video';\n  source: HMSTrackSource;\n  description: string;\n  track_id: string;\n  stream_id: string;\n\n  constructor(track: HMSLocalTrack | Track) {\n    this.type = track.type;\n    this.source = track.source || 'regular';\n    this.description = '';\n    if (track instanceof HMSTrack) {\n      this.mute = !track.enabled;\n      this.track_id = track.publishedTrackId;\n      this.stream_id = track.stream.id;\n    } else {\n      this.mute = track.mute;\n      this.track_id = track.track_id;\n      this.stream_id = track.stream_id;\n    }\n  }\n}\n\nexport interface PeerNotification {\n  peer_id: string;\n  info: Info;\n  role: string;\n  tracks: {\n    [track_id: string]: TrackState;\n  };\n}\n\nexport interface PeerListNotification {\n  peers: {\n    [peer_id: string]: PeerNotification;\n  };\n  room: {\n    name: string;\n    recording: {\n      sfu: {\n        enabled: boolean;\n      };\n      beam: {\n        enabled: boolean;\n      };\n    };\n    streaming: {\n      enabled: boolean;\n    };\n  };\n}\n\ninterface Speaker {\n  peer_id: string;\n  track_id: string;\n  level: number;\n}\n\nexport interface SpeakerList {\n  'speaker-list': Speaker[];\n}\n\n/**\n * Represents the role change request received from the server\n */\nexport interface RoleChangeRequestParams {\n  requested_by: string;\n  role: string;\n  token: string;\n}\n\nexport interface TrackUpdateRequestNotification {\n  requested_by: string;\n  track_id: string;\n  stream_id: string;\n  mute: boolean;\n}\n\nexport interface ChangeTrackMuteStateNotification {\n  requested_by: string;\n  roles?: string[];\n  type?: 'audio' | 'video';\n  source?: HMSTrackSource;\n  value: boolean;\n}\n\nexport interface PeerLeaveRequestNotification {\n  requested_by: string;\n  reason: string;\n  room_end: boolean;\n}\n\nexport interface MessageNotification {\n  peer: {\n    peer_id: string;\n    info: {\n      name: string;\n      data: any;\n      user_id: string;\n    };\n  };\n  roles?: string[];\n  private: boolean;\n  timestamp: number;\n  info: MessageNotificationInfo;\n}\n\nexport interface SendMessage {\n  info: MessageNotificationInfo;\n  roles?: string[];\n  peer_id?: string;\n}\n\nexport interface MessageNotificationInfo {\n  sender: string;\n  message: any;\n  type: string;\n  time?: string;\n}\n\nexport interface RecordingNotification {\n  type: 'sfu' | 'Browser';\n  peer: PeerNotificationInfo;\n}\n","import { HMSException } from '../error/HMSException';\nimport { HMSTrackSettings } from '../media/settings/HMSTrackSettings';\nimport { SelectedDevices } from '../device-manager';\nimport { DeviceMap } from '../interfaces';\nimport AnalyticsEvent from './AnalyticsEvent';\nimport { AnalyticsEventLevel } from './AnalyticsEventLevel';\nimport { IAnalyticsPropertiesProvider } from './IAnalyticsPropertiesProvider';\n\nexport default class AnalyticsEventFactory {\n  private static KEY_REQUESTED_AT = 'requested_at';\n  private static KEY_RESPONDED_AT = 'responded_at';\n\n  static connect(\n    error?: HMSException,\n    requestedAt: Date = new Date(),\n    respondedAt: Date = new Date(),\n    endpoint?: string,\n  ) {\n    const name = this.eventNameFor('connect', error === undefined);\n    const level = error ? AnalyticsEventLevel.ERROR : AnalyticsEventLevel.INFO;\n\n    const properties = this.getPropertiesWithError(\n      {\n        [this.KEY_REQUESTED_AT]: requestedAt?.getTime(),\n        [this.KEY_RESPONDED_AT]: respondedAt?.getTime(),\n        endpoint,\n      },\n      error,\n    );\n\n    return new AnalyticsEvent({ name, level, properties });\n  }\n\n  static disconnect(error?: HMSException) {\n    const name = 'disconnected';\n    const level = error ? AnalyticsEventLevel.ERROR : AnalyticsEventLevel.INFO;\n    const properties = this.getPropertiesWithError({}, error);\n\n    return new AnalyticsEvent({ name, level, properties });\n  }\n\n  static join(requestedAt: Date, respondedAt: Date, error?: HMSException) {\n    const name = this.eventNameFor('join', error === undefined);\n    const level = error ? AnalyticsEventLevel.ERROR : AnalyticsEventLevel.INFO;\n\n    const properties = this.getPropertiesWithError(\n      {\n        [this.KEY_REQUESTED_AT]: requestedAt.getTime(),\n        [this.KEY_RESPONDED_AT]: respondedAt.getTime(),\n      },\n      error,\n    );\n\n    return new AnalyticsEvent({ name, level, properties });\n  }\n\n  static publish({\n    devices,\n    settings,\n    error,\n  }: {\n    devices?: DeviceMap;\n    settings?: HMSTrackSettings;\n    error?: HMSException;\n  }) {\n    const name = this.eventNameFor('publish', error === undefined);\n    const level = error ? AnalyticsEventLevel.ERROR : AnalyticsEventLevel.INFO;\n    const properties = this.getPropertiesWithError(\n      {\n        devices,\n        audio: settings?.audio,\n        video: settings?.video,\n      },\n      error,\n    );\n    return new AnalyticsEvent({\n      name,\n      level,\n      properties,\n    });\n  }\n\n  static subscribeFail(error: HMSException) {\n    const name = this.eventNameFor('subscribe', false);\n    const level = AnalyticsEventLevel.ERROR;\n    const properties = error.toAnalyticsProperties();\n\n    return new AnalyticsEvent({ name, level, properties });\n  }\n\n  static leave() {\n    return new AnalyticsEvent({ name: 'leave', level: AnalyticsEventLevel.INFO });\n  }\n\n  static deviceChange({\n    selection,\n    type,\n    devices,\n    error,\n  }: {\n    selection: Partial<SelectedDevices>;\n    type?: 'change' | 'list';\n    devices: DeviceMap;\n    error?: HMSException;\n  }) {\n    const name = this.eventNameFor(error ? 'publish' : `device.${type}`, error === undefined);\n    const level = error ? AnalyticsEventLevel.ERROR : AnalyticsEventLevel.INFO;\n    const properties = this.getPropertiesWithError({ selection, devices }, error);\n    return new AnalyticsEvent({\n      name,\n      level,\n      properties,\n    });\n  }\n\n  static performance(stats: IAnalyticsPropertiesProvider) {\n    const name = 'perf.stats';\n    const level = AnalyticsEventLevel.INFO;\n    const properties = stats.toAnalyticsProperties();\n\n    return new AnalyticsEvent({ name, level, properties });\n  }\n\n  static rtcStats(stats: IAnalyticsPropertiesProvider) {\n    const name = 'rtc.stats';\n    const level = AnalyticsEventLevel.INFO;\n    const properties = stats.toAnalyticsProperties();\n\n    return new AnalyticsEvent({ name, level, properties });\n  }\n\n  private static eventNameFor(name: string, ok: boolean) {\n    const suffix = ok ? 'success' : 'failed';\n    return `${name}.${suffix}`;\n  }\n\n  private static getPropertiesWithError(initialProperties: any, error?: HMSException) {\n    if (error) {\n      initialProperties = { ...error.toAnalyticsProperties(), ...initialProperties };\n    }\n    return initialProperties;\n  }\n}\n","export enum TransportFailureCategory {\n  ConnectFailed,\n  SignalDisconnect,\n  PublishIceConnectionFailed,\n  SubscribeIceConnectionFailed,\n}\n\nexport const Dependencies = {\n  [TransportFailureCategory.ConnectFailed]: [],\n  [TransportFailureCategory.SignalDisconnect]: [],\n  [TransportFailureCategory.PublishIceConnectionFailed]: [TransportFailureCategory.SignalDisconnect],\n  [TransportFailureCategory.SubscribeIceConnectionFailed]: [TransportFailureCategory.SignalDisconnect],\n};\n","export class JoinParameters {\n  constructor(\n    public authToken: string,\n    public peerId: string,\n    public peerName: string,\n    public data: string,\n    public endpoint: string,\n    public autoSubscribeVideo: boolean,\n  ) {}\n}\n","export interface PromiseCallbacks<T> {\n  resolve: (value: T) => void;\n  reject: (reason?: any) => void;\n}\n\nexport class PromiseWithCallbacks<T> {\n  promise: Promise<T>;\n  resolve!: (value: T) => void;\n  reject!: (reason?: any) => void;\n\n  constructor(cb: (resolve: (value: T) => void, reject: (reason?: any) => void) => any) {\n    this.promise = new Promise<T>((resolve, reject) => {\n      this.resolve = resolve;\n      this.reject = reject;\n      cb(resolve, reject);\n    });\n  }\n}\n","import AnalyticsEvent from '../analytics/AnalyticsEvent';\nimport AnalyticsEventFactory from '../analytics/AnalyticsEventFactory';\nimport { AnalyticsEventsService } from '../analytics/AnalyticsEventsService';\nimport { HMSException } from '../error/HMSException';\nimport { MAX_TRANSPORT_RETRIES, MAX_TRANSPORT_RETRY_DELAY } from '../utils/constants';\nimport HMSLogger from '../utils/logger';\nimport { PromiseWithCallbacks } from '../utils/promise';\nimport { TransportFailureCategory as TFC, Dependencies as TFCDependencies } from './models/TransportFailureCategory';\nimport { TransportState } from './models/TransportState';\n\n/**\n * Task which is executed by [RetryScheduler.schedule] until max retry count\n * is reached.\n *\n * Any exception raised while executing the task assumes that task is failed.\n * Failed tasks are retried if max retry count is not reached.\n *\n * @returns True if the task if successful, otherwise False\n *\n *\n */\ntype RetryTask = () => Promise<boolean>;\n\nconst TAG = '[RetryScheduler]';\n\nexport class RetryScheduler {\n  private analyticsEventsService: AnalyticsEventsService;\n  private onStateChange: (state: TransportState, error?: HMSException) => void;\n\n  private inProgress = new Map<TFC, PromiseWithCallbacks<number>>();\n  private retryTaskIds: number[] = [];\n\n  constructor(\n    analyticsEventsService: AnalyticsEventsService,\n    onStateChange: (state: TransportState, error?: HMSException) => Promise<void>,\n  ) {\n    this.analyticsEventsService = analyticsEventsService;\n    this.onStateChange = onStateChange;\n  }\n\n  async schedule(\n    category: TFC,\n    error: HMSException,\n    task: RetryTask,\n    maxFailedRetries = MAX_TRANSPORT_RETRIES,\n    changeState = true,\n  ) {\n    await this.scheduleTask(category, error, changeState, task, maxFailedRetries);\n  }\n\n  reset() {\n    this.retryTaskIds.forEach((future) => clearTimeout(future));\n    this.retryTaskIds = [];\n    this.inProgress.clear();\n  }\n\n  private async scheduleTask(\n    category: TFC,\n    error: HMSException,\n    changeState: Boolean,\n    task: RetryTask,\n    maxFailedRetries = MAX_TRANSPORT_RETRIES,\n    failedRetryCount = 0,\n  ): Promise<void> {\n    HMSLogger.d(TAG, 'schedule: ', { category: TFC[category], error });\n\n    // First schedule call\n    if (failedRetryCount === 0) {\n      const inProgressTask = this.inProgress.get(category);\n      if (inProgressTask) {\n        HMSLogger.d(TAG, `schedule: Already a task for ${TFC[category]} scheduled, waiting for its completion`);\n        await inProgressTask.promise;\n        return;\n      }\n\n      const taskPromise = new PromiseWithCallbacks<number>((_, __) => {});\n      this.inProgress.set(category, taskPromise);\n\n      this.sendEvent(error, category);\n    }\n\n    let hasFailedDependency = false;\n    const dependencies = TFCDependencies[category];\n\n    for (const dependencyIndexString in dependencies) {\n      const dependency = dependencies[parseInt(dependencyIndexString)];\n      try {\n        const dependencyTask = this.inProgress.get(dependency);\n        if (dependencyTask) {\n          HMSLogger.d(\n            TAG,\n            `schedule: Suspending retry task of ${TFC[category]}, waiting for ${TFC[dependency]} to recover`,\n          );\n          await dependencyTask.promise;\n          HMSLogger.d(\n            TAG,\n            `schedule: Resuming retry task ${TFC[category]} as it's dependency ${TFC[dependency]} is recovered`,\n          );\n        }\n      } catch (ex) {\n        HMSLogger.d(\n          TAG,\n          `schedule: Stopping retry task of ${TFC[category]} as it's dependency ${TFC[dependency]} failed to recover`,\n        );\n        hasFailedDependency = true;\n        break;\n      }\n    }\n\n    if (failedRetryCount >= maxFailedRetries || hasFailedDependency) {\n      error.description += `. [${TFC[category]}] Could not recover after ${failedRetryCount} tries`;\n\n      if (hasFailedDependency) {\n        error.description += ` Could not recover all of it's required dependencies - [${(dependencies as Array<TFC>)\n          .map((dep) => TFC[dep])\n          .toString()}]`;\n      }\n      error.isTerminal = true;\n\n      // @NOTE: Don't reject to throw error for dependencies, use onStateChange\n      // const taskPromise = this.inProgress.get(category);\n      this.inProgress.delete(category);\n      // taskPromise?.reject(error);\n      this.sendEvent(error, category);\n\n      this.reset();\n\n      if (changeState) {\n        this.onStateChange(TransportState.Failed, error);\n      } else {\n        throw error;\n      }\n\n      return;\n    }\n\n    if (changeState) {\n      this.onStateChange(TransportState.Reconnecting, error);\n    }\n\n    const delay = this.getDelayForRetryCount(failedRetryCount);\n\n    HMSLogger.i(\n      TAG,\n      `schedule: [${TFC[category]}] [failedRetryCount=${failedRetryCount}] Scheduling retry task in ${delay}ms`,\n    );\n\n    let taskSucceeded: boolean;\n    try {\n      taskSucceeded = await this.setTimeoutPromise(task, delay);\n    } catch (ex) {\n      taskSucceeded = false;\n      HMSLogger.w(TAG, `[${TFC[category]}] Un-caught exception ${ex.name} in retry-task, initiating retry`, ex);\n    }\n\n    if (taskSucceeded) {\n      const taskPromise = this.inProgress.get(category);\n      this.inProgress.delete(category);\n      taskPromise?.resolve(failedRetryCount);\n\n      if (changeState && this.inProgress.size === 0) {\n        this.onStateChange(TransportState.Joined);\n      }\n      HMSLogger.i(TAG, `schedule: [${TFC[category]}] [failedRetryCount=${failedRetryCount}] Recovered ♻️`);\n    } else {\n      await this.scheduleTask(category, error, changeState, task, maxFailedRetries, failedRetryCount + 1);\n    }\n  }\n\n  private sendEvent(error: HMSException, category: TFC) {\n    let event: AnalyticsEvent;\n    switch (category) {\n      case TFC.ConnectFailed:\n        event = AnalyticsEventFactory.connect(error);\n        break;\n      case TFC.SignalDisconnect:\n        event = AnalyticsEventFactory.disconnect(error);\n        break;\n      case TFC.PublishIceConnectionFailed:\n        event = AnalyticsEventFactory.publish({ error });\n        break;\n      case TFC.SubscribeIceConnectionFailed:\n        event = AnalyticsEventFactory.subscribeFail(error);\n        break;\n    }\n    this.analyticsEventsService.queue(event!).flush();\n  }\n\n  private getDelayForRetryCount(n: number) {\n    let delay = Math.pow(2, n);\n    const jitter = Math.random();\n    return Math.round(Math.min(delay + jitter, MAX_TRANSPORT_RETRY_DELAY) * 1000);\n  }\n\n  private async setTimeoutPromise<T>(task: () => Promise<T>, delay: number): Promise<T> {\n    return new Promise((resolve, reject) => {\n      const timeoutId = window.setTimeout(async () => {\n        try {\n          const value: T = await task();\n          value && this.retryTaskIds.splice(this.retryTaskIds.indexOf(timeoutId), 1);\n          resolve(value);\n        } catch (error) {\n          reject(error);\n        }\n      }, delay);\n\n      this.retryTaskIds.push(timeoutId);\n    });\n  }\n}\n","import HMSLogger from '../utils/logger';\nimport { Queue } from '../utils/queue';\nimport AnalyticsEvent from './AnalyticsEvent';\nimport { IAnalyticsTransportProvider } from './IAnalyticsTransportProvider';\n\nexport abstract class AnalyticsTransport {\n  abstract transportProvider: IAnalyticsTransportProvider;\n  abstract failedEvents: Queue<AnalyticsEvent>;\n\n  private get TAG() {\n    return `[${this.constructor.name}]`;\n  }\n\n  sendEvent(event: AnalyticsEvent) {\n    try {\n      this.sendSingleEvent(event);\n      this.flushFailedEvents();\n    } catch (error) {}\n  }\n\n  flushFailedEvents() {\n    try {\n      HMSLogger.d(this.TAG, 'Flushing failed events', this.failedEvents);\n      while (this.failedEvents.size() > 0) {\n        const event = this.failedEvents.dequeue();\n        if (event) this.sendSingleEvent(event);\n      }\n    } catch (error) {\n      HMSLogger.w(this.TAG, 'flushFailedEvents failed', error);\n    }\n  }\n\n  private sendSingleEvent(event: AnalyticsEvent) {\n    try {\n      HMSLogger.d(this.TAG, 'Sending event', { event });\n      this.transportProvider.sendEvent(event);\n    } catch (error) {\n      HMSLogger.w(\n        this.TAG,\n        `${this.transportProvider.constructor.name}.sendEvent failed, adding to local storage events`,\n        {\n          event,\n          error,\n        },\n      );\n      this.failedEvents.enqueue(event);\n      throw error;\n    }\n  }\n}\n","import { ANALYTICS_BUFFER_SIZE } from '../../utils/constants';\nimport { LocalStorage } from '../../utils/local-storage';\nimport { Queue } from '../../utils/queue';\nimport AnalyticsEvent from '../AnalyticsEvent';\n\nexport class LocalStorageEvents extends Queue<AnalyticsEvent> {\n  private localStorage = new LocalStorage<AnalyticsEvent[]>('hms-analytics');\n\n  constructor() {\n    super(ANALYTICS_BUFFER_SIZE);\n    // @TODO: Currently we don't send failed events of old sessions. So reset localstorage for every session.\n    // Once support for failed events from old sessions is added, remove clear and init queue from localstorage.\n    this.localStorage.clear();\n    this.initLocalStorageQueue();\n  }\n\n  enqueue(event: AnalyticsEvent) {\n    super.enqueue(event);\n    this.localStorage.set(this.storage);\n  }\n\n  dequeue() {\n    const removedEvent = super.dequeue();\n    this.localStorage.set(this.storage);\n    return removedEvent;\n  }\n\n  private initLocalStorageQueue() {\n    this.localStorage.get()?.forEach((event) => {\n      const eventInstance = new AnalyticsEvent(event);\n      super.enqueue(eventInstance);\n    });\n  }\n}\n","export interface IQueue<T> {\n  size(): number;\n  enqueue(item: T): void;\n  dequeue(): T | undefined;\n}\n\nexport class Queue<T> implements IQueue<T> {\n  protected storage: T[] = [];\n\n  constructor(private capacity: number = Infinity) {}\n\n  size() {\n    return this.storage.length;\n  }\n\n  enqueue(item: T) {\n    if (this.size() === this.capacity) {\n      throw Error('Queue has reached max capacity, cannot add more items');\n    }\n    this.storage.push(item);\n  }\n\n  dequeue() {\n    return this.storage.shift();\n  }\n}\n","import { ISignal } from '../../signal/ISignal';\nimport { AnalyticsTransport } from '../AnalyticsTransport';\nimport { LocalStorageEvents } from './LocalStoageEvents';\n\nexport class SignalAnalyticsTransport extends AnalyticsTransport {\n  failedEvents = new LocalStorageEvents();\n\n  constructor(public transportProvider: ISignal) {\n    super();\n  }\n}\n","import HMSConnection from '../connection';\nimport { RTC_STATS_MONITOR_INTERVAL } from '../utils/constants';\nimport HMSLogger from '../utils/logger';\nimport { sleep } from '../utils/timer-utils';\nimport { TypedEventEmitter } from '../utils/typed-event-emitter';\nimport { RTCStats } from './RTCStats';\n\nexport class RTCStatsMonitor extends TypedEventEmitter<{ RTC_STATS_CHANGE: RTCStats }> {\n  private isMonitored: boolean = false;\n  constructor(private readonly connections: HMSConnection[], private readonly interval = RTC_STATS_MONITOR_INTERVAL) {\n    super();\n  }\n\n  async start() {\n    this.stop();\n    this.isMonitored = true;\n    HMSLogger.d('Starting RTCStatsMonitor');\n    this.startLoop().then(() => HMSLogger.d('Stopping RTCStatsMonitor'));\n  }\n\n  stop() {\n    this.isMonitored = false;\n  }\n\n  private async startLoop() {\n    while (this.isMonitored) {\n      await this.handleConnectionsStats();\n      await sleep(this.interval);\n    }\n  }\n\n  private async handleConnectionsStats() {\n    let totalPacketsLost = 0;\n    let availableIncomingBitrate = 0;\n    let availableOutgoingBitrate = 0;\n    for (const conn of this.connections) {\n      const stats = await conn.getStats();\n      stats.forEach((stat) => {\n        if (stat.packetsLost) totalPacketsLost += stat.packetsLost;\n        if (stat.availableIncomingBitrate) availableIncomingBitrate = Number(stat.availableIncomingBitrate);\n        if (stat.availableOutgoingBitrate) availableOutgoingBitrate = Number(stat.availableOutgoingBitrate);\n      });\n    }\n\n    this.emit('RTC_STATS_CHANGE', {\n      packetsLost: totalPacketsLost,\n      availableIncomingBitrate,\n      availableOutgoingBitrate,\n    });\n  }\n}\n","import { IStore } from '../sdk/store/IStore';\nimport { RTCStats } from '../rtc-stats';\nimport { TypedEventEmitter } from '../utils/typed-event-emitter';\nimport { HMSRemoteVideoTrack } from '../media/tracks';\nimport HMSLogger from '../utils/logger';\n\ninterface TrackDegradationControllerEvents {\n  TRACK_DEGRADED: HMSRemoteVideoTrack;\n  TRACK_RESTORED: HMSRemoteVideoTrack;\n}\n\n/** @see docs/Subscribe-Degradation.md */\nexport class TrackDegradationController extends TypedEventEmitter<TrackDegradationControllerEvents> {\n  private readonly TAG = '[TrackDegradationController]';\n  private readonly PACKETS_LOST_THRESHOLD: number;\n  private readonly MIN_DEGRADE_GRACE_PERIOD: number;\n  private readonly MIN_RECOVER_GRACE_PERIOD: number;\n  private readonly MAX_RECOVER_GRACE_PERIOD = 120;\n\n  private recoveringTrack?: HMSRemoteVideoTrack;\n  private degradeGracePeriod: number;\n  private recoverGracePeriod: number;\n  private recoverAttemptCount = 0;\n  private packetsLost = 0;\n\n  private get isAttemptingRecover() {\n    return Boolean(this.recoveringTrack);\n  }\n\n  constructor(private store: IStore) {\n    super();\n\n    const storeParams = this.store.getSubscribeDegradationParams()!;\n    this.PACKETS_LOST_THRESHOLD = storeParams.packetLossThreshold;\n    this.MIN_DEGRADE_GRACE_PERIOD = storeParams.degradeGracePeriodSeconds;\n    this.MIN_RECOVER_GRACE_PERIOD = storeParams.recoverGracePeriodSeconds;\n\n    this.degradeGracePeriod = this.MIN_DEGRADE_GRACE_PERIOD;\n    this.recoverGracePeriod = this.MIN_RECOVER_GRACE_PERIOD;\n  }\n\n  handleRtcStatsChange(rtcStats: RTCStats) {\n    /**\n     * rtcStats.packetLost is a running counter\n     * Degrade if packetsLost increase is greater than threshold\n     */\n    const shouldDegrade = rtcStats.packetsLost > this.packetsLost + this.PACKETS_LOST_THRESHOLD;\n    this.packetsLost = rtcStats.packetsLost;\n    shouldDegrade ? this.degrade() : this.recover();\n  }\n\n  degrade() {\n    if (this.degradeGracePeriod > 0) {\n      this.degradeGracePeriod--;\n      return;\n    }\n\n    if (this.isAttemptingRecover) {\n      return this.cancelRecovery();\n    }\n\n    HMSLogger.d(this.TAG, 'Packet loss increased, Degrading', { packetsLost: this.packetsLost });\n\n    this.degradeActiveTracksByHalf();\n\n    this.degradeGracePeriod = this.MIN_DEGRADE_GRACE_PERIOD;\n    this.recoverGracePeriod = this.MIN_RECOVER_GRACE_PERIOD;\n  }\n\n  recover() {\n    this.degradeGracePeriod = this.MIN_DEGRADE_GRACE_PERIOD;\n    if (this.recoverGracePeriod > 0) {\n      this.recoverGracePeriod--;\n      return;\n    }\n\n    this.recoveringTrack = this.getActiveTracks(true).find((track) => track.degraded);\n    if (!this.recoveringTrack) {\n      return;\n    }\n\n    HMSLogger.d(this.TAG, 'Packet lost stable, recovering track', this.recoveringTrack);\n    this.recoveringTrack.setDegraded(false);\n    this.emit('TRACK_RESTORED', this.recoveringTrack);\n    this.recoverGracePeriod = this.MIN_RECOVER_GRACE_PERIOD;\n  }\n\n  private degradeActiveTracksByHalf() {\n    const activeTracks = this.getActiveTracks(false);\n    if (!activeTracks.length) return;\n    HMSLogger.d(this.TAG, { activeTracks: [...activeTracks] });\n\n    let halfCount = Math.ceil(activeTracks.length / 2);\n    while (halfCount--) {\n      const track = activeTracks.pop();\n      track!.setDegraded(true);\n      this.emit('TRACK_DEGRADED', track!);\n    }\n  }\n\n  private getActiveTracks(includeDegraded: boolean) {\n    return this.store\n      .getRemoteVideoTracks()\n      .filter((track) => track.hasSinks() && (!track.degraded || includeDegraded))\n      .sort((trackA, trackB) => {\n        const comparators = this.store.getComparator().getTrackComparators();\n        /**\n         * Sort in descending order of importance.\n         * Importance: Screenshare > Role Priority > Speaker > TrackId\n         */\n        return (\n          -1 *\n          (comparators.screenShare(trackA, trackB) ||\n            comparators.rolePriority(trackA, trackB) ||\n            comparators.peerAudioLevel(trackA, trackB) ||\n            this.store.getComparator().stringComparator(trackA.trackId, trackB.trackId))\n        );\n      })\n      .slice(0); // Shallow copy - clone array, keep track references\n  }\n\n  private cancelRecovery() {\n    if (this.recoveringTrack) {\n      this.recoveringTrack.setDegraded(true);\n      this.emit('TRACK_DEGRADED', this.recoveringTrack);\n    }\n    this.recoveringTrack = undefined;\n    this.recoverAttemptCount++;\n    this.recoverGracePeriod = this.getDelayForRecoverCount(this.recoverAttemptCount);\n    this.degradeGracePeriod = this.MIN_DEGRADE_GRACE_PERIOD;\n    HMSLogger.d(this.TAG, 'Recover Attempt Failed', {\n      count: this.recoverAttemptCount,\n      delay: this.recoverGracePeriod,\n    });\n  }\n\n  private getDelayForRecoverCount(count: number) {\n    const delay = this.MIN_RECOVER_GRACE_PERIOD + this.MIN_RECOVER_GRACE_PERIOD * count;\n    return Math.min(delay, this.MAX_RECOVER_GRACE_PERIOD);\n  }\n}\n","import ITransportObserver from './ITransportObserver';\nimport ITransport, { IFetchAVTrackOptions } from './ITransport';\nimport HMSPublishConnection from '../connection/publish';\nimport HMSSubscribeConnection from '../connection/subscribe';\nimport InitService from '../signal/init';\nimport { ISignalEventsObserver } from '../signal/ISignalEventsObserver';\nimport JsonRpcSignal from '../signal/jsonrpc';\nimport { HMSConnectionRole, HMSTrickle } from '../connection/model';\nimport { IPublishConnectionObserver } from '../connection/publish/IPublishConnectionObserver';\nimport ISubscribeConnectionObserver from '../connection/subscribe/ISubscribeConnectionObserver';\nimport { HMSTrack, HMSLocalTrack } from '../media/tracks';\nimport { HMSException } from '../error/HMSException';\nimport { PromiseCallbacks } from '../utils/promise';\nimport {\n  MAX_TRANSPORT_RETRIES,\n  RENEGOTIATION_CALLBACK_ID,\n  SUBSCRIBE_ICE_CONNECTION_CALLBACK_ID,\n  SUBSCRIBE_TIMEOUT,\n} from '../utils/constants';\nimport HMSLocalStream from '../media/streams/HMSLocalStream';\nimport HMSLogger from '../utils/logger';\nimport { HMSVideoTrackSettings, HMSAudioTrackSettings, HMSTrackSettings } from '../media/settings';\nimport { TrackState } from '../notification-manager';\nimport { TransportState } from './models/TransportState';\nimport { ErrorFactory, HMSAction } from '../error/ErrorFactory';\nimport analyticsEventsService from '../analytics/AnalyticsEventsService';\nimport AnalyticsEventFactory from '../analytics/AnalyticsEventFactory';\nimport { JoinParameters } from './models/JoinParameters';\nimport { InitConfig } from '../signal/init/models';\nimport { TransportFailureCategory } from './models/TransportFailureCategory';\nimport { RetryScheduler } from './RetryScheduler';\nimport { userAgent } from '../utils/support';\nimport { ErrorCodes } from '../error/ErrorCodes';\nimport { SignalAnalyticsTransport } from '../analytics/signal-transport/SignalAnalyticsTransport';\nimport { HMSPeer, HMSRoleChangeRequest } from '../interfaces';\nimport { RTCStatsMonitor } from '../rtc-stats';\nimport { TrackDegradationController } from '../degradation';\nimport { IStore } from '../sdk/store';\nimport { DeviceManager } from '../device-manager';\nimport { MultiTrackUpdateRequestParams, TrackUpdateRequestParams } from '../signal/interfaces';\nimport Message from '../sdk/models/HMSMessage';\nimport { ISignal } from '../signal/ISignal';\nimport { RTMPRecordingConfig } from '../interfaces/rtmp-recording-config';\n\nconst TAG = '[HMSTransport]:';\n\n// @DISCUSS: action and extra are not used at all.\ninterface CallbackTriple {\n  promise: PromiseCallbacks<boolean>;\n  action: HMSAction;\n  extra: any;\n}\n\nexport default class HMSTransport implements ITransport {\n  private state: TransportState = TransportState.Disconnected;\n  private trackStates: Map<string, TrackState> = new Map();\n  private publishConnection: HMSPublishConnection | null = null;\n  private subscribeConnection: HMSSubscribeConnection | null = null;\n  private initConfig?: InitConfig;\n  private endpoint!: string;\n  private joinParameters?: JoinParameters;\n  private retryScheduler = new RetryScheduler(analyticsEventsService, async (state, error) => {\n    if (state !== this.state) {\n      this.state = state;\n      await this.observer.onStateChange(this.state, error);\n    }\n  });\n  private subscribeConnStatsMonitor?: RTCStatsMonitor;\n  private trackDegradationController?: TrackDegradationController;\n\n  constructor(private observer: ITransportObserver, private deviceManager: DeviceManager, private store: IStore) {}\n\n  /**\n   * Map of callbacks used to wait for an event to fire.\n   * Used here for:\n   *  1. publish/unpublish waits for [IPublishConnectionObserver.onRenegotiationNeeded] to complete\n   */\n  private readonly callbacks = new Map<string, CallbackTriple>();\n\n  private signalObserver: ISignalEventsObserver = {\n    onOffer: async (jsep: RTCSessionDescriptionInit) => {\n      try {\n        await this.subscribeConnection!.setRemoteDescription(jsep);\n        HMSLogger.d(\n          TAG,\n          `[SUBSCRIBE] Adding ${this.subscribeConnection!.candidates.length} ice-candidates`,\n          this.subscribeConnection!.candidates,\n        );\n        for (const candidate of this.subscribeConnection!.candidates) {\n          await this.subscribeConnection!.addIceCandidate(candidate);\n        }\n        this.subscribeConnection!.candidates.length = 0;\n        const answer = await this.subscribeConnection!.createAnswer();\n        await this.subscribeConnection!.setLocalDescription(answer);\n        this.signal.answer(answer);\n        HMSLogger.d(TAG, '[role=SUBSCRIBE] onOffer renegotiation DONE ✅');\n      } catch (err) {\n        HMSLogger.d(TAG, '[role=SUBSCRIBE] onOffer renegotiation FAILED ❌');\n        this.state = TransportState.Failed;\n        let ex: HMSException;\n        if (err instanceof HMSException) {\n          ex = err;\n        } else {\n          ex = ErrorFactory.GenericErrors.Unknown(HMSAction.PUBLISH, (err as Error).message);\n        }\n\n        analyticsEventsService.queue(AnalyticsEventFactory.subscribeFail(ex)).flush();\n        throw ex;\n      }\n    },\n\n    onTrickle: async (trickle: HMSTrickle) => {\n      const connection =\n        trickle.target === HMSConnectionRole.Publish ? this.publishConnection! : this.subscribeConnection!;\n      if (connection.remoteDescription === null) {\n        // ICE candidates can't be added without any remote session description\n        connection.candidates.push(trickle.candidate);\n      } else {\n        await connection.addIceCandidate(trickle.candidate);\n      }\n    },\n\n    onNotification: (message: Object) => this.observer.onNotification(message),\n\n    onServerError: async (error: HMSException) => {\n      await this.leave();\n      await this.observer.onStateChange(TransportState.Failed, error);\n    },\n\n    onFailure: (exception: HMSException) => {\n      // @DISCUSS: Should we remove this? Pong failure would have already scheduled signal retry.\n      if (this.joinParameters) {\n        this.retryScheduler.schedule(\n          TransportFailureCategory.SignalDisconnect,\n          exception,\n          this.retrySignalDisconnectTask,\n        );\n      }\n    },\n\n    onOffline: async () => {\n      HMSLogger.d(TAG, 'socket offline', TransportState[this.state]);\n      try {\n        if (this.state !== TransportState.Leaving && this.joinParameters) {\n          this.retryScheduler.schedule(\n            TransportFailureCategory.SignalDisconnect,\n            ErrorFactory.WebSocketConnectionErrors.WebSocketConnectionLost(\n              HMSAction.RECONNECT_SIGNAL,\n              'Network offline',\n            ),\n            this.retrySignalDisconnectTask,\n          );\n        }\n      } catch (e) {\n        console.error(e);\n      }\n    },\n\n    onOnline: () => {\n      HMSLogger.d(TAG, 'socket online', TransportState[this.state]);\n      this.analyticsSignalTransport.flushFailedEvents();\n    },\n  };\n\n  private signal: ISignal = new JsonRpcSignal(this.signalObserver);\n  private analyticsSignalTransport = new SignalAnalyticsTransport(this.signal);\n\n  private publishConnectionObserver: IPublishConnectionObserver = {\n    onRenegotiationNeeded: async () => {\n      await this.performPublishRenegotiation();\n    },\n\n    onIceConnectionChange: async (newState: RTCIceConnectionState) => {\n      HMSLogger.d('publisher ice connection state change, ', newState);\n\n      // @TODO: Uncomment this and remove connectionstatechange\n      if (newState === 'failed') {\n        // await this.handleIceConnectionFailure(HMSConnectionRole.Publish);\n      }\n    },\n\n    // @TODO(eswar): Remove this. Use iceconnectionstate change with interval and threshold.\n    onConnectionStateChange: async (newState: RTCPeerConnectionState) => {\n      HMSLogger.d('publisher connection state change, ', newState);\n\n      if (newState === 'failed') {\n        await this.handleIceConnectionFailure(HMSConnectionRole.Publish);\n      }\n    },\n  };\n\n  private subscribeConnectionObserver: ISubscribeConnectionObserver = {\n    onApiChannelMessage: (message: string) => {\n      this.observer.onNotification(JSON.parse(message));\n    },\n\n    onTrackAdd: (track: HMSTrack) => {\n      HMSLogger.d(TAG, '[Subscribe] onTrackAdd', track);\n      this.observer.onTrackAdd(track);\n    },\n\n    onTrackRemove: (track: HMSTrack) => {\n      HMSLogger.d(TAG, '[Subscribe] onTrackRemove', track);\n      this.observer.onTrackRemove(track);\n    },\n\n    onIceConnectionChange: async (newState: RTCIceConnectionState) => {\n      HMSLogger.d('subscriber ice connection state change, ', newState);\n      if (newState === 'failed') {\n        // await this.handleIceConnectionFailure(HMSConnectionRole.Subscribe);\n      }\n\n      if (newState === 'connected') {\n        const callback = this.callbacks.get(SUBSCRIBE_ICE_CONNECTION_CALLBACK_ID);\n        this.callbacks.delete(SUBSCRIBE_ICE_CONNECTION_CALLBACK_ID);\n\n        if (callback) {\n          callback.promise.resolve(true);\n        }\n      }\n    },\n\n    // @TODO(eswar): Remove this. Use iceconnectionstate change with interval and threshold.\n    onConnectionStateChange: async (newState: RTCPeerConnectionState) => {\n      HMSLogger.d('subscriber connection state change, ', newState);\n      if (newState === 'failed') {\n        await this.handleIceConnectionFailure(HMSConnectionRole.Subscribe);\n      }\n\n      if (newState === 'connected') {\n        const callback = this.callbacks.get(SUBSCRIBE_ICE_CONNECTION_CALLBACK_ID);\n        this.callbacks.delete(SUBSCRIBE_ICE_CONNECTION_CALLBACK_ID);\n\n        if (callback) {\n          callback.promise.resolve(true);\n        }\n      }\n    },\n  };\n\n  async getLocalScreen(\n    videoSettings: HMSVideoTrackSettings,\n    audioSettings: HMSAudioTrackSettings,\n  ): Promise<Array<HMSLocalTrack>> {\n    try {\n      return await HMSLocalStream.getLocalScreen(videoSettings, audioSettings);\n    } catch (error) {\n      if (error instanceof HMSException) {\n        analyticsEventsService\n          .queue(\n            AnalyticsEventFactory.publish({\n              error,\n              devices: this.deviceManager.getDevices(),\n              settings: new HMSTrackSettings(videoSettings, audioSettings, false),\n            }),\n          )\n          .flush();\n      }\n      throw error;\n    }\n  }\n\n  async getLocalTracks(settings: HMSTrackSettings): Promise<Array<HMSLocalTrack>> {\n    try {\n      return await HMSLocalStream.getLocalTracks(settings);\n    } catch (error) {\n      if (error instanceof HMSException) {\n        analyticsEventsService\n          .queue(\n            AnalyticsEventFactory.publish({\n              devices: this.deviceManager.getDevices(),\n              error,\n              settings,\n            }),\n          )\n          .flush();\n      }\n      throw error;\n    }\n  }\n\n  async getEmptyLocalTracks(\n    fetchTrackOptions: IFetchAVTrackOptions = { audio: true, video: true },\n    settings?: HMSTrackSettings,\n  ): Promise<Array<HMSLocalTrack>> {\n    try {\n      const tracks = await HMSLocalStream.getEmptyLocalTracks(fetchTrackOptions, settings);\n      return tracks;\n    } catch (error) {\n      if (error instanceof HMSException) {\n        analyticsEventsService\n          .queue(\n            AnalyticsEventFactory.publish({\n              devices: this.deviceManager.getDevices(),\n              error,\n              settings,\n            }),\n          )\n          .flush();\n      }\n      throw error;\n    }\n  }\n\n  async join(\n    authToken: string,\n    peerId: string,\n    customData: { name: string; metaData: string },\n    initEndpoint: string = 'https://prod-init.100ms.live/init',\n    autoSubscribeVideo: boolean = false,\n  ): Promise<void> {\n    if (this.state === TransportState.Failed) {\n      this.state = TransportState.Disconnected;\n    }\n\n    if (this.state !== TransportState.Disconnected && this.state !== TransportState.Reconnecting) {\n      throw ErrorFactory.WebsocketMethodErrors.AlreadyJoined(HMSAction.JOIN, `Cannot join a meeting in ${this.state}`);\n    }\n\n    if (this.state === TransportState.Disconnected) {\n      this.state = TransportState.Connecting;\n      this.observer.onStateChange(this.state);\n    }\n\n    this.joinParameters = new JoinParameters(\n      authToken,\n      peerId,\n      customData.name,\n      customData.metaData,\n      initEndpoint,\n      autoSubscribeVideo,\n    );\n\n    HMSLogger.d(TAG, 'join: started ⏰');\n    const joinRequestedAt = new Date();\n    try {\n      if (!this.signal.isConnected || !this.initConfig) {\n        await this.connect(authToken, initEndpoint, peerId);\n      }\n\n      if (this.initConfig) {\n        await this.connectionJoin(\n          customData.name,\n          customData.metaData,\n          this.initConfig.rtcConfiguration,\n          autoSubscribeVideo,\n        );\n      }\n    } catch (error) {\n      HMSLogger.e(TAG, `join: failed ❌ [token=${authToken}]`, error);\n      this.state = TransportState.Failed;\n      if (error instanceof HMSException) {\n        analyticsEventsService.queue(AnalyticsEventFactory.join(joinRequestedAt, new Date(), error)).flush();\n      }\n      const ex = error as HMSException;\n      ex.isTerminal = ex.code === 500;\n      await this.observer.onStateChange(this.state, ex);\n      throw ex;\n    }\n\n    HMSLogger.d(TAG, '✅ join: successful');\n    this.state = TransportState.Joined;\n    this.observer.onStateChange(this.state);\n  }\n\n  async connect(token: string, endpoint: string, peerId: string) {\n    try {\n      return await this.internalConnect(token, endpoint, peerId);\n    } catch (error) {\n      const shouldRetry =\n        error instanceof HMSException &&\n        ([\n          ErrorCodes.WebSocketConnectionErrors.WEBSOCKET_CONNECTION_LOST,\n          ErrorCodes.InitAPIErrors.ENDPOINT_UNREACHABLE,\n          ErrorCodes.InitAPIErrors.CONNECTION_LOST,\n          ErrorCodes.InitAPIErrors.HTTP_ERROR,\n        ].includes(error.code) ||\n          error.code.toString().startsWith('5') ||\n          error.code.toString().startsWith('429'));\n\n      if (shouldRetry) {\n        const task = async () => {\n          await this.internalConnect(token, endpoint, peerId);\n          return Boolean(this.initConfig && this.initConfig.endpoint);\n        };\n\n        await this.retryScheduler.schedule(\n          TransportFailureCategory.ConnectFailed,\n          error as HMSException,\n          task,\n          MAX_TRANSPORT_RETRIES,\n          false,\n        );\n      } else {\n        throw error;\n      }\n    }\n  }\n\n  async leave(): Promise<void> {\n    analyticsEventsService.removeTransport(this.analyticsSignalTransport);\n\n    this.retryScheduler.reset();\n    this.joinParameters = undefined;\n\n    try {\n      this.state = TransportState.Leaving;\n      this.subscribeConnStatsMonitor?.stop();\n      this.subscribeConnStatsMonitor?.removeAllListeners();\n      this.trackDegradationController?.removeAllListeners();\n      await this.publishConnection?.close();\n      await this.subscribeConnection?.close();\n      if (this.signal.isConnected) {\n        this.signal.leave();\n        await this.signal.close();\n      }\n    } catch (err) {\n      if (err instanceof HMSException) {\n        analyticsEventsService.queue(AnalyticsEventFactory.disconnect(err)).flush();\n      }\n      HMSLogger.e(TAG, 'leave: FAILED ❌', err);\n    } finally {\n      this.state = TransportState.Disconnected;\n      this.observer.onStateChange(this.state);\n    }\n  }\n\n  async publish(tracks: Array<HMSLocalTrack>): Promise<void> {\n    for (const track of tracks) {\n      try {\n        await this.publishTrack(track);\n      } catch (error) {\n        if (error instanceof HMSException) {\n          analyticsEventsService\n            .queue(\n              AnalyticsEventFactory.publish({\n                devices: this.deviceManager.getDevices(),\n                error,\n              }),\n            )\n            .flush();\n        }\n      }\n    }\n  }\n\n  async unpublish(tracks: Array<HMSLocalTrack>): Promise<void> {\n    for (const track of tracks) {\n      await this.unpublishTrack(track);\n    }\n  }\n\n  async sendMessage(message: Message) {\n    await this.signal.broadcast(message);\n  }\n\n  /**\n   * TODO: check if track.publishedTrackId be used instead of the hack to match with track with same type and\n   * source. The hack won't work if there are multiple tracks with same source and type.\n   */\n  trackUpdate(track: HMSLocalTrack) {\n    const currentTrackStates = Array.from(this.trackStates.values());\n    const originalTrackState = currentTrackStates.find(\n      (trackState) => track.type === trackState.type && track.source === trackState.source,\n    );\n    if (originalTrackState) {\n      const newTrackState = new TrackState({\n        ...originalTrackState,\n        mute: !track.enabled,\n      });\n      this.trackStates.set(originalTrackState.track_id, newTrackState);\n      HMSLogger.d(TAG, 'Track Update', this.trackStates, track);\n      this.signal.trackUpdate(new Map([[originalTrackState.track_id, newTrackState]]));\n    }\n  }\n\n  async changeRole(forPeer: HMSPeer, toRole: string, force: boolean = false) {\n    await this.signal.requestRoleChange({\n      requested_for: forPeer.peerId,\n      role: toRole,\n      force,\n    });\n  }\n\n  async acceptRoleChange(request: HMSRoleChangeRequest) {\n    await this.signal.acceptRoleChangeRequest({ role: request.role.name, token: request.token });\n  }\n\n  async endRoom(lock: boolean, reason: string) {\n    await this.signal.endRoom(lock, reason);\n  }\n\n  async removePeer(peerId: string, reason: string) {\n    await this.signal.removePeer({ requested_for: peerId, reason });\n  }\n\n  async startRTMPOrRecording(params: RTMPRecordingConfig) {\n    if (params.rtmpURLs?.length) {\n      await this.signal.startRTMPOrRecording({\n        meeting_url: params.meetingURL,\n        record: params.record,\n        rtmp_urls: params.rtmpURLs,\n      });\n    } else {\n      await this.signal.startRTMPOrRecording({\n        meeting_url: params.meetingURL,\n        record: params.record,\n      });\n    }\n  }\n\n  async stopRTMPOrRecording() {\n    await this.signal.stopRTMPAndRecording();\n  }\n\n  async changeTrackState(trackUpdateRequest: TrackUpdateRequestParams) {\n    await this.signal.requestTrackStateChange(trackUpdateRequest);\n  }\n\n  async changeMultiTrackState(trackUpdateRequest: MultiTrackUpdateRequestParams) {\n    await this.signal.requestMultiTrackStateChange(trackUpdateRequest);\n  }\n\n  private async publishTrack(track: HMSLocalTrack): Promise<void> {\n    track.publishedTrackId = track.nativeTrack.id;\n    HMSLogger.d(TAG, `⏳ publishTrack: trackId=${track.trackId}, toPublishTrackId=${track.publishedTrackId}`, track);\n    this.trackStates.set(track.publishedTrackId, new TrackState(track));\n\n    const p = new Promise<boolean>((resolve, reject) => {\n      this.callbacks.set(RENEGOTIATION_CALLBACK_ID, {\n        promise: { resolve, reject },\n        action: HMSAction.PUBLISH,\n        extra: {},\n      });\n    });\n    const stream = track.stream as HMSLocalStream;\n    stream.setConnection(this.publishConnection!);\n    const simulcastLayers = this.store.getSimulcastLayers(track.source!);\n    stream.addTransceiver(track, simulcastLayers);\n    HMSLogger.time(`publish-${track.trackId}-${track.type}`);\n    await p;\n    HMSLogger.timeEnd(`publish-${track.trackId}-${track.type}`);\n    // add track to store after publish\n    this.store.addTrack(track);\n\n    // @ts-ignore\n    const maxBitrate = track.settings.maxBitrate;\n    if (maxBitrate) {\n      await stream\n        .setMaxBitrate(maxBitrate, track)\n        .then(() => {\n          HMSLogger.i(TAG, `Setting maxBitrate for ${track.source} ${track.type} to ${maxBitrate} kpbs`);\n        })\n        .catch((error) => HMSLogger.e(TAG, 'Failed setting maxBitrate', error));\n    }\n\n    HMSLogger.d(TAG, `✅ publishTrack: trackId=${track.trackId}`, track, this.callbacks);\n  }\n\n  private async unpublishTrack(track: HMSLocalTrack): Promise<void> {\n    HMSLogger.d(TAG, `⏳ unpublishTrack: trackId=${track.trackId}`, track);\n    if (this.trackStates.has(track.publishedTrackId)) {\n      this.trackStates.delete(track.publishedTrackId);\n    } else {\n      // TODO: hotfix to unpublish replaced video track id, solve it properly\n      // it won't work when there are multiple regular video tracks, hmslocalvideotrack can store\n      // the original initial track id for a proper fix\n      const currentTrackStates = Array.from(this.trackStates.values());\n      const originalTrackState = currentTrackStates.find(\n        (trackState) => track.type === trackState.type && track.source === trackState.source,\n      );\n      if (originalTrackState) {\n        this.trackStates.delete(originalTrackState.track_id);\n      }\n    }\n    const p = new Promise<boolean>((resolve, reject) => {\n      this.callbacks.set(RENEGOTIATION_CALLBACK_ID, {\n        promise: { resolve, reject },\n        action: HMSAction.UNPUBLISH,\n        extra: {},\n      });\n    });\n    const stream = track.stream as HMSLocalStream;\n    stream.removeSender(track);\n    await p;\n    await track.cleanup();\n    // remove track from store on unpublish\n    this.store.removeTrack(track.trackId);\n    HMSLogger.d(TAG, `✅ unpublishTrack: trackId=${track.trackId}`, this.callbacks);\n  }\n\n  private async connectionJoin(\n    name: string,\n    data: string,\n    config: RTCConfiguration,\n    autoSubscribeVideo: boolean,\n    constraints: RTCOfferOptions = { offerToReceiveAudio: false, offerToReceiveVideo: false },\n  ) {\n    this.publishConnection = new HMSPublishConnection(this.signal, config, this.publishConnectionObserver, this);\n    this.subscribeConnection = new HMSSubscribeConnection(this.signal, config, this.subscribeConnectionObserver);\n\n    try {\n      HMSLogger.d(TAG, '⏳ join: Negotiating over PUBLISH connection');\n      const offer = await this.publishConnection!.createOffer(constraints, new Map());\n      await this.publishConnection!.setLocalDescription(offer);\n      const answer = await this.signal.join(name, data, offer, !autoSubscribeVideo);\n      await this.publishConnection!.setRemoteDescription(answer);\n      for (const candidate of this.publishConnection!.candidates || []) {\n        await this.publishConnection!.addIceCandidate(candidate);\n      }\n\n      this.publishConnection!.initAfterJoin();\n      await this.initRtcStatsMonitor();\n      HMSLogger.d(TAG, '✅ join: Negotiated over PUBLISH connection');\n    } catch (error) {\n      this.state = TransportState.Failed;\n      throw error;\n    }\n  }\n\n  private async performPublishRenegotiation(constraints?: RTCOfferOptions) {\n    HMSLogger.d(TAG, `⏳ [role=PUBLISH] onRenegotiationNeeded START`, this.trackStates);\n    const callback = this.callbacks.get(RENEGOTIATION_CALLBACK_ID);\n    this.callbacks.delete(RENEGOTIATION_CALLBACK_ID);\n\n    try {\n      const offer = await this.publishConnection!.createOffer(constraints, this.trackStates);\n      await this.publishConnection!.setLocalDescription(offer);\n      HMSLogger.time(`renegotiation-offer-exchange`);\n      const answer = await this.signal.offer(offer, this.trackStates);\n      HMSLogger.timeEnd(`renegotiation-offer-exchange`);\n      await this.publishConnection!.setRemoteDescription(answer);\n      callback!.promise.resolve(true);\n      HMSLogger.d(TAG, `[role=PUBLISH] onRenegotiationNeeded DONE ✅`);\n    } catch (err) {\n      let ex: HMSException;\n      if (err instanceof HMSException) {\n        ex = err;\n      } else {\n        ex = ErrorFactory.GenericErrors.Unknown(HMSAction.PUBLISH, (err as Error).message);\n      }\n\n      callback!.promise.reject(ex);\n      HMSLogger.d(TAG, `[role=PUBLISH] onRenegotiationNeeded FAILED ❌`);\n    }\n  }\n\n  private async handleIceConnectionFailure(role: HMSConnectionRole) {\n    if (role === HMSConnectionRole.Publish) {\n      this.retryScheduler.schedule(\n        TransportFailureCategory.PublishIceConnectionFailed,\n        ErrorFactory.WebrtcErrors.ICEFailure(HMSAction.PUBLISH),\n        this.retryPublishIceFailedTask,\n      );\n    } else {\n      this.retryScheduler.schedule(\n        TransportFailureCategory.SubscribeIceConnectionFailed,\n        ErrorFactory.WebrtcErrors.ICEFailure(HMSAction.SUBSCRIBE),\n        this.retrySubscribeIceFailedTask,\n        1,\n      );\n    }\n  }\n\n  private async internalConnect(token: string, endpoint: string, peerId: string) {\n    HMSLogger.d(TAG, 'connect: started ⏰');\n    const connectRequestedAt = new Date();\n    try {\n      this.initConfig = await InitService.fetchInitConfig(token, endpoint);\n      await this.openSignal(token, peerId);\n      HMSLogger.d(TAG, 'Adding Analytics Transport: JsonRpcSignal');\n      analyticsEventsService.addTransport(this.analyticsSignalTransport);\n      analyticsEventsService.flush();\n    } catch (error) {\n      analyticsEventsService\n        .queue(AnalyticsEventFactory.connect(error as HMSException, connectRequestedAt, new Date(), endpoint))\n        .flush();\n      HMSLogger.d(TAG, '❌ internal connect: failed', error);\n      throw error;\n    }\n  }\n\n  private async openSignal(token: string, peerId: string) {\n    if (!this.initConfig) {\n      throw ErrorFactory.WebSocketConnectionErrors.GenericConnect(HMSAction.INIT, 'Init Config not found');\n    }\n\n    HMSLogger.d(TAG, '⏳ internal connect: connecting to ws endpoint', this.initConfig.endpoint);\n    const url = new URL(this.initConfig.endpoint);\n    url.searchParams.set('peer', peerId);\n    url.searchParams.set('token', token);\n    url.searchParams.set('user_agent', userAgent);\n    this.endpoint = url.toString();\n    await this.signal.open(this.endpoint);\n    HMSLogger.d(TAG, '✅ internal connect: connected to ws endpoint');\n  }\n\n  private async initRtcStatsMonitor() {\n    if (this.store.getSubscribeDegradationParams()) {\n      this.subscribeConnStatsMonitor = new RTCStatsMonitor([this.subscribeConnection!]);\n      this.trackDegradationController = new TrackDegradationController(this.store);\n      this.subscribeConnStatsMonitor.on('RTC_STATS_CHANGE', (stats) =>\n        this.trackDegradationController?.handleRtcStatsChange(stats),\n      );\n      this.trackDegradationController.on('TRACK_DEGRADED', this.observer.onTrackDegrade);\n      this.trackDegradationController.on('TRACK_RESTORED', this.observer.onTrackRestore);\n      await this.subscribeConnStatsMonitor.start();\n    }\n  }\n\n  private retryPublishIceFailedTask = async () => {\n    if (\n      this.publishConnection!.iceConnectionState !== 'connected' ||\n      this.publishConnection!.connectionState !== 'connected'\n    ) {\n      const p = new Promise<boolean>((resolve, reject) => {\n        this.callbacks.set(RENEGOTIATION_CALLBACK_ID, {\n          promise: { resolve, reject },\n          action: HMSAction.RESTART_ICE,\n          extra: {},\n        });\n      });\n      await this.performPublishRenegotiation({ iceRestart: true });\n      await p;\n    }\n\n    return true;\n  };\n\n  private retrySubscribeIceFailedTask = async () => {\n    if (\n      this.subscribeConnection!.iceConnectionState !== 'connected' ||\n      this.subscribeConnection!.connectionState !== 'connected'\n    ) {\n      const p = new Promise<boolean>((resolve, reject) => {\n        // Use subscribe constant string\n        this.callbacks.set(SUBSCRIBE_ICE_CONNECTION_CALLBACK_ID, {\n          promise: { resolve, reject },\n          action: HMSAction.RESTART_ICE,\n          extra: {},\n        });\n      });\n\n      const timeout = new Promise((resolve) => {\n        setTimeout(resolve, SUBSCRIBE_TIMEOUT, false);\n      });\n\n      return Promise.race([p, timeout]) as Promise<boolean>;\n    }\n\n    return true;\n  };\n\n  private retrySignalDisconnectTask = async () => {\n    let ok = this.signal.isConnected;\n\n    HMSLogger.d(TAG, 'retrySignalDisconnectTask', { signalConnected: this.signal.isConnected });\n    // Check if ws is disconnected - otherwise if only publishIce fails\n    // and ws connect is success then we don't need to reconnect to WebSocket\n    if (!this.signal.isConnected) {\n      try {\n        await this.internalConnect(\n          this.joinParameters!.authToken,\n          this.joinParameters!.endpoint,\n          this.joinParameters!.peerId,\n        );\n        ok = true;\n      } catch (ex) {\n        ok = false;\n      }\n    }\n\n    ok = this.signal.isConnected && (await this.retryPublishIceFailedTask());\n\n    // Send track update to sync local track state changes during reconnection\n    this.signal.trackUpdate(this.trackStates);\n\n    return ok;\n  };\n}\n","import { ErrorFactory, HMSAction } from '../error/ErrorFactory';\n\nexport interface AuthToken {\n  roomId: string;\n  userId: string;\n  role: string;\n}\n\nexport default function decodeJWT(token: string): AuthToken {\n  if (token.length === 0) {\n    throw ErrorFactory.InitAPIErrors.InvalidTokenFormat(HMSAction.INIT, 'Token cannot be an empty string');\n  }\n\n  const parts = token.split('.');\n  if (parts.length !== 3) {\n    throw ErrorFactory.InitAPIErrors.InvalidTokenFormat(\n      HMSAction.INIT,\n      `Expected 3 '.' separate fields - header, payload and signature respectively`,\n    );\n  }\n\n  const payloadStr = atob(parts[1]);\n  try {\n    const payload = JSON.parse(payloadStr);\n    return {\n      roomId: payload.room_id,\n      userId: payload.user_id,\n      role: payload.role,\n    } as AuthToken;\n  } catch (err) {\n    throw ErrorFactory.InitAPIErrors.InvalidTokenFormat(HMSAction.INIT, (err as Error).message);\n  }\n}\n","import { HMSAudioCodec, HMSVideoCodec, PublishParams } from '../interfaces';\nimport {\n  HMSAudioTrackSettings,\n  HMSAudioTrackSettingsBuilder,\n  HMSTrackSettings,\n  HMSTrackSettingsBuilder,\n  HMSVideoTrackSettings,\n  HMSVideoTrackSettingsBuilder,\n} from '../media/settings';\nimport InitialSettings from '../interfaces/settings';\nimport { HMSLocalAudioTrack, HMSLocalTrack, HMSLocalVideoTrack, HMSTrackType } from '../media/tracks';\nimport { IStore } from './store';\nimport { IFetchAVTrackOptions } from '../transport/ITransport';\nimport HMSLogger from '../utils/logger';\nimport { HMSException } from '../error/HMSException';\nimport { ErrorFactory, HMSAction } from '../error/ErrorFactory';\nimport ITransportObserver from '../transport/ITransportObserver';\nimport HMSLocalStream from '../media/streams/HMSLocalStream';\nimport analyticsEventsService from '../analytics/AnalyticsEventsService';\nimport AnalyticsEventFactory from '../analytics/AnalyticsEventFactory';\nimport { DeviceManager } from '../device-manager';\nimport { BuildGetMediaError, HMSGetMediaActions } from '../error/utils';\n\nconst defaultSettings = {\n  isAudioMuted: false,\n  isVideoMuted: false,\n  audioInputDeviceId: 'default',\n  audioOutputDeviceId: 'default',\n  videoDeviceId: 'default',\n};\n\nlet blankCanvas: any;\n\nexport class LocalTrackManager {\n  readonly TAG: string = '[LocalTrackManager]';\n\n  constructor(private store: IStore, private observer: ITransportObserver, private deviceManager: DeviceManager) {}\n\n  async getTracksToPublish(initialSettings: InitialSettings): Promise<HMSLocalTrack[]> {\n    const publishParams = this.store.getPublishParams();\n    if (!publishParams) return [];\n\n    const { allowed } = publishParams;\n    const canPublishAudio = Boolean(allowed && allowed.includes('audio'));\n    const canPublishVideo = Boolean(allowed && allowed.includes('video'));\n\n    if (!canPublishAudio && !canPublishVideo) {\n      return [];\n    }\n    let tracksToPublish: Array<HMSLocalTrack> = [];\n\n    const trackSettings = this.getTrackSettings(initialSettings, publishParams);\n\n    if (!trackSettings) {\n      return [];\n    }\n\n    const localTracks = this.store.getLocalPeerTracks();\n    const videoTrack = localTracks.find((t) => t.type === HMSTrackType.VIDEO && t.source === 'regular') as\n      | HMSLocalVideoTrack\n      | undefined;\n    const audioTrack = localTracks.find((t) => t.type === HMSTrackType.AUDIO && t.source === 'regular') as\n      | HMSLocalAudioTrack\n      | undefined;\n    const screenTrack = localTracks.find((t) => t.type === HMSTrackType.VIDEO && t.source === 'screen') as\n      | HMSLocalVideoTrack\n      | undefined;\n\n    // The track gets added to the store only after it is published.\n    const isVideoTrackPublished = Boolean(videoTrack && this.store.getTrackById(videoTrack.trackId));\n    const isAudioTrackPublished = Boolean(audioTrack && this.store.getTrackById(audioTrack.trackId));\n\n    if (videoTrack && trackSettings.video) {\n      await videoTrack.setSettings(trackSettings.video);\n    }\n\n    if (audioTrack && trackSettings.audio) {\n      await audioTrack.setSettings(trackSettings.audio);\n    }\n\n    if (screenTrack && trackSettings.screen) {\n      screenTrack.setSettings(trackSettings.screen);\n    }\n\n    if (isVideoTrackPublished && isAudioTrackPublished) {\n      // there is nothing to publish\n      return [];\n    }\n\n    let fetchTrackOptions: IFetchAVTrackOptions = {\n      audio: canPublishAudio && !audioTrack && (initialSettings.isAudioMuted ? 'empty' : true),\n      video: canPublishVideo && !videoTrack && (initialSettings.isVideoMuted ? 'empty' : true),\n    };\n    try {\n      HMSLogger.d(this.TAG, 'Init Local Tracks', { fetchTrackOptions });\n      tracksToPublish = await this.getLocalTracks(fetchTrackOptions, trackSettings);\n    } catch (error) {\n      if (error instanceof HMSException && error.action === HMSAction.TRACK) {\n        this.observer.onFailure(error);\n\n        const audioFailure = error.message.includes('audio');\n        const videoFailure = error.message.includes('video');\n        fetchTrackOptions.audio = audioFailure ? 'empty' : fetchTrackOptions.audio;\n        fetchTrackOptions.video = videoFailure ? 'empty' : fetchTrackOptions.video;\n        HMSLogger.w(this.TAG, 'Fetch AV Tracks failed', { fetchTrackOptions }, error);\n        try {\n          tracksToPublish.push(...(await this.getLocalTracks(fetchTrackOptions, trackSettings)));\n        } catch (error) {\n          HMSLogger.w(this.TAG, 'Fetch empty tacks failed', error);\n          fetchTrackOptions.audio = fetchTrackOptions.audio && 'empty';\n          fetchTrackOptions.video = fetchTrackOptions.video && 'empty';\n          tracksToPublish.push(...(await this.getLocalTracks(fetchTrackOptions, trackSettings)));\n          this.observer.onFailure(ErrorFactory.TracksErrors.GenericTrack(HMSAction.TRACK, (error as Error).message));\n        }\n      } else {\n        HMSLogger.w(this.TAG, 'Fetch AV Tracks failed - unknown exception', error);\n        this.observer.onFailure(ErrorFactory.TracksErrors.GenericTrack(HMSAction.TRACK, (error as Error).message));\n      }\n    }\n\n    /**\n     * concat local tracks only if both are true which means it is either join or switched from a role\n     * with no tracks earlier.\n     * the reason we need this is for preview API to work, in case of preview we want to publish the same\n     * tracks which were shown and are already part of the local peer instead of creating new ones.\n     * */\n    // if (publishConfig.publishAudio && publishConfig.publishVideo) {\n    //   return tracks.concat(localTracks);\n    // }\n    if (videoTrack && canPublishVideo && !isVideoTrackPublished) {\n      tracksToPublish.push(videoTrack);\n    }\n    if (audioTrack && canPublishAudio && !isAudioTrackPublished) {\n      tracksToPublish.push(audioTrack);\n    }\n    return tracksToPublish;\n  }\n\n  async getLocalTracks(\n    fetchTrackOptions: IFetchAVTrackOptions = { audio: true, video: true },\n    settings: HMSTrackSettings,\n  ): Promise<Array<HMSLocalTrack>> {\n    try {\n      const nativeTracks = await this.getNativeLocalTracks(fetchTrackOptions, settings);\n      const nativeVideoTrack = nativeTracks.find((track) => track.kind === 'video');\n      const nativeAudioTrack = nativeTracks.find((track) => track.kind === 'audio');\n      const local = new HMSLocalStream(new MediaStream(nativeTracks));\n\n      const tracks: Array<HMSLocalTrack> = [];\n      if (nativeAudioTrack && settings?.audio) {\n        const audioTrack = new HMSLocalAudioTrack(local, nativeAudioTrack, 'regular', settings.audio);\n        tracks.push(audioTrack);\n      }\n\n      if (nativeVideoTrack && settings?.video) {\n        const videoTrack = new HMSLocalVideoTrack(local, nativeVideoTrack, 'regular', settings.video);\n        tracks.push(videoTrack);\n      }\n      return tracks;\n    } catch (error) {\n      // TOOD: On OverConstrained error, retry with dropping all constraints.\n      // Just retry getusermedia again - it sometimes work when AbortError or NotFoundError is thrown on a few devices\n      if (error instanceof HMSException) {\n        analyticsEventsService\n          .queue(\n            AnalyticsEventFactory.publish({\n              devices: this.deviceManager.getDevices(),\n              error,\n              settings,\n            }),\n          )\n          .flush();\n      }\n      throw error;\n    }\n  }\n\n  private async getNativeLocalTracks(\n    fetchTrackOptions: IFetchAVTrackOptions = { audio: false, video: false },\n    settings: HMSTrackSettings,\n  ) {\n    let trackSettings = new HMSTrackSettings(\n      fetchTrackOptions.video === true ? settings.video : null,\n      fetchTrackOptions.audio === true ? settings.audio : null,\n      settings.simulcast,\n    );\n\n    let nativeTracks: MediaStreamTrack[] = [];\n\n    if (trackSettings.audio || trackSettings.video) {\n      nativeTracks.push(...(await this.getAVTracks(trackSettings)));\n    }\n\n    if (fetchTrackOptions.audio === 'empty') {\n      nativeTracks.push(this.getEmptyAudioTrack());\n    }\n\n    if (fetchTrackOptions.video === 'empty') {\n      nativeTracks.push(this.getEmptyVideoTrack());\n    }\n\n    return nativeTracks;\n  }\n\n  private getEmptyVideoTrack(prevTrack?: MediaStreamTrack): MediaStreamTrack {\n    const width = prevTrack?.getSettings()?.width || 320;\n    const height = prevTrack?.getSettings()?.height || 240;\n    const frameRate = 10; // fps TODO: experiment, see if this can be reduced\n    if (!blankCanvas) {\n      blankCanvas = Object.assign(document.createElement('canvas'), { width, height });\n      blankCanvas.getContext('2d')?.fillRect(0, 0, width, height);\n    }\n    const stream = blankCanvas.captureStream(frameRate);\n    const emptyTrack = stream.getVideoTracks()[0];\n    const intervalID = setInterval(() => {\n      if (emptyTrack.readyState === 'ended') {\n        clearInterval(intervalID);\n        return;\n      }\n      const ctx = blankCanvas.getContext('2d');\n      if (ctx) {\n        const pixel = ctx.getImageData(0, 0, 1, 1).data;\n        const red = pixel[0] === 0 ? 1 : 0; // toggle red in pixel\n        ctx.fillStyle = `rgb(${red}, 0, 0)`;\n        ctx.fillRect(0, 0, 1, 1);\n      }\n    }, 1000 / frameRate);\n    emptyTrack.onended = () => {\n      clearInterval(intervalID);\n    };\n    emptyTrack.enabled = false;\n    return emptyTrack;\n  }\n\n  private getEmptyAudioTrack(): MediaStreamTrack {\n    const ctx = new AudioContext();\n    const oscillator = ctx.createOscillator();\n    const dst = oscillator.connect(ctx.createMediaStreamDestination());\n    oscillator.start();\n    // @ts-expect-error\n    const emptyTrack = dst.stream.getAudioTracks()[0];\n    emptyTrack.enabled = false;\n    return emptyTrack;\n  }\n\n  private async getAVTracks(settings: HMSTrackSettings): Promise<Array<MediaStreamTrack>> {\n    try {\n      const stream = await navigator.mediaDevices.getUserMedia({\n        audio: settings.audio ? settings.audio.toConstraints() : false,\n        video: settings.video ? settings.video.toConstraints() : false,\n      });\n\n      return stream.getVideoTracks().concat(stream.getAudioTracks());\n    } catch (error) {\n      let videoError = false;\n      let audioError = false;\n\n      await this.deviceManager.init();\n\n      if (!this.deviceManager.hasWebcamPermission && settings.video) {\n        videoError = true;\n      }\n\n      if (!this.deviceManager.hasMicrophonePermission && settings.audio) {\n        audioError = true;\n      }\n\n      if (videoError && audioError) {\n        throw BuildGetMediaError(error as Error, HMSGetMediaActions.AV);\n      } else if (videoError) {\n        throw BuildGetMediaError(error as Error, HMSGetMediaActions.VIDEO);\n      } else {\n        throw BuildGetMediaError(error as Error, HMSGetMediaActions.AUDIO);\n      }\n    }\n  }\n\n  private getTrackSettings(initialSettings: InitialSettings, publishParams: PublishParams): HMSTrackSettings | null {\n    const { audio, video, screen, allowed } = publishParams;\n    const canPublishAudio = Boolean(allowed && allowed.includes('audio'));\n    const canPublishVideo = Boolean(allowed && allowed.includes('video'));\n    const canPublishScreen = Boolean(allowed && allowed.includes('screen'));\n\n    if (!canPublishAudio && !canPublishVideo) {\n      return null;\n    }\n    const { audioInputDeviceId, videoDeviceId } = initialSettings;\n\n    let audioSettings: HMSAudioTrackSettings | null = null;\n    let videoSettings: HMSVideoTrackSettings | null = null;\n    let screenSettings: HMSVideoTrackSettings | null = null;\n    if (canPublishAudio) {\n      audioSettings = new HMSAudioTrackSettingsBuilder()\n        .codec(audio.codec as HMSAudioCodec)\n        .maxBitrate(audio.bitRate)\n        .deviceId(audioInputDeviceId || defaultSettings.audioInputDeviceId)\n        .build();\n    }\n    if (canPublishVideo) {\n      const dimensions = this.store.getSimulcastDimensions('regular');\n      videoSettings = new HMSVideoTrackSettingsBuilder()\n        .codec(video.codec as HMSVideoCodec)\n        .maxBitrate(video.bitRate)\n        .maxFramerate(video.frameRate)\n        .setWidth(dimensions?.width || video.width) // take simulcast width if available\n        .setHeight(dimensions?.height || video.height) // take simulcast width if available\n        .deviceId(videoDeviceId || defaultSettings.videoDeviceId)\n        .build();\n    }\n    if (canPublishScreen) {\n      const dimensions = this.store.getSimulcastDimensions('screen');\n      screenSettings = new HMSVideoTrackSettingsBuilder()\n        // Don't cap maxBitrate for screenshare.\n        // If publish params doesn't have bitRate value - don't set maxBitrate.\n        .maxBitrate(screen.bitRate, false)\n        .codec(screen.codec as HMSVideoCodec)\n        .maxFramerate(screen.frameRate)\n        .setWidth(dimensions?.width || screen.width)\n        .setHeight(dimensions?.height || screen.height)\n        .build();\n    }\n\n    return new HMSTrackSettingsBuilder().video(videoSettings).audio(audioSettings).screen(screenSettings).build();\n  }\n}\n","import { HMSRoom, HMSRoomType } from '../../interfaces/room';\nimport { IStore } from '../store/IStore';\n\nexport default class Room implements HMSRoom {\n  shareableLink!: string;\n  type!: HMSRoomType;\n  hasWaitingRoom!: boolean;\n\n  public get localPeer() {\n    return this.store.getLocalPeer()!;\n  }\n\n  public get peers() {\n    return this.store.getPeers();\n  }\n\n  constructor(public id: string, public name: string, private store: IStore) {}\n}\n","import { EventEmitter } from 'events';\nimport { v4 as uuid } from 'uuid';\nimport { HMSAudioTrack } from '../media/tracks';\nimport { DeviceManager } from '../device-manager';\nimport { NotificationManager } from '../notification-manager/NotificationManager';\nimport HMSLogger from '../utils/logger';\nimport { IStore } from '../sdk/store';\nimport { HMSException } from '../error/HMSException';\nimport { ErrorFactory, HMSAction } from '../error/ErrorFactory';\nimport { HMSDeviceChangeEvent, HMSUpdateListener, HMSTrackUpdate } from '../interfaces';\nimport { HMSRemotePeer } from '../sdk/models/peer';\nimport { isMobile } from '../utils/support';\n\nexport interface AutoplayEvent {\n  error: HMSException;\n}\n\nexport const AutoplayError = 'autoplay-error';\n\ntype AudioSinkState = {\n  autoplayFailed?: boolean;\n  initialized: boolean;\n  // this promise will be set for the first track. remaining tracks will be processed once it's know whether\n  // autoplay is allowed or not\n  autoplayCheckPromise?: Promise<void>;\n};\n\nconst INITIAL_STATE: AudioSinkState = {\n  autoplayFailed: undefined,\n  initialized: false,\n  autoplayCheckPromise: undefined,\n};\n\nexport class AudioSinkManager {\n  private audioSink?: HTMLElement;\n  private autoPausedTracks: Set<HMSAudioTrack> = new Set();\n  private TAG = '[AudioSinkManager]:';\n  private volume: number = 100;\n  private eventEmitter: EventEmitter = new EventEmitter();\n  private state = { ...INITIAL_STATE };\n  private audioContext?: AudioContext;\n  private listener?: HMSUpdateListener;\n\n  constructor(\n    private store: IStore,\n    private notificationManager: NotificationManager,\n    private deviceManager: DeviceManager,\n  ) {\n    this.notificationManager.addEventListener('track-added', this.handleTrackAdd as EventListener);\n    this.notificationManager.addEventListener('track-removed', this.handleTrackRemove as EventListener);\n    this.notificationManager.addEventListener('track-updated', this.handleTrackUpdate as EventListener);\n    this.deviceManager.addEventListener('audio-device-change', this.handleAudioDeviceChange);\n    // Initiate a Audio Context so safari will play audio on speaker instead of earpiece\n    this.audioContext = new AudioContext();\n  }\n\n  setListener(listener?: HMSUpdateListener) {\n    this.listener = listener;\n  }\n\n  addEventListener(event: string, listener: (event: AutoplayEvent) => void) {\n    this.eventEmitter.addListener(event, listener);\n  }\n\n  removeEventListener(event: string, listener: (event: AutoplayEvent) => void) {\n    this.eventEmitter.removeListener(event, listener);\n  }\n\n  private get outputDevice() {\n    return this.deviceManager.outputDevice;\n  }\n\n  getVolume() {\n    return this.volume;\n  }\n\n  setVolume(value: number) {\n    this.store.updateAudioOutputVolume(value);\n    this.volume = value;\n  }\n\n  /**\n   *  This function is to be called only on user interaction when\n   *  autoplay error is received.\n   */\n  async unblockAutoplay() {\n    if (this.autoPausedTracks.size > 0) {\n      this.unpauseAudioTracks();\n    }\n  }\n\n  init(elementId?: string) {\n    if (this.state.initialized) {\n      return;\n    }\n    this.state.initialized = true;\n    const audioSink = document.createElement('div');\n    audioSink.id = `HMS-SDK-audio-sink-${uuid()}`;\n    const userElement = elementId && document.getElementById(elementId);\n    const audioSinkParent = userElement || document.body;\n    audioSinkParent.append(audioSink);\n\n    this.audioSink = audioSink;\n  }\n\n  cleanUp() {\n    this.audioSink?.remove();\n    this.audioSink = undefined;\n    this.audioContext?.close();\n    this.audioContext = undefined;\n    this.notificationManager.removeEventListener('track-added', this.handleTrackAdd as EventListener);\n    this.notificationManager.removeEventListener('track-removed', this.handleTrackRemove as EventListener);\n    this.notificationManager.removeEventListener('track-updated', this.handleTrackUpdate as EventListener);\n    this.deviceManager.removeEventListener('audio-device-change', this.handleAudioDeviceChange);\n    this.autoPausedTracks = new Set();\n    this.state = { ...INITIAL_STATE };\n  }\n\n  private handleAudioPaused = (event: any) => {\n    const audioEl = event.target as HTMLAudioElement;\n    //@ts-ignore\n    const track = audioEl.srcObject?.getAudioTracks()[0];\n    if (!track?.enabled) {\n      // No need to play if already disabled\n      return;\n    }\n    // this means the audio paused because of external factors(headset removal)\n    HMSLogger.d(this.TAG, 'Audio Paused', event.target.id);\n    const audioTrack = this.store.getTrackById(event.target.id);\n    if (audioTrack) {\n      if (isMobile()) {\n        // Play after a delay since mobile devices don't call onDevice change event\n        setTimeout(async () => {\n          if (audioTrack) {\n            await this.playAudioFor(audioTrack as HMSAudioTrack);\n          }\n        }, 500);\n      } else {\n        this.autoPausedTracks.add(audioTrack as HMSAudioTrack);\n      }\n    }\n  };\n\n  private handleTrackUpdate = (event: CustomEvent<{ track: HMSAudioTrack; enabled: boolean }>) => {\n    // @ts-ignore\n    if (window.HMS?.AUDIO_SINK) {\n      const { track, enabled } = event.detail;\n      if (enabled) {\n        track.addSink();\n        this.playAudioFor(track);\n      } else {\n        track.removeSink();\n      }\n    }\n  };\n\n  private handleTrackAdd = (event: CustomEvent<{ track: HMSAudioTrack; peer: HMSRemotePeer }>) => {\n    this.handleTrackAddAsync(event);\n  };\n\n  private handleTrackAddAsync = async (event: CustomEvent<{ track: HMSAudioTrack; peer: HMSRemotePeer }>) => {\n    const { track, peer } = event.detail;\n\n    const audioEl = document.createElement('audio');\n    audioEl.style.display = 'none';\n    audioEl.id = track.trackId;\n    audioEl.addEventListener('pause', this.handleAudioPaused);\n\n    track.setAudioElement(audioEl);\n    track.setVolume(this.volume);\n    HMSLogger.d(this.TAG, 'Audio track added', track.trackId);\n    this.audioSink?.append(audioEl);\n    this.outputDevice && (await track.setOutputDevice(this.outputDevice));\n    // @ts-ignore\n    if (window.HMS?.AUDIO_SINK) {\n      // No need to play if track is not enabled\n      if (!track.enabled) {\n        track.removeSink();\n        this.listener?.onTrackUpdate(HMSTrackUpdate.TRACK_ADDED, track, peer);\n        return;\n      }\n      track.addSink();\n    } else {\n      audioEl.srcObject = new MediaStream([track.nativeTrack]);\n    }\n    this.listener?.onTrackUpdate(HMSTrackUpdate.TRACK_ADDED, track, peer);\n    /**\n     * if it's not known whether autoplay will succeed, wait for it to be known\n     */\n    if (this.state.autoplayFailed === undefined) {\n      if (!this.state.autoplayCheckPromise) {\n        // it's the first track, try to play it, that'll tell us whether autoplay is allowed\n        this.state.autoplayCheckPromise = new Promise<void>((resolve) => {\n          this.playAudioFor(track).then(resolve);\n        });\n      }\n      // and wait for the result to be known\n      await this.state.autoplayCheckPromise;\n    }\n    /**\n     * Don't play the track if autoplay failed, add to paused list\n     */\n    if (this.state.autoplayFailed) {\n      this.autoPausedTracks.add(track);\n      return;\n    }\n    await this.playAudioFor(track);\n  };\n\n  private handleAudioDeviceChange = (event: HMSDeviceChangeEvent) => {\n    // if there is no selection that means this is an init request. No need to do anything\n    if (event.error || !event.selection) {\n      return;\n    }\n    this.unpauseAudioTracks();\n  };\n\n  /**\n   * try to play audio for the passed in track, assume autoplay error happened if play fails\n   * @param track\n   * @private\n   */\n  private async playAudioFor(track: HMSAudioTrack) {\n    const audioEl = track.getAudioElement();\n    if (!audioEl) {\n      HMSLogger.w(this.TAG, 'No audio element found on track', track.trackId);\n      return;\n    }\n    try {\n      if (this.audioContext?.state === 'suspended') {\n        this.audioContext?.resume();\n      }\n      await audioEl.play();\n      this.state.autoplayFailed = false;\n      this.autoPausedTracks.delete(track);\n      HMSLogger.d(this.TAG, 'Played track', track.trackId);\n    } catch (error) {\n      this.autoPausedTracks.add(track);\n      HMSLogger.e(this.TAG, 'Failed to play track', track.trackId, error);\n      if (!this.state.autoplayFailed) {\n        this.state.autoplayFailed = true;\n        const ex = ErrorFactory.TracksErrors.AutoplayBlocked(HMSAction.AUTOPLAY, '');\n        this.eventEmitter.emit(AutoplayError, { error: ex });\n      }\n    }\n  }\n\n  private handleTrackRemove = (event: CustomEvent<HMSAudioTrack>) => {\n    const track = event.detail;\n    this.autoPausedTracks.delete(track);\n    const audioEl = document.getElementById(track.trackId) as HTMLAudioElement;\n    if (audioEl) {\n      audioEl.removeEventListener('pause', this.handleAudioPaused);\n      audioEl.srcObject = null;\n      audioEl.remove();\n      track.setAudioElement(null);\n    }\n    // Reset autoplay error thrown because if all tracks are removed and a new track is added\n    // Autoplay error is thrown in safari\n    if (this.audioSink && this.audioSink.childElementCount === 0) {\n      this.state.autoplayCheckPromise = undefined;\n      this.state.autoplayFailed = undefined;\n    }\n    HMSLogger.d(this.TAG, 'Audio track removed', track.trackId);\n  };\n\n  private unpauseAudioTracks = async () => {\n    const promises: Promise<void>[] = [];\n    this.autoPausedTracks.forEach((track) => {\n      promises.push(this.playAudioFor(track));\n    });\n    // Return after all pending tracks are played\n    await Promise.all(promises);\n  };\n}\n","import EventEmitter from 'events';\nimport { HMSDeviceManager, DeviceMap } from '../interfaces/HMSDeviceManager';\nimport { HMSLocalAudioTrack, HMSLocalVideoTrack } from '../media/tracks';\nimport { HMSAudioTrackSettingsBuilder, HMSVideoTrackSettingsBuilder } from '../media/settings';\nimport { HMSDeviceChangeEvent } from '../interfaces';\nimport AnalyticsEventFactory from '../analytics/AnalyticsEventFactory';\nimport analyticsEventsService from '../analytics/AnalyticsEventsService';\nimport { DeviceStorageManager } from './DeviceStorage';\nimport { IStore } from '../sdk/store';\nimport { debounce } from '../utils/timer-utils';\nimport HMSLogger from '../utils/logger';\nimport { HMSException } from '../error/HMSException';\n\nexport type SelectedDevices = {\n  audioInput?: MediaDeviceInfo;\n  videoInput?: MediaDeviceInfo;\n  audioOutput?: MediaDeviceInfo;\n};\n\ntype DeviceAndGroup = Partial<MediaTrackSettings>;\nexport class DeviceManager implements HMSDeviceManager {\n  audioInput: MediaDeviceInfo[] = [];\n  audioOutput: MediaDeviceInfo[] = [];\n  videoInput: MediaDeviceInfo[] = [];\n  outputDevice?: MediaDeviceInfo;\n  // true if user has allowed the permission\n  // false if user has denied the permission or prompt was never shown or ignored\n  // or if the camera/mic is not available in the device\n  hasWebcamPermission = false;\n  hasMicrophonePermission = false;\n\n  private eventEmitter: EventEmitter = new EventEmitter();\n  private TAG: string = '[Device Manager]:';\n  private initialized = false;\n  private videoInputChanged = false;\n  private audioInputChanged = false;\n\n  constructor(private store: IStore) {}\n\n  updateOutputDevice = (deviceId?: string) => {\n    const newDevice = this.audioOutput.find((device) => device.deviceId === deviceId);\n    if (newDevice) {\n      this.outputDevice = newDevice;\n      this.store.updateAudioOutputDevice(newDevice);\n      DeviceStorageManager.updateSelection('audioOutput', { deviceId: newDevice.deviceId, groupId: newDevice.groupId });\n    }\n    return newDevice;\n  };\n\n  async init() {\n    if (this.initialized) {\n      return;\n    }\n    this.initialized = true;\n    navigator.mediaDevices.addEventListener('devicechange', this.handleDeviceChange);\n    await this.enumerateDevices();\n    this.logDevices('Init');\n    this.setOutputDevice();\n    this.eventEmitter.emit('audio-device-change', { devices: this.getDevices() } as HMSDeviceChangeEvent);\n    analyticsEventsService\n      .queue(\n        AnalyticsEventFactory.deviceChange({\n          selection: this.getCurrentSelection(),\n          type: 'list',\n          devices: this.getDevices(),\n        }),\n      )\n      .flush();\n  }\n\n  getDevices(): DeviceMap {\n    return {\n      audioInput: this.audioInput,\n      audioOutput: this.audioOutput,\n      videoInput: this.videoInput,\n    };\n  }\n\n  cleanUp() {\n    this.initialized = false;\n    this.audioInput = [];\n    this.audioOutput = [];\n    this.videoInput = [];\n    this.outputDevice = undefined;\n    navigator.mediaDevices.removeEventListener('devicechange', this.handleDeviceChange);\n  }\n\n  private createIdentifier(deviceInfo?: DeviceAndGroup) {\n    if (!deviceInfo) {\n      return '';\n    }\n    return `${deviceInfo.deviceId}${deviceInfo.groupId}`;\n  }\n\n  private getCurrentSelection = (): SelectedDevices => {\n    const localPeer = this.store.getLocalPeer();\n    const audioDevice = this.createIdentifier(localPeer?.audioTrack?.getMediaTrackSettings());\n    const videoDevice = this.createIdentifier(localPeer?.videoTrack?.getMediaTrackSettings());\n    const audioSelection = this.audioInput.find((device) => {\n      const id = this.createIdentifier(device);\n      return id === audioDevice;\n    });\n    const videoSelection = this.videoInput.find((device) => this.createIdentifier(device) === videoDevice);\n    return {\n      audioInput: audioSelection,\n      videoInput: videoSelection,\n      audioOutput: this.outputDevice,\n    };\n  };\n\n  private computeChange = (prevDevices: string[], currentDevices: MediaDeviceInfo[]) => {\n    if (prevDevices.length !== currentDevices.length) {\n      return true;\n    }\n    return currentDevices.some((device) => !prevDevices.includes(this.createIdentifier(device)));\n  };\n\n  private enumerateDevices = async () => {\n    try {\n      const devices = await navigator.mediaDevices.enumerateDevices();\n      const prevVideoInput = this.videoInput.map(this.createIdentifier);\n      const prevAudioInput = this.audioInput.map(this.createIdentifier);\n      this.audioInput = [];\n      this.audioOutput = [];\n      this.videoInput = [];\n      devices.forEach((device) => {\n        if (device.kind === 'audioinput' && device.label) {\n          this.hasMicrophonePermission = true;\n          this.audioInput.push(device as MediaDeviceInfo);\n        } else if (device.kind === 'audiooutput') {\n          this.audioOutput.push(device);\n        } else if (device.kind === 'videoinput' && device.label) {\n          this.hasWebcamPermission = true;\n          this.videoInput.push(device as MediaDeviceInfo);\n        }\n      });\n      this.videoInputChanged = this.computeChange(prevVideoInput, this.videoInput);\n      this.audioInputChanged = this.computeChange(prevAudioInput, this.audioInput);\n      DeviceStorageManager.setDevices({\n        videoInput: [...this.videoInput],\n        audioInput: [...this.audioInput],\n        audioOutput: [...this.audioOutput],\n      });\n      this.logDevices('Enumerate Devices');\n    } catch (error) {\n      HMSLogger.e(this.TAG, 'Failed enumerating devices', error);\n    }\n  };\n\n  private handleDeviceChange = debounce(async () => {\n    await this.enumerateDevices();\n    analyticsEventsService\n      .queue(\n        AnalyticsEventFactory.deviceChange({\n          selection: this.getCurrentSelection(),\n          type: 'list',\n          devices: this.getDevices(),\n        }),\n      )\n      .flush();\n    this.logDevices('After Device Change');\n    const localPeer = this.store.getLocalPeer();\n    this.setOutputDevice(true);\n    await this.handleAudioInputDeviceChange(localPeer?.audioTrack);\n    await this.handleVideoInputDeviceChange(localPeer?.videoTrack);\n  }, 500).bind(this);\n\n  /**\n   * Function to get the device after device change\n   * Chrome and Edge provide a default device from which we select the actual device\n   * Firefox and safari give 0th device as system default\n   * @returns {MediaDeviceInfo}\n   */\n  getNewAudioInputDevice() {\n    const defaultDevice = this.audioInput.find((device) => device.deviceId === 'default');\n    if (defaultDevice) {\n      // Selecting a non-default device so that the deviceId comparision does not give\n      // false positives when device is removed, because the other available device\n      // get's the deviceId as default once this device is removed\n      const nextDevice = this.audioInput.find((device) => {\n        return device.label !== defaultDevice.label && defaultDevice.label.includes(device.label);\n      });\n      return nextDevice;\n    }\n    return this.audioInput[0];\n  }\n\n  /**\n   * This method is to select the input/output from same group\n   * same group meaning both input/output are of same device\n   * This method might override the default coming from browser and system so as to select options from same\n   * device type. This is required in certain cases where browser's default is not correct.\n   * Algo:\n   * 1. find the non default input device if selected one is default by matching device label\n   * 2. find the corresponding output device which has the same group id or same label\n   * 3. select the default one if nothing was found\n   * 4. select the first option if there is no default\n   */\n  setOutputDevice(deviceChange: boolean = false) {\n    const inputDevice = this.getNewAudioInputDevice();\n    const prevSelection = this.createIdentifier(this.outputDevice);\n    this.outputDevice = undefined;\n    if (inputDevice?.groupId) {\n      // only check for label because if groupId check is added it will select speaker\n      // when an external earphone without microphone is added\n      this.outputDevice = this.audioOutput.find(\n        (device) => inputDevice.deviceId !== 'default' && device.label === inputDevice.label,\n      );\n    }\n    if (!this.outputDevice) {\n      // select default deviceId device if available, otherwise select 0th device\n      this.outputDevice = this.audioOutput.find((device) => device.deviceId === 'default') || this.audioOutput[0];\n    }\n    this.store.updateAudioOutputDevice(this.outputDevice);\n    // send event only on device change and device is not same as previous\n    if (deviceChange && prevSelection !== this.createIdentifier(this.outputDevice)) {\n      this.eventEmitter.emit('audio-device-change', {\n        selection: this.outputDevice,\n        type: 'audioOutput',\n        devices: this.getDevices(),\n      } as HMSDeviceChangeEvent);\n    }\n  }\n\n  private handleAudioInputDeviceChange = async (audioTrack?: HMSLocalAudioTrack) => {\n    if (!audioTrack) {\n      HMSLogger.d(this.TAG, 'No Audio track on local peer');\n      return;\n    }\n    // no need to proceed further if input has not changed\n    if (!this.audioInputChanged) {\n      HMSLogger.d(this.TAG, 'No Change in AudioInput Device');\n      return;\n    }\n    const newSelection = this.getNewAudioInputDevice();\n    if (!newSelection || !newSelection.deviceId) {\n      HMSLogger.w(this.TAG, 'Audio device not found');\n      return;\n    }\n    const { settings } = audioTrack;\n    const newAudioTrackSettings = new HMSAudioTrackSettingsBuilder()\n      .codec(settings.codec)\n      .maxBitrate(settings.maxBitrate)\n      .deviceId(newSelection.deviceId)\n      .build();\n    try {\n      await audioTrack.setSettings(newAudioTrackSettings, true);\n      this.eventEmitter.emit('audio-device-change', {\n        devices: this.getDevices(),\n        selection: newSelection,\n        type: 'audioInput',\n      } as HMSDeviceChangeEvent);\n      this.logDevices('Audio Device Change Success');\n    } catch (error) {\n      HMSLogger.e(this.TAG, '[Audio Device Change]', error);\n      analyticsEventsService\n        .queue(\n          AnalyticsEventFactory.deviceChange({\n            selection: { audioInput: newSelection },\n            devices: this.getDevices(),\n            error: error as HMSException,\n          }),\n        )\n        .flush();\n      this.eventEmitter.emit('audio-device-change', {\n        error,\n        selection: newSelection,\n        type: 'audioInput',\n        devices: this.getDevices(),\n      } as HMSDeviceChangeEvent);\n    }\n  };\n\n  private handleVideoInputDeviceChange = async (videoTrack?: HMSLocalVideoTrack) => {\n    if (!videoTrack) {\n      HMSLogger.d(this.TAG, 'No Audio track on local peer');\n      return;\n    }\n    // no need to proceed further if input has not changed\n    if (!this.videoInputChanged) {\n      HMSLogger.d(this.TAG, 'No Change in VideoInput Device');\n      return;\n    }\n    const newSelection = this.videoInput[0];\n    if (!newSelection || !newSelection.deviceId) {\n      HMSLogger.w(this.TAG, 'Video device not found');\n      return;\n    }\n    const { settings, enabled } = videoTrack;\n    const newVideoTrackSettings = new HMSVideoTrackSettingsBuilder()\n      .codec(settings.codec)\n      .maxBitrate(settings.maxBitrate)\n      .maxFramerate(settings.maxFramerate)\n      .setWidth(settings.width)\n      .setHeight(settings.height)\n      .deviceId(newSelection.deviceId)\n      .build();\n    try {\n      await (videoTrack as HMSLocalVideoTrack).setSettings(newVideoTrackSettings, true);\n      if (!enabled) {\n        // On replace track, enabled will be true. Need to be set to previous state\n        videoTrack.setEnabled(enabled);\n      }\n      this.eventEmitter.emit('video-device-change', {\n        devices: this.getDevices(),\n        selection: newSelection,\n        type: 'video',\n      } as HMSDeviceChangeEvent);\n      this.logDevices('Video Device Change Success');\n    } catch (error) {\n      HMSLogger.e(this.TAG, '[Video Device Change]', error);\n      analyticsEventsService\n        .queue(\n          AnalyticsEventFactory.deviceChange({\n            selection: { videoInput: newSelection },\n            devices: this.getDevices(),\n            error: error as HMSException,\n          }),\n        )\n        .flush();\n      this.eventEmitter.emit('video-device-change', {\n        error: error as Error,\n        type: 'video',\n        selection: newSelection,\n        devices: this.getDevices(),\n      } as HMSDeviceChangeEvent);\n    }\n  };\n\n  addEventListener(event: string, listener: (event: HMSDeviceChangeEvent) => void) {\n    this.eventEmitter.addListener(event, listener);\n  }\n\n  removeEventListener(event: string, listener: (event: HMSDeviceChangeEvent) => void) {\n    this.eventEmitter.removeListener(event, listener);\n  }\n\n  private logDevices(label = '') {\n    HMSLogger.d(\n      this.TAG,\n      label,\n      JSON.stringify(\n        {\n          videoInput: [...this.videoInput],\n          audioInput: [...this.audioInput],\n          audioOutput: [...this.audioOutput],\n          selected: this.getCurrentSelection(),\n        },\n        null,\n        4,\n      ),\n    );\n  }\n}\n","import { AudioSinkManager } from '../audio-sink-manager';\nimport { DeviceManager } from '.';\n\nexport interface IAudioOutputManager {\n  getDevice(): MediaDeviceInfo | undefined;\n  setDevice(deviceId: string): MediaDeviceInfo | undefined;\n  getVolume(): number;\n  setVolume(value: number): void;\n}\n\nexport class AudioOutputManager implements IAudioOutputManager {\n  constructor(private deviceManager: DeviceManager, private audioSinkManager: AudioSinkManager) {}\n\n  getVolume() {\n    return this.audioSinkManager.getVolume();\n  }\n\n  setVolume(value: number) {\n    if (value < 0 || value > 100) {\n      throw Error('Please pass a valid number between 0-100');\n    }\n    this.audioSinkManager.setVolume(value);\n  }\n\n  getDevice() {\n    return this.deviceManager.outputDevice;\n  }\n\n  setDevice(deviceId?: string) {\n    return this.deviceManager.updateOutputDevice(deviceId);\n  }\n\n  async unblockAutoplay() {\n    await this.audioSinkManager.unblockAutoplay();\n  }\n}\n","import { HMSTrack } from '../..';\nimport { HMSTrackType } from '../../media/tracks';\nimport { HMSPeer } from '../models/peer';\nimport { IStore } from './IStore';\n\n/**\n * Function passed as argument to the sort method of the list.\n * @returns a negative value if first argument is less than second argument, zero if they're equal and a positive value otherwise\n *\n * @see Array.sort\n */\ntype ComparatorFn<T> = (a: T, b: T) => number;\n\ninterface PeerComparators {\n  videoEnabled: ComparatorFn<HMSPeer>;\n  audioEnabled: ComparatorFn<HMSPeer>;\n  screenShare: ComparatorFn<HMSPeer>;\n  audioLevel: ComparatorFn<HMSPeer | undefined>;\n  rolePriority: ComparatorFn<HMSPeer>;\n}\n\ninterface TrackComparators {\n  video: ComparatorFn<HMSTrack>;\n  audio: ComparatorFn<HMSTrack>;\n  enabled: ComparatorFn<HMSTrack>;\n  audioLevel: ComparatorFn<HMSTrack>;\n  peerAudioLevel: ComparatorFn<HMSTrack>;\n  screenShare: ComparatorFn<HMSTrack>;\n  rolePriority: ComparatorFn<HMSTrack>;\n}\n\ninterface IComparator {\n  getPeerComparators: () => PeerComparators;\n  getTrackComparators: () => TrackComparators;\n}\n\n/**\n * Used to sort list of items(peers/tracks) based on common use cases.\n * Usage: peerList.sort(comparator.getPeerComparators().audioLevel);\n */\nexport class Comparator implements IComparator {\n  constructor(private readonly store: IStore) {}\n\n  getPeerComparators(): PeerComparators {\n    return {\n      videoEnabled: (peerA: HMSPeer, peerB: HMSPeer) =>\n        this.primitiveComparator<boolean>(Boolean(peerA.videoTrack?.enabled), Boolean(peerB.videoTrack?.enabled)),\n\n      audioEnabled: (peerA: HMSPeer, peerB: HMSPeer) =>\n        this.primitiveComparator<boolean>(Boolean(peerA.audioTrack?.enabled), Boolean(peerB.audioTrack?.enabled)),\n\n      screenShare: (peerA: HMSPeer, peerB: HMSPeer) =>\n        this.primitiveComparator<boolean>(\n          peerA.auxiliaryTracks.some((track) => track.source === 'screen'),\n          peerB.auxiliaryTracks.some((track) => track.source === 'screen'),\n        ),\n\n      audioLevel: (peerA?: HMSPeer, peerB?: HMSPeer) =>\n        this.primitiveComparator<number>(\n          this.store.getSpeakers().find((speaker) => speaker.peer.peerId === peerA?.peerId)?.audioLevel || -1,\n          this.store.getSpeakers().find((speaker) => speaker.peer.peerId === peerB?.peerId)?.audioLevel || -1,\n        ),\n\n      rolePriority: (peerA: HMSPeer, peerB: HMSPeer) =>\n        this.primitiveComparator<number>(peerA.role?.priority || 0, peerB.role?.priority || 0),\n    };\n  }\n\n  getTrackComparators(): TrackComparators {\n    return {\n      video: (trackA: HMSTrack, trackB: HMSTrack) =>\n        this.primitiveComparator<boolean>(trackA.type === HMSTrackType.VIDEO, trackB.type === HMSTrackType.VIDEO),\n\n      audio: (trackA: HMSTrack, trackB: HMSTrack) =>\n        this.primitiveComparator<boolean>(trackA.type === HMSTrackType.AUDIO, trackB.type === HMSTrackType.AUDIO),\n\n      enabled: (trackA: HMSTrack, trackB: HMSTrack) =>\n        this.primitiveComparator<boolean>(Boolean(trackA.enabled), Boolean(trackB.enabled)),\n\n      peerAudioLevel: (trackA: HMSTrack, trackB: HMSTrack) => {\n        const peerA = this.store.getPeerByTrackId(trackA.trackId);\n        const peerB = this.store.getPeerByTrackId(trackB.trackId);\n        return this.getPeerComparators().audioLevel(peerA, peerB);\n      },\n\n      /**\n       * Only HMSAudioTracks comparable as speaker objects have only HMSAudioTracks\n       */\n      audioLevel: (trackA: HMSTrack, trackB: HMSTrack) =>\n        this.primitiveComparator<number>(\n          this.store.getSpeakers().find((speaker) => speaker.track.trackId === trackA.trackId)?.audioLevel || 0,\n          this.store.getSpeakers().find((speaker) => speaker.track.trackId === trackB.trackId)?.audioLevel || 0,\n        ),\n\n      screenShare: (trackA: HMSTrack, trackB: HMSTrack) =>\n        this.primitiveComparator(trackA.source === 'screen', trackB.source === 'screen'),\n\n      rolePriority: (trackA: HMSTrack, trackB: HMSTrack) =>\n        this.primitiveComparator<number>(\n          this.store.getPeerByTrackId(trackA.trackId)?.role?.priority || 0,\n          this.store.getPeerByTrackId(trackB.trackId)?.role?.priority || 0,\n        ),\n    };\n  }\n\n  /**\n   * @returns a negative value if a is less than b, zero if they're equal and a positive value otherwise\n   */\n  primitiveComparator = <T>(a: T, b: T): number => {\n    return a === b ? 0 : Number(a) - Number(b);\n  };\n\n  stringComparator = (a: string, b: string) => (a === b ? 0 : a < b ? -1 : 1);\n}\n","import { IStore, KnownRoles, TrackStateEntry } from './IStore';\nimport HMSRoom from '../models/HMSRoom';\nimport { HMSLocalPeer, HMSPeer, HMSRemotePeer } from '../models/peer';\nimport { HMSSpeaker } from '../../interfaces';\nimport { IErrorListener } from '../../interfaces/error-listener';\nimport {\n  HMSTrack,\n  HMSVideoTrack,\n  HMSAudioTrack,\n  HMSTrackType,\n  HMSTrackSource,\n  HMSRemoteVideoTrack,\n  HMSLocalTrack,\n} from '../../media/tracks';\nimport {\n  SimulcastLayer,\n  SimulcastLayers,\n  SimulcastDimensions,\n  simulcastMapping,\n  RID,\n  SimulcastLayerDefinition,\n} from '../../interfaces/simulcast-layers';\nimport { Comparator } from './Comparator';\nimport { HMSConfig, PublishParams } from '../../interfaces';\nimport { SelectedDevices } from '../../device-manager';\nimport { DeviceStorageManager } from '../../device-manager/DeviceStorage';\nimport { ErrorFactory, HMSAction } from '../../error/ErrorFactory';\n\nclass Store implements IStore {\n  private readonly comparator: Comparator = new Comparator(this);\n  private room?: HMSRoom;\n  private knownRoles: KnownRoles = {};\n  private localPeerId?: string;\n  private peers: Record<string, HMSPeer> = {};\n  private tracks: Record<string, HMSTrack> = {};\n  // Not used currently. Will be used exclusively for preview tracks.\n  // private previewTracks: Record<string, HMSTrack> = {};\n  private peerTrackStates: Record<string, TrackStateEntry> = {};\n  private speakers: HMSSpeaker[] = [];\n  private videoLayers: SimulcastLayers | null = null;\n  private screenshareLayers: SimulcastLayers | null = null;\n  private config?: HMSConfig;\n  private publishParams?: PublishParams;\n  private errorListener?: IErrorListener;\n\n  getConfig() {\n    return this.config;\n  }\n\n  getPublishParams() {\n    return this.publishParams;\n  }\n\n  getComparator() {\n    return this.comparator;\n  }\n\n  getRoom() {\n    return this.room!;\n  }\n\n  getPolicyForRole(role: string) {\n    return this.knownRoles[role];\n  }\n\n  getKnownRoles() {\n    return this.knownRoles;\n  }\n\n  getLocalPeer() {\n    if (this.localPeerId && this.peers[this.localPeerId]) {\n      return this.peers[this.localPeerId] as HMSLocalPeer;\n    }\n    return undefined;\n  }\n\n  getRemotePeers() {\n    return Object.values(this.peers).filter((peer) => !peer.isLocal) as HMSRemotePeer[];\n  }\n\n  getPeers(): HMSPeer[] {\n    return Object.values(this.peers);\n  }\n\n  getPeerById(peerId: string) {\n    if (this.peers[peerId]) {\n      return this.peers[peerId];\n    }\n    return undefined;\n  }\n\n  getTracks() {\n    return Object.values(this.tracks);\n  }\n\n  getVideoTracks() {\n    return this.getTracks().filter((track) => track.type === HMSTrackType.VIDEO) as HMSVideoTrack[];\n  }\n\n  getRemoteVideoTracks() {\n    return this.getTracks().filter((track) => track instanceof HMSRemoteVideoTrack) as HMSRemoteVideoTrack[];\n  }\n\n  getAudioTracks() {\n    return this.getTracks().filter((track) => track.type === HMSTrackType.AUDIO) as HMSAudioTrack[];\n  }\n\n  getPeerTracks(peerId?: string) {\n    const peer = peerId ? this.peers[peerId] : undefined;\n    const tracks: HMSTrack[] = [];\n    peer?.videoTrack && tracks.push(peer.videoTrack);\n    peer?.audioTrack && tracks.push(peer.audioTrack);\n    return tracks.concat(peer?.auxiliaryTracks || []);\n  }\n\n  getLocalPeerTracks() {\n    return this.getPeerTracks(this.localPeerId) as HMSLocalTrack[];\n  }\n\n  getTrackById(trackId: string) {\n    return this.tracks[trackId];\n  }\n\n  getPeerByTrackId(trackId: string) {\n    const track = this.tracks[trackId];\n    return track.peerId ? this.peers[track.peerId] : undefined;\n  }\n\n  getSpeakers() {\n    return this.speakers;\n  }\n\n  getSpeakerPeers() {\n    return this.speakers.map((speaker) => speaker.peer);\n  }\n\n  setRoom(room: HMSRoom) {\n    this.room = room;\n  }\n\n  setKnownRoles(knownRoles: KnownRoles) {\n    this.knownRoles = knownRoles;\n    this.updatePeersPolicy();\n  }\n\n  setConfig(config: HMSConfig) {\n    DeviceStorageManager.rememberDevices(Boolean(config.rememberDeviceSelection));\n    if (config.rememberDeviceSelection) {\n      const devices: SelectedDevices | undefined = DeviceStorageManager.getSelection();\n      if (devices) {\n        if (!config.settings) {\n          config.settings = {};\n        }\n        if (devices.audioInput?.deviceId) {\n          config.settings.audioInputDeviceId = config.settings.audioInputDeviceId || devices.audioInput.deviceId;\n        }\n        if (devices.audioOutput?.deviceId) {\n          config.settings.audioOutputDeviceId = config.settings.audioOutputDeviceId || devices.audioOutput.deviceId;\n        }\n        if (devices.videoInput?.deviceId) {\n          config.settings.videoDeviceId = config.settings.videoDeviceId || devices.videoInput.deviceId;\n        }\n      }\n    }\n    this.config = config;\n  }\n\n  setPublishParams(params: PublishParams) {\n    this.publishParams = params;\n  }\n\n  addPeer(peer: HMSPeer) {\n    this.peers[peer.peerId] = peer;\n    if (peer.isLocal) this.localPeerId = peer.peerId;\n  }\n\n  /**\n   * @param {HMSTrack} track the published track that has to be added\n   *\n   * Note: Only use this method to add published tracks not preview traks\n   */\n  addTrack(track: HMSTrack) {\n    this.tracks[track.trackId] = track;\n  }\n\n  getTrackState(trackId: string) {\n    return this.peerTrackStates[trackId];\n  }\n\n  setTrackState(trackStateEntry: TrackStateEntry) {\n    this.peerTrackStates[trackStateEntry.trackInfo.track_id] = trackStateEntry;\n  }\n\n  removePeer(peerId: string) {\n    if (this.localPeerId === peerId) this.localPeerId = undefined;\n    delete this.peers[peerId];\n  }\n\n  removeTrack(trackId: string) {\n    delete this.tracks[trackId];\n  }\n\n  updateSpeakers(speakers: HMSSpeaker[]) {\n    this.speakers = speakers;\n  }\n\n  updateAudioOutputVolume(value: number) {\n    this.getAudioTracks().forEach((track) => track.setVolume(value));\n  }\n\n  updateAudioOutputDevice(device: MediaDeviceInfo) {\n    this.getAudioTracks().forEach((track) => {\n      track.setOutputDevice(device);\n    });\n  }\n\n  getSubscribeDegradationParams() {\n    const params = this.getLocalPeer()?.role?.subscribeParams.subscribeDegradation;\n    if (params && Object.keys(params).length > 0) {\n      return params;\n    }\n    return undefined;\n  }\n\n  getSimulcastLayers(source: HMSTrackSource): SimulcastLayer[] {\n    if (source === 'screen') {\n      return this.screenshareLayers?.layers || [];\n    }\n    return this.videoLayers?.layers || [];\n  }\n\n  getSimulcastDimensions(source: HMSTrackSource): SimulcastDimensions {\n    const layers = source === 'screen' ? this.screenshareLayers : this.videoLayers;\n    const width = layers?.width;\n    const height = layers?.height;\n    return {\n      width,\n      height,\n    };\n  }\n\n  /**\n   * Convert maxBitrate from kbps to bps\n   * @internal\n   * @param simulcastLayers\n   * @returns {SimulcastLayers}\n   */\n  private convertSimulcastLayers(simulcastLayers: SimulcastLayers) {\n    return {\n      ...simulcastLayers,\n      layers: (simulcastLayers.layers || []).map((layer) => {\n        return {\n          ...layer,\n          maxBitrate: layer.maxBitrate * 1000,\n        };\n      }),\n    };\n  }\n\n  setVideoSimulcastLayers(simulcastLayers: SimulcastLayers): void {\n    this.videoLayers = this.convertSimulcastLayers(simulcastLayers);\n  }\n\n  setScreenshareSimulcastLayers(simulcastLayers: SimulcastLayers): void {\n    this.screenshareLayers = this.convertSimulcastLayers(simulcastLayers);\n  }\n\n  getSimulcastDefinitionsForPeer(peer: HMSPeer, source: HMSTrackSource) {\n    if (!peer.role) return [];\n\n    const publishParams = this.getPolicyForRole(peer.role.name).publishParams;\n    let simulcastLayers: SimulcastLayers | undefined;\n    if (source === 'regular') {\n      simulcastLayers = publishParams.videoSimulcastLayers;\n    } else if (source === 'screen') {\n      simulcastLayers = publishParams.screenSimulcastLayers;\n    }\n    if (!simulcastLayers || !simulcastLayers.layers || simulcastLayers.layers.length === 0) {\n      return [];\n    }\n    const width = simulcastLayers.width;\n    const height = simulcastLayers.height;\n    return simulcastLayers.layers.map((value) => {\n      const layer = simulcastMapping[value.rid as RID];\n      const resolution = {\n        width: width && value.scaleResolutionDownBy ? width / value.scaleResolutionDownBy : undefined,\n        height: height && value.scaleResolutionDownBy ? height / value.scaleResolutionDownBy : undefined,\n      };\n      return {\n        layer,\n        resolution,\n      } as SimulcastLayerDefinition;\n    });\n  }\n\n  cleanUp() {\n    const tracks = this.getTracks();\n    for (const track of tracks) {\n      track.cleanup();\n    }\n    this.config = undefined;\n  }\n\n  setErrorListener(listener: IErrorListener) {\n    this.errorListener = listener;\n  }\n\n  private updatePeersPolicy() {\n    this.getPeers().forEach((peer) => {\n      if (!peer.role) {\n        this.errorListener?.onError(ErrorFactory.GenericErrors.InvalidRole(HMSAction.VALIDATION, ''));\n        return;\n      }\n      peer.role = this.getPolicyForRole(peer.role.name);\n    });\n  }\n}\n\nexport { Store };\n","import { HMSRole } from '../interfaces';\nimport InitialSettings from '../interfaces/settings';\nimport { HMSPeerUpdate, HMSTrackUpdate, HMSUpdateListener } from '../interfaces/update-listener';\nimport ITransport from '../transport/ITransport';\nimport { IStore } from './store';\n\nexport type PublishConfig = {\n  publishAudio?: boolean;\n  publishVideo?: boolean;\n};\n\nexport default class RoleChangeManager {\n  constructor(\n    private store: IStore,\n    private transport: ITransport,\n    private publish: (settings: InitialSettings, publishConfig?: PublishConfig) => void,\n    private removeAuxillaryTrack: (trackId: string) => void,\n    private listener?: HMSUpdateListener,\n  ) {}\n\n  public handleLocalPeerRoleUpdate = async (event: any) => {\n    const localPeer = this.store.getLocalPeer();\n\n    if (!localPeer) {\n      return;\n    }\n    const oldRole = event.detail.oldRole as HMSRole;\n    const newRole = event.detail.newRole as HMSRole;\n\n    const wasPublishing = oldRole.publishParams.allowed || [];\n    const isPublishing = newRole.publishParams.allowed || [];\n\n    const toRemove = {\n      removeVideo: false,\n      removeAudio: false,\n      removeScreen: false,\n    };\n\n    if (wasPublishing.length > 0) {\n      // check if we have to remove any tracks\n      if (isPublishing.length === 0) {\n        toRemove.removeVideo = true;\n        toRemove.removeAudio = true;\n        toRemove.removeScreen = true;\n      } else {\n        if (wasPublishing.includes('video') && !isPublishing.includes('video')) {\n          toRemove.removeVideo = true;\n        }\n\n        if (wasPublishing.includes('audio') && !isPublishing.includes('audio')) {\n          toRemove.removeAudio = true;\n        }\n\n        if (wasPublishing.includes('screen') && !isPublishing.includes('screen')) {\n          toRemove.removeScreen = true;\n        }\n      }\n    }\n\n    await this.removeLocalTracks(toRemove);\n    this.store.setPublishParams(newRole.publishParams);\n\n    const initialSettings = this.store.getConfig()?.settings || {\n      isAudioMuted: true,\n      isVideoMuted: true,\n      audioInputDeviceId: 'default',\n      videoDeviceId: 'default',\n      audioOutputDeviceId: 'default',\n    };\n    // call publish with new settings, local track manager will diff policies\n    await this.publish({ ...initialSettings, isAudioMuted: true, isVideoMuted: true });\n\n    this.listener?.onPeerUpdate(HMSPeerUpdate.ROLE_UPDATED, localPeer);\n  };\n\n  private async removeLocalTracks({\n    removeVideo,\n    removeAudio,\n    removeScreen,\n  }: {\n    removeVideo: boolean;\n    removeAudio: boolean;\n    removeScreen: boolean;\n  }) {\n    const localPeer = this.store.getLocalPeer();\n\n    if (!localPeer) {\n      return;\n    }\n\n    const tracksToUnpublish = [];\n\n    // TODO check auxillary tracks for regular audio and video too\n    if (localPeer?.videoTrack && removeVideo) {\n      // TODO: stop processed track and cleanup plugins loop non async\n      // vb can throw change role off otherwise\n      tracksToUnpublish.push(localPeer.videoTrack);\n      localPeer.videoTrack = undefined;\n    }\n\n    if (localPeer?.audioTrack && removeAudio) {\n      tracksToUnpublish.push(localPeer.audioTrack);\n      localPeer.audioTrack = undefined;\n    }\n\n    await this.transport.unpublish(tracksToUnpublish);\n    for (let track of tracksToUnpublish) {\n      this.listener?.onTrackUpdate(HMSTrackUpdate.TRACK_REMOVED, track, localPeer);\n    }\n\n    if (localPeer.auxiliaryTracks && removeScreen) {\n      const localAuxTracks = [...localPeer.auxiliaryTracks];\n      for (const track of localAuxTracks) {\n        if (track.source === 'screen') {\n          await this.removeAuxillaryTrack(track.trackId);\n        }\n      }\n    }\n  }\n}\n","import HMSLogger from '../utils/logger';\n\nexport class AudioContextManager {\n  private audioContext: AudioContext;\n  private destinationNode?: MediaStreamAudioDestinationNode;\n  private source: MediaElementAudioSourceNode;\n\n  constructor(element: HTMLMediaElement) {\n    this.audioContext = new AudioContext();\n    this.source = this.audioContext.createMediaElementSource(element);\n    this.source.connect(this.audioContext.destination);\n  }\n\n  /**\n   * Resume AudioContext if it is suspended\n   * Note: when the browser tab is muted by default, AudioContext will be in suspended state\n   * It has to be resumed for the video/audio to be played.\n   */\n  resumeContext() {\n    if (this.audioContext.state === 'suspended') {\n      HMSLogger.d(this.TAG, 'AudioContext is resumed');\n      this.audioContext.resume();\n    }\n  }\n\n  getAudioTrack() {\n    // Always create a destinationNode to get new audio track id\n    if (this.destinationNode) {\n      this.source.disconnect(this.destinationNode);\n    }\n    this.destinationNode = this.audioContext.createMediaStreamDestination();\n    this.source.connect(this.destinationNode);\n    return this.destinationNode.stream.getAudioTracks()[0];\n  }\n\n  cleanup() {\n    if (this.audioContext.state !== 'closed') {\n      this.audioContext.close();\n    }\n  }\n\n  private get TAG() {\n    return 'AudioContextManager';\n  }\n}\n","import HMSLogger from '../utils/logger';\nimport { TypedEventEmitter } from '../utils/typed-event-emitter';\nimport { AudioContextManager } from './AudioContextManager';\n\n/**\n * This class handles audio playlist management\n * - An audio element and audio context which processes audio from audio element is created\n *   in the constructor\n * It handles playback in the following steps\n *  - set's the url on the audio element created in the constructor\n *  - oncanplaythrough event of the audio element\n *    - resume the audio context if it is suspended\n *    - play the audio element\n *    - Get audio track from the audio context manager\n *    - The track is passed to playlist manager to publish\n */\nexport class PlaylistAudioManager extends TypedEventEmitter<{ ended: null; progress: Event }> {\n  private audioElement: HTMLAudioElement | null;\n  private track?: MediaStreamTrack;\n  private audioContextManager!: AudioContextManager;\n  // This is to handle audio playing when seekTo is called when audio is paused\n  private seeked = false;\n\n  constructor() {\n    super();\n    this.audioElement = this.getAudioElement();\n  }\n\n  async play(url: string) {\n    return new Promise<MediaStreamTrack[]>((resolve, reject) => {\n      this.audioElement = this.getAudioElement();\n      this.audioElement.src = url;\n      this.seeked = false;\n      this.audioElement.onerror = () => {\n        const error = `Error loading ${url}`;\n        HMSLogger.e(this.TAG, error);\n        this.stop();\n        reject(error);\n      };\n      // oncanplaythrough is called when enough media is loaded for play to be possible in two cases -\n      //    * when play is called for the first time\n      //    * when user seeks jumps to any mid track timestamp\n      this.audioElement.oncanplaythrough = async () => {\n        try {\n          if (!this.audioElement) {\n            return;\n          }\n          this.audioContextManager.resumeContext();\n          // Create audio track only once and reuse, it will be updated with current content\n          if (!this.track) {\n            await this.audioElement.play();\n            let audioTrack = this.audioContextManager.getAudioTrack();\n            this.track = audioTrack;\n            resolve([audioTrack]);\n          } else {\n            if (!this.seeked) {\n              // if this was called in response to a play call\n              await this.audioElement.play();\n              resolve([this.track]);\n            } else {\n              // if seek happened, there is no play call/promise to be resolved, just reset seeked\n              this.seeked = false;\n            }\n          }\n        } catch (err) {\n          HMSLogger.e(this.TAG, 'Error playing audio', url, (err as ErrorEvent).message);\n          reject(err);\n        }\n      };\n      this.audioElement.onseeked = () => {\n        this.seeked = true;\n      };\n    });\n  }\n\n  getTracks() {\n    return this.track ? [this.track.id] : [];\n  }\n\n  getElement() {\n    return this.audioElement;\n  }\n\n  stop() {\n    this.audioElement?.pause();\n    this.audioElement?.removeAttribute('src');\n    this.audioElement = null;\n    this.audioContextManager.cleanup();\n    this.track = undefined;\n  }\n\n  private getAudioElement() {\n    if (this.audioElement) {\n      return this.audioElement;\n    }\n    const audioElement = document.createElement('audio');\n    audioElement.crossOrigin = 'anonymous';\n    audioElement.addEventListener('timeupdate', (event) => this.emit('progress', event));\n    audioElement.addEventListener('ended', () => {\n      this.emit('ended', null);\n    });\n    this.audioContextManager = new AudioContextManager(audioElement);\n    return audioElement;\n  }\n\n  private get TAG() {\n    return 'PlaylistAudioManager';\n  }\n}\n","import HMSLogger from '../utils/logger';\nimport { TypedEventEmitter } from '../utils/typed-event-emitter';\nimport { AudioContextManager } from './AudioContextManager';\n\n/**\n * This class handles video playlist management\n * - An video element, canvas and audio context which processes audio from video element is created\n *   in the constructor\n * It handles playback in the following steps\n *  - set's the url on the video element created in the constructor\n *  - oncanplaythrough event of the video element\n *    - resume the audio context if it is suspended\n *    - set width/height on canvas\n *    - captureStream on canvas element if not already captured\n *    - play the video element\n *    - on video element is played, it is drawn to canvas\n *    - Get audio track from the audio context manager\n *    - add audioTrack to canvas stream\n *    - The audio and video tracks are passed to playlist manager to publish\n */\nexport class PlaylistVideoManager extends TypedEventEmitter<{ ended: null; progress: Event }> {\n  private videoElement: HTMLVideoElement | null;\n  private canvasContext: CanvasRenderingContext2D | null;\n  private canvas!: HTMLCanvasElement;\n  private timer: any;\n  private tracks: MediaStreamTrack[] = [];\n  private audioContextManager!: AudioContextManager;\n  private DEFAUL_FPS = 24;\n  // This is to handle video playing when seekTo is called when video is paused\n  private seeked = false;\n\n  constructor() {\n    super();\n    this.videoElement = this.getVideoElement();\n    this.canvas = document.createElement('canvas');\n    this.canvasContext = this.canvas.getContext('2d');\n  }\n\n  play(url: string) {\n    return new Promise<MediaStreamTrack[]>((resolve, reject) => {\n      this.videoElement = this.getVideoElement();\n      this.videoElement.src = url;\n      this.seeked = false;\n      this.videoElement.onerror = () => {\n        const error = `Error loading ${url}`;\n        HMSLogger.e(this.TAG, error);\n        this.stop();\n        reject(error);\n      };\n      // oncanplaythrough is called when enough media is loaded for play to be possible in two cases -\n      //    * when play is called for the first time\n      //    * when user jumps to any mid track timestamp using seekTo\n      this.videoElement.oncanplaythrough = async () => {\n        try {\n          if (!this.videoElement) {\n            return;\n          }\n          this.canvas.width = this.videoElement.videoWidth;\n          this.canvas.height = this.videoElement.videoHeight;\n          // Capture stream only once and reuse the same tracks. it will be autoupdated with the selected video\n          if (this.tracks.length === 0) {\n            this.clearCanvasAndTracks();\n            //@ts-ignore\n            const stream = this.canvas.captureStream();\n            if (!stream) {\n              HMSLogger.e(this.TAG, 'Browser does not support captureStream');\n              return;\n            }\n            this.videoElement.onplay = this.drawImage;\n            this.audioContextManager.resumeContext();\n            await this.videoElement.play();\n            const audioTrack = this.audioContextManager.getAudioTrack();\n            stream.addTrack(audioTrack);\n            stream.getTracks().forEach((track: MediaStreamTrack) => {\n              this.tracks.push(track);\n            });\n            resolve(this.tracks);\n          } else {\n            // No need to capture canvas stream/get audio track. They wull be auto updated\n            if (!this.seeked) {\n              // if this was called in response to a play call\n              await this.videoElement.play();\n              resolve(this.tracks);\n            } else {\n              // if seek happened, there is no play call/promise to be resolved, just reset seeked\n              this.seeked = false;\n              // This event will be called on seekTo when paused. Just draw the one frame on canvas.\n              this.canvasContext?.drawImage(this.videoElement, 0, 0, this.canvas?.width, this.canvas?.height);\n            }\n          }\n        } catch (err) {\n          HMSLogger.e(this.TAG, 'Error playing video', url, (err as ErrorEvent).message);\n          reject(err);\n        }\n      };\n      this.videoElement.onseeked = () => {\n        this.seeked = true;\n      };\n    });\n  }\n\n  getTracks() {\n    return this.tracks.map((track) => track.id);\n  }\n\n  getElement() {\n    return this.videoElement;\n  }\n\n  stop() {\n    this.videoElement?.pause();\n    this.videoElement?.removeAttribute('src');\n    this.videoElement = null;\n    this.clearCanvasAndTracks();\n  }\n\n  private clearCanvasAndTracks() {\n    this.tracks = [];\n    // clear canvas before playing new video\n    this.canvasContext?.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    clearTimeout(this.timer);\n  }\n\n  private drawImage = () => {\n    if (this.videoElement && !this.videoElement.paused && !this.videoElement.ended) {\n      this.canvasContext?.drawImage(this.videoElement, 0, 0, this.canvas?.width, this.canvas?.height);\n      this.timer = setTimeout(() => {\n        this.drawImage();\n      }, 1000 / this.DEFAUL_FPS);\n    }\n  };\n\n  private getVideoElement() {\n    if (this.videoElement) {\n      return this.videoElement;\n    }\n    const videoElement = document.createElement('video');\n    videoElement.crossOrigin = 'anonymous';\n    videoElement.addEventListener('timeupdate', (event) => this.emit('progress', event));\n    videoElement.addEventListener('ended', () => {\n      this.emit('ended', null);\n    });\n    this.audioContextManager = new AudioContextManager(videoElement);\n    return videoElement;\n  }\n\n  private get TAG() {\n    return 'PlaylistVideoManager';\n  }\n}\n","import { HMSSdk } from '../sdk';\nimport { HMSPlaylistItem, HMSPlaylistType, HMSPlaylistManager, HMSPlaylistProgressEvent } from '../interfaces';\nimport { PlaylistAudioManager } from './PlaylistAudioManager';\nimport { PlaylistVideoManager } from './PlaylistVideoManager';\nimport HMSLogger from '../utils/logger';\nimport { ErrorFactory, HMSAction } from '../error/ErrorFactory';\nimport { TypedEventEmitter } from '../utils/typed-event-emitter';\n\ntype PlaylistManagerState<T> = {\n  audio: {\n    list: HMSPlaylistItem<T>[];\n    currentIndex: number;\n  };\n  video: {\n    list: HMSPlaylistItem<T>[];\n    currentIndex: number;\n  };\n};\n\nconst INITIAL_STATE: PlaylistManagerState<any> = {\n  audio: {\n    list: [],\n    currentIndex: -1,\n  },\n  video: {\n    list: [],\n    currentIndex: -1,\n  },\n};\n\nexport class PlaylistManager\n  extends TypedEventEmitter<{ newTrackStart: HMSPlaylistItem<any>; playlistEnded: HMSPlaylistType }>\n  implements HMSPlaylistManager {\n  private state = { audio: { ...INITIAL_STATE.audio }, video: { ...INITIAL_STATE.video } };\n  private audioManager: PlaylistAudioManager;\n  private videoManager: PlaylistVideoManager;\n\n  constructor(private sdk: HMSSdk) {\n    super();\n    this.audioManager = new PlaylistAudioManager();\n    this.videoManager = new PlaylistVideoManager();\n    this.addListeners();\n  }\n\n  getList<T>(type: HMSPlaylistType = HMSPlaylistType.audio): HMSPlaylistItem<T>[] {\n    return this.state[type].list;\n  }\n\n  setList<T>(list: HMSPlaylistItem<T>[]): void {\n    if (!list || list.length === 0) {\n      HMSLogger.w(this.TAG, `Please pass in a list of HMSPlaylistItem's`);\n      return;\n    }\n    list.forEach((item: HMSPlaylistItem<T>) => {\n      this.state[item.type].list.push(item);\n    });\n  }\n\n  removeItem<T>(item: HMSPlaylistItem<T>): void {\n    const list = this.state[item.type].list;\n    const index = list.findIndex((playItem) => item.id === playItem.id);\n    if (index > -1) {\n      list.splice(index, 1);\n    }\n  }\n\n  seek(value: number, type: HMSPlaylistType = HMSPlaylistType.audio): void {\n    const { currentIndex } = this.state[type];\n    if (currentIndex === -1) {\n      throw ErrorFactory.PlaylistErrors.NoEntryToPlay(HMSAction.PLAYLIST, 'No item is currently playing');\n    }\n    const element = this.getElement(type);\n    if (element) {\n      let updatedValue = Math.max(element.currentTime + value, 0);\n      element.currentTime = Math.min(updatedValue, element.duration);\n    }\n  }\n\n  seekTo(value: number, type: HMSPlaylistType = HMSPlaylistType.audio): void {\n    const { currentIndex } = this.state[type];\n    if (currentIndex === -1) {\n      throw ErrorFactory.PlaylistErrors.NoEntryToPlay(HMSAction.PLAYLIST, 'No item is currently playing');\n    }\n    if (value < 0) {\n      throw Error('value cannot be negative');\n    }\n    const element = this.getElement(type);\n    if (element) {\n      element.currentTime = Math.min(value, element.duration);\n    }\n  }\n\n  setVolume(value: number, type: HMSPlaylistType = HMSPlaylistType.audio): void {\n    if (value < 0 || value > 100) {\n      throw Error('Please pass a valid number between 0-100');\n    }\n    const element = this.getElement(type);\n    if (element) {\n      element.volume = value * 0.01;\n    } else {\n      HMSLogger.w(this.TAG, `No valid element of type ${type} found`);\n    }\n  }\n\n  getVolume(type: HMSPlaylistType = HMSPlaylistType.audio): number {\n    const element = this.getElement(type);\n    if (element) {\n      return element.volume * 100;\n    } else {\n      HMSLogger.w(this.TAG, `No valid element of type ${type} found`);\n    }\n    return 0;\n  }\n\n  getCurrentTime(type: HMSPlaylistType = HMSPlaylistType.audio) {\n    const element = this.getElement(type);\n    return element?.currentTime || 0;\n  }\n\n  getCurrentIndex(type: HMSPlaylistType = HMSPlaylistType.audio) {\n    return this.state[type].currentIndex;\n  }\n\n  getCurrentProgress(type: HMSPlaylistType = HMSPlaylistType.audio) {\n    const { list, currentIndex } = this.state[type];\n    const activeUrl = list[currentIndex]?.url;\n    const element = this.getElement(type);\n    if (!activeUrl || !element) {\n      return 0;\n    }\n    return Math.floor(100 * (element.currentTime / element.duration));\n  }\n\n  getCurrentSelection(type: HMSPlaylistType = HMSPlaylistType.audio) {\n    const { list, currentIndex } = this.state[type];\n    if (currentIndex === -1) {\n      return undefined;\n    }\n    return list[currentIndex];\n  }\n\n  isPlaying(type: HMSPlaylistType = HMSPlaylistType.audio) {\n    const element = this.getElement(type);\n    return !!element && !element.paused;\n  }\n\n  async setEnabled(\n    enabled: boolean,\n    { id, type = HMSPlaylistType.audio }: { id: string; type: HMSPlaylistType },\n  ): Promise<void> {\n    const list = this.state[type].list;\n    const currentIndex = list.findIndex((item) => item.id === id);\n    if (!id || currentIndex === -1) {\n      HMSLogger.w(this.TAG, 'Pass a valid id');\n      return;\n    }\n    const url = this.state[type].list[currentIndex].url;\n    if (enabled) {\n      await this.play(url, type);\n    } else {\n      await this.pause(url, type);\n    }\n    this.state[type].currentIndex = currentIndex;\n    this.setDuration(type);\n  }\n\n  async playNext(type: HMSPlaylistType = HMSPlaylistType.audio): Promise<void> {\n    const { list, currentIndex } = this.state[type];\n    if (currentIndex >= list.length - 1) {\n      throw ErrorFactory.PlaylistErrors.NoEntryToPlay(HMSAction.PLAYLIST, 'Reached end of playlist');\n    }\n    await this.play(list[currentIndex + 1].url, type);\n    this.state[type].currentIndex = currentIndex + 1;\n    this.setDuration(type);\n  }\n\n  async playPrevious(type: HMSPlaylistType = HMSPlaylistType.audio): Promise<void> {\n    const { list, currentIndex } = this.state[type];\n    if (currentIndex <= 0) {\n      throw ErrorFactory.PlaylistErrors.NoEntryToPlay(HMSAction.PLAYLIST, 'Reached start of playlist');\n    }\n    await this.play(list[currentIndex - 1].url, type);\n    this.state[type].currentIndex = currentIndex - 1;\n    this.setDuration(type);\n  }\n\n  async stop(type: HMSPlaylistType = HMSPlaylistType.audio): Promise<void> {\n    const manager = type === HMSPlaylistType.audio ? this.audioManager : this.videoManager;\n    await this.removeTracks(type);\n    manager.stop();\n    this.state[type].currentIndex = -1;\n  }\n\n  cleanup() {\n    this.state = { audio: { ...INITIAL_STATE.audio }, video: { ...INITIAL_STATE.video } };\n    this.audioManager.stop();\n    this.videoManager.stop();\n  }\n\n  onProgress(fn: (progress: HMSPlaylistProgressEvent) => void) {\n    this.videoManager.on('progress', () => {\n      try {\n        fn({\n          type: HMSPlaylistType.video,\n          progress: this.getCurrentProgress(HMSPlaylistType.video),\n        });\n      } catch (error) {\n        HMSLogger.e(this.TAG, 'Error in onProgress callback');\n      }\n    });\n    this.audioManager.on('progress', () => {\n      try {\n        fn({\n          type: HMSPlaylistType.audio,\n          progress: this.getCurrentProgress(HMSPlaylistType.audio),\n        });\n      } catch (error) {\n        HMSLogger.e(this.TAG, 'Error in onProgress callback');\n      }\n    });\n  }\n\n  onNewTrackStart<T>(fn: (item: HMSPlaylistItem<T>) => void) {\n    this.on('newTrackStart', fn);\n  }\n\n  onPlaylistEnded(fn: (type: HMSPlaylistType) => void) {\n    this.on('playlistEnded', fn);\n  }\n\n  private getElement(type: HMSPlaylistType = HMSPlaylistType.audio) {\n    return type === HMSPlaylistType.audio ? this.audioManager.getElement() : this.videoManager.getElement();\n  }\n\n  private async removeTracks(type: HMSPlaylistType = HMSPlaylistType.audio) {\n    const manager = type === HMSPlaylistType.audio ? this.audioManager : this.videoManager;\n    const tracks = manager.getTracks();\n    for (let trackId of tracks) {\n      await this.removeTrack(trackId);\n    }\n  }\n\n  private async play(url: string, type: HMSPlaylistType = HMSPlaylistType.audio): Promise<void> {\n    const element = this.getElement(type);\n    if (element && !element.paused && element.src.includes(url)) {\n      HMSLogger.w(this.TAG, `The ${type} is currently playing`);\n      return;\n    }\n    if (element && element.src.includes(url)) {\n      await element.play();\n    } else {\n      element?.pause();\n      let tracks: MediaStreamTrack[];\n      if (type === HMSPlaylistType.audio) {\n        tracks = await this.audioManager.play(url);\n      } else {\n        tracks = await this.videoManager.play(url);\n      }\n      for (const track of tracks) {\n        await this.addTrack(track, type === HMSPlaylistType.audio ? 'audioplaylist' : 'videoplaylist');\n      }\n    }\n  }\n\n  private setDuration(type: HMSPlaylistType = HMSPlaylistType.audio) {\n    const element = this.getElement(type);\n    const { list, currentIndex } = this.state[type];\n    if (list[currentIndex]) {\n      list[currentIndex].duration = element?.duration || 0;\n    }\n    this.emit('newTrackStart', list[currentIndex]);\n  }\n\n  private async pause(url: string, type: HMSPlaylistType = HMSPlaylistType.audio): Promise<void> {\n    const el = this.getElement(type);\n    if (el && !el.paused && el.src.includes(url)) {\n      el.pause();\n      HMSLogger.d(this.TAG, 'paused url', url);\n    } else {\n      HMSLogger.w(this.TAG, 'The passed in url is not currently playing');\n    }\n  }\n\n  private addListeners() {\n    this.audioManager.on('ended', () => this.handleEnded(HMSPlaylistType.audio));\n    this.videoManager.on('ended', () => this.handleEnded(HMSPlaylistType.video));\n  }\n\n  /**\n   * Remove tracks if reached the end of list otherwise play next\n   * @param {HMSPlaylistType} type\n   */\n  private async handleEnded(type: HMSPlaylistType = HMSPlaylistType.audio) {\n    const { list, currentIndex } = this.state[type];\n    if (currentIndex === list.length - 1) {\n      await this.stop(type);\n      this.emit('playlistEnded', type);\n    } else {\n      this.playNext(type);\n    }\n  }\n\n  private addTrack = async (track: MediaStreamTrack, source: string) => {\n    await this.sdk.addTrack(track, source);\n    HMSLogger.d(this.TAG, 'Playlist track added', track);\n  };\n\n  private removeTrack = async (trackId: string) => {\n    await this.sdk.removeTrack(trackId);\n    HMSLogger.d(this.TAG, 'Playlist track removed', trackId);\n  };\n\n  private get TAG() {\n    return 'PlaylistManager';\n  }\n}\n","import { HMSConfig, HMSVideoCodec, HMSMessageInput, HMSDeviceChangeEvent } from '../interfaces';\nimport InitialSettings from '../interfaces/settings';\nimport HMSInterface from '../interfaces/hms';\nimport HMSTransport from '../transport';\nimport ITransportObserver from '../transport/ITransportObserver';\nimport { HMSAudioListener, HMSTrackUpdate, HMSUpdateListener } from '../interfaces/update-listener';\nimport HMSLogger, { HMSLogLevel } from '../utils/logger';\nimport decodeJWT from '../utils/jwt';\nimport { NotificationManager, HMSNotificationMethod, PeerLeaveRequestNotification } from '../notification-manager';\nimport {\n  HMSTrackSource,\n  HMSTrackType,\n  HMSLocalAudioTrack,\n  HMSLocalVideoTrack,\n  HMSRemoteVideoTrack,\n  HMSLocalTrack,\n  HMSRemoteTrack,\n} from '../media/tracks';\nimport { HMSException } from '../error/HMSException';\nimport HMSRoom from './models/HMSRoom';\nimport { HMSLocalPeer, HMSPeer, HMSRemotePeer } from './models/peer';\nimport Message from './models/HMSMessage';\nimport HMSLocalStream from '../media/streams/HMSLocalStream';\nimport { HMSVideoTrackSettingsBuilder, HMSAudioTrackSettingsBuilder } from '../media/settings';\nimport { AudioSinkManager } from '../audio-sink-manager';\nimport { DeviceManager, AudioOutputManager } from '../device-manager';\nimport { HMSAnalyticsLevel } from '../analytics/AnalyticsEventLevel';\nimport analyticsEventsService from '../analytics/AnalyticsEventsService';\nimport { TransportState } from '../transport/models/TransportState';\nimport { ErrorFactory, HMSAction } from '../error/ErrorFactory';\nimport { ErrorCodes } from '../error/ErrorCodes';\nimport { HMSPreviewListener } from '../interfaces/preview-listener';\nimport { IErrorListener } from '../interfaces/error-listener';\nimport { IStore, Store } from './store';\nimport { DeviceChangeListener } from '../interfaces/device-change-listener';\nimport { HMSRoleChangeRequest, HMSRole, HMSChangeMultiTrackStateParams } from '../interfaces';\nimport RoleChangeManager from './RoleChangeManager';\nimport { AutoplayError, AutoplayEvent } from '../audio-sink-manager/AudioSinkManager';\nimport { HMSLeaveRoomRequest } from '../interfaces/leave-room-request';\nimport { DeviceStorageManager } from '../device-manager/DeviceStorage';\nimport { LocalTrackManager } from './LocalTrackManager';\nimport { PlaylistManager } from '../playlist-manager';\nimport { RTMPRecordingConfig } from '../interfaces/rtmp-recording-config';\nimport { isNode } from '../utils/support';\n\n// @DISCUSS: Adding it here as a hotfix\nconst defaultSettings = {\n  isAudioMuted: false,\n  isVideoMuted: false,\n  audioInputDeviceId: 'default',\n  audioOutputDeviceId: 'default',\n  videoDeviceId: 'default',\n};\n\nconst INITIAL_STATE = {\n  published: false,\n  isInitialised: false,\n  isReconnecting: false,\n  isPreviewInProgress: false,\n  deviceManagersInitialised: false,\n};\n\nexport class HMSSdk implements HMSInterface {\n  private transport!: HMSTransport;\n  private TAG: string = '[HMSSdk]:';\n  private listener?: HMSUpdateListener;\n  private errorListener?: IErrorListener;\n  private deviceChangeListener?: DeviceChangeListener;\n  private audioListener?: HMSAudioListener;\n  private store!: IStore;\n  private notificationManager!: NotificationManager;\n  private deviceManager!: DeviceManager;\n  private audioSinkManager!: AudioSinkManager;\n  private playlistManager!: PlaylistManager;\n  private audioOutput!: AudioOutputManager;\n  private transportState: TransportState = TransportState.Disconnected;\n  private roleChangeManager?: RoleChangeManager;\n  private localTrackManager!: LocalTrackManager;\n  private sdkState = { ...INITIAL_STATE };\n\n  private initStoreAndManagers() {\n    if (this.sdkState.isInitialised) {\n      /**\n       * Set listener after both join and preview, since they can have different listeners\n       */\n      this.notificationManager.setListener(this.listener);\n      this.audioSinkManager.setListener(this.listener);\n      return;\n    }\n\n    this.sdkState.isInitialised = true;\n    this.store = new Store();\n    this.playlistManager = new PlaylistManager(this);\n    this.notificationManager = new NotificationManager(this.store, this.listener, this.audioListener);\n    this.deviceManager = new DeviceManager(this.store);\n    this.audioSinkManager = new AudioSinkManager(this.store, this.notificationManager, this.deviceManager);\n    this.audioOutput = new AudioOutputManager(this.deviceManager, this.audioSinkManager);\n    this.audioSinkManager.addEventListener(AutoplayError, this.handleAutoplayError);\n    this.transport = new HMSTransport(this.observer, this.deviceManager, this.store);\n    this.localTrackManager = new LocalTrackManager(this.store, this.observer, this.deviceManager);\n  }\n\n  getPlaylistManager(): PlaylistManager {\n    return this.playlistManager;\n  }\n\n  getRecordingState() {\n    return this.store.getRoom()?.recording;\n  }\n\n  getRTMPState() {\n    return this.store.getRoom()?.rtmp;\n  }\n\n  private handleAutoplayError = (event: AutoplayEvent) => {\n    this.errorListener?.onError?.(event.error);\n  };\n\n  private get localPeer(): HMSLocalPeer | undefined {\n    return this.store?.getLocalPeer();\n  }\n\n  private observer: ITransportObserver = {\n    onNotification: (message: any) => {\n      if (message.method === HMSNotificationMethod.PEER_LEAVE_REQUEST) {\n        this.handlePeerLeaveRequest(message.params as PeerLeaveRequestNotification);\n        return;\n      }\n      this.notificationManager.handleNotification(message, this.sdkState.isReconnecting);\n    },\n\n    onTrackAdd: (track: HMSRemoteTrack) => {\n      this.notificationManager.handleTrackAdd(track);\n    },\n\n    onTrackRemove: (track: HMSRemoteTrack) => {\n      this.notificationManager.handleTrackRemove(track);\n    },\n\n    onTrackDegrade: (track: HMSRemoteVideoTrack) => {\n      HMSLogger.d(this.TAG, 'Sending Track Update Track Degraded', track);\n      this.listener?.onTrackUpdate(HMSTrackUpdate.TRACK_DEGRADED, track, this.store?.getPeerByTrackId(track.trackId)!);\n    },\n\n    onTrackRestore: (track: HMSRemoteVideoTrack) => {\n      HMSLogger.d(this.TAG, 'Sending Track Update Track Restored', track);\n      this.listener?.onTrackUpdate(HMSTrackUpdate.TRACK_RESTORED, track, this.store?.getPeerByTrackId(track.trackId)!);\n    },\n\n    onFailure: (exception: HMSException) => {\n      this.errorListener?.onError(exception);\n    },\n\n    onStateChange: async (state: TransportState, error?: HMSException) => {\n      switch (state) {\n        case TransportState.Joined:\n          if (this.transportState === TransportState.Reconnecting) {\n            this.listener?.onReconnected();\n          }\n          break;\n        case TransportState.Failed:\n          await this.leave();\n\n          this.errorListener?.onError?.(error!);\n          this.sdkState.isReconnecting = false;\n          break;\n        case TransportState.Reconnecting:\n          this.sdkState.isReconnecting = true;\n          this.listener?.onReconnecting(error!);\n          break;\n      }\n\n      this.transportState = state;\n    },\n  };\n\n  private handlePeerLeaveRequest = (message: PeerLeaveRequestNotification) => {\n    const peer = this.store.getPeerById(message.requested_by);\n    const request: HMSLeaveRoomRequest = {\n      roomEnded: message.room_end,\n      reason: message.reason,\n      requestedBy: peer!,\n    };\n    this.listener?.onRemovedFromRoom(request);\n    this.leave();\n  };\n\n  async preview(config: HMSConfig, listener: HMSPreviewListener) {\n    if (this.sdkState.isPreviewInProgress) {\n      return;\n    }\n    this.sdkState.isPreviewInProgress = true;\n    const { roomId, userId, role } = decodeJWT(config.authToken);\n    this.errorListener = listener;\n    this.deviceChangeListener = listener;\n    this.initStoreAndManagers();\n\n    this.store.setErrorListener(this.errorListener);\n    this.store.setConfig(config);\n    this.store.setRoom(new HMSRoom(roomId, config.userName, this.store));\n    const policy = this.store.getPolicyForRole(role);\n    const localPeer = new HMSLocalPeer({\n      name: config.userName || '',\n      customerUserId: userId,\n      customerDescription: config.metaData,\n      role: policy,\n    });\n\n    this.store.addPeer(localPeer);\n    HMSLogger.d(this.TAG, 'SDK Store', this.store);\n\n    const policyHandler = async () => {\n      this.notificationManager.removeEventListener('policy-change', policyHandler);\n      const tracks = await this.localTrackManager.getTracksToPublish(config.settings || defaultSettings);\n      tracks.forEach((track) => this.setLocalPeerTrack(track));\n      this.localPeer?.audioTrack && this.initPreviewTrackAudioLevelMonitor();\n      await this.initDeviceManagers();\n      listener.onPreview(this.store.getRoom(), tracks);\n      this.sdkState.isPreviewInProgress = false;\n    };\n\n    this.notificationManager.addEventListener('policy-change', policyHandler);\n\n    try {\n      await this.transport.connect(\n        config.authToken,\n        config.initEndpoint || 'https://prod-init.100ms.live/init',\n        this.localPeer!.peerId,\n      );\n    } catch (ex) {\n      this.errorListener?.onError(ex as HMSException);\n      this.sdkState.isPreviewInProgress = false;\n    }\n  }\n\n  private handleDeviceChangeError = (event: HMSDeviceChangeEvent) => {\n    HMSLogger.d(this.TAG, 'Device Change event', event);\n    this.deviceChangeListener?.onDeviceChange?.(event);\n    if (event.error && event.type) {\n      const track = event.type.includes('audio') ? this.localPeer?.audioTrack : this.localPeer?.videoTrack;\n      this.errorListener?.onError(event.error);\n      if (\n        [\n          ErrorCodes.TracksErrors.CANT_ACCESS_CAPTURE_DEVICE,\n          ErrorCodes.TracksErrors.DEVICE_IN_USE,\n          ErrorCodes.TracksErrors.DEVICE_NOT_AVAILABLE,\n        ].includes(event.error.code) &&\n        track\n      ) {\n        track.setEnabled(false);\n        this.listener?.onTrackUpdate(HMSTrackUpdate.TRACK_MUTED, track, this.localPeer!);\n      }\n    }\n  };\n\n  join(config: HMSConfig, listener: HMSUpdateListener) {\n    if (this.sdkState.isPreviewInProgress) {\n      throw ErrorFactory.GenericErrors.NotReady(HMSAction.JOIN, \"Preview is in progress, can't join\");\n    }\n\n    this.localPeer?.audioTrack?.destroyAudioLevelMonitor();\n    this.listener = listener;\n    this.errorListener = listener;\n    this.deviceChangeListener = listener;\n    this.initStoreAndManagers();\n\n    const storedConfig = this.store.getConfig();\n\n    if (storedConfig && config.settings) {\n      // preview was called\n      delete config.settings.audioOutputDeviceId;\n      delete config.settings.videoDeviceId;\n      delete config.settings.audioInputDeviceId;\n    }\n\n    this.store.setErrorListener(this.errorListener);\n    this.store.setConfig(config);\n    const { roomId, userId, role } = decodeJWT(config.authToken);\n\n    if (!this.localPeer) {\n      this.notificationManager.addEventListener('role-change', (e: any) => {\n        this.store.setPublishParams(e.detail.params.role.publishParams);\n      });\n\n      const localPeer = new HMSLocalPeer({\n        name: config.userName,\n        customerUserId: userId,\n        customerDescription: config.metaData || '',\n        role: this.store.getPolicyForRole(role),\n      });\n      this.store.addPeer(localPeer);\n    } else {\n      this.localPeer.name = config.userName;\n      this.localPeer.role = this.store.getPolicyForRole(role);\n      this.localPeer.customerUserId = userId;\n      this.localPeer.customerDescription = config.metaData || '';\n    }\n\n    this.roleChangeManager = new RoleChangeManager(\n      this.store,\n      this.transport,\n      this.publish.bind(this),\n      this.removeTrack.bind(this),\n      this.listener,\n    );\n    this.notificationManager.addEventListener(\n      'local-peer-role-update',\n      this.roleChangeManager.handleLocalPeerRoleUpdate,\n    );\n\n    HMSLogger.d(this.TAG, 'SDK Store', this.store);\n    HMSLogger.d(this.TAG, `⏳ Joining room ${roomId}`);\n\n    if (!this.store.getRoom()) {\n      // note: store room is used to handle server notifications in join and has to be done before join process starts\n      this.store.setRoom(new HMSRoom(roomId, config.userName, this.store));\n    }\n    HMSLogger.time(`join-room-${roomId}`);\n    this.transport\n      .join(\n        config.authToken,\n        this.localPeer!.peerId,\n        { name: config.userName, metaData: config.metaData || '' },\n        config.initEndpoint,\n        config.autoVideoSubscribe,\n      )\n      .then(async () => {\n        HMSLogger.d(this.TAG, `✅ Joined room ${roomId}`);\n        // if delay fix is set, call onJoin before publishing\n        //@ts-ignore\n        if (window.HMS?.JOIN_DELAY_FIX) {\n          this.notifyJoin();\n        }\n        if (this.publishParams && !this.sdkState.published && !isNode) {\n          await this.publish(config.settings || defaultSettings);\n        }\n        //@ts-ignore\n        if (!window.HMS?.JOIN_DELAY_FIX) {\n          this.notifyJoin();\n        }\n      })\n      .catch((error) => {\n        this.listener?.onError(error as HMSException);\n        HMSLogger.e(this.TAG, 'Unable to join room', error);\n      })\n      .then(() => {\n        HMSLogger.timeEnd(`join-room-${roomId}`);\n      });\n  }\n\n  private cleanUp() {\n    this.store.cleanUp();\n    this.cleanDeviceManagers();\n    DeviceStorageManager.cleanup();\n    this.playlistManager.cleanup();\n    HMSLogger.cleanUp();\n    this.sdkState = { ...INITIAL_STATE };\n    /**\n     * when leave is called after preview itself without join.\n     * Store won't have the tracks in this case\n     */\n    if (this.localPeer) {\n      this.localPeer.audioTrack?.cleanup();\n      this.localPeer.audioTrack = undefined;\n      this.localPeer.videoTrack?.cleanup();\n      this.localPeer.videoTrack = undefined;\n    }\n    this.listener = undefined;\n    if (this.roleChangeManager) {\n      this.notificationManager.removeEventListener(\n        'local-peer-role-update',\n        this.roleChangeManager.handleLocalPeerRoleUpdate,\n      );\n    }\n  }\n\n  async leave() {\n    const room = this.store.getRoom();\n    if (room) {\n      const roomId = room.id;\n      HMSLogger.d(this.TAG, `⏳ Leaving room ${roomId}`);\n      // browsers often put limitation on amount of time a function set on window onBeforeUnload can take in case of\n      // tab refresh or close. Therefore prioritise the leave action over anything else, if tab is closed/refreshed\n      // we would want leave to succeed to stop stucked peer for others. The followup cleanup however is important\n      // for cases where uses stays on the page post leave.\n      await this.transport?.leave();\n      this.cleanUp();\n      HMSLogger.d(this.TAG, `✅ Left room ${roomId}`);\n    }\n  }\n\n  getLocalPeer() {\n    return this.store.getLocalPeer();\n  }\n\n  getPeers() {\n    const peers = this.store.getPeers();\n    HMSLogger.d(this.TAG, `Got peers`, peers);\n    return peers;\n  }\n\n  getAudioOutput() {\n    return this.audioOutput;\n  }\n\n  sendMessage(type: string, message: string) {\n    this.sendMessageInternal({ message, type });\n  }\n\n  async sendBroadcastMessage(message: string, type?: string) {\n    return await this.sendMessageInternal({ message, type });\n  }\n\n  async sendGroupMessage(message: string, roles: HMSRole[], type?: string) {\n    const knownRoles = this.store.getKnownRoles();\n    const recipientRoles =\n      roles.filter((role) => {\n        return knownRoles[role.name];\n      }) || [];\n    if (recipientRoles.length === 0) {\n      throw ErrorFactory.GenericErrors.ValidationFailed('No valid role is present', roles);\n    }\n    return await this.sendMessageInternal({ message, recipientRoles: roles, type });\n  }\n\n  async sendDirectMessage(message: string, peer: HMSPeer, type?: string) {\n    let recipientPeer = this.store.getPeerById(peer.peerId);\n    if (!recipientPeer) {\n      throw ErrorFactory.GenericErrors.ValidationFailed('Invalid peer - peer not present in the room', peer);\n    }\n    if (this.localPeer?.peerId === peer.peerId) {\n      throw ErrorFactory.GenericErrors.ValidationFailed('Cannot send message to self');\n    }\n    return await this.sendMessageInternal({ message, recipientPeer: peer, type });\n  }\n\n  private async sendMessageInternal({ recipientRoles, recipientPeer, type = 'chat', message }: HMSMessageInput) {\n    if (message.replace(/\\u200b/g, ' ').trim() === '') {\n      HMSLogger.w(this.TAG, 'sendMessage', 'Ignoring empty message send');\n      throw ErrorFactory.GenericErrors.ValidationFailed('Empty message not allowed');\n    }\n    const hmsMessage = new Message({\n      sender: this.localPeer!,\n      type,\n      message,\n      recipientPeer,\n      recipientRoles,\n      time: new Date(),\n    });\n    HMSLogger.d(this.TAG, 'Sending Message:: ', hmsMessage);\n    await this.transport.sendMessage(hmsMessage);\n    return hmsMessage;\n  }\n\n  async startScreenShare(onStop: () => void, audioOnly = false) {\n    const publishParams = this.publishParams;\n    if (!publishParams) return;\n\n    const { screen, allowed } = publishParams;\n    const canPublishScreen = allowed && allowed.includes('screen');\n\n    if (!canPublishScreen) {\n      HMSLogger.e(this.TAG, `Role ${this.localPeer?.role} cannot share screen`);\n      return;\n    }\n\n    if (this.localPeer?.auxiliaryTracks?.find((track) => track.source === 'screen')) {\n      throw Error('Cannot share multiple screens');\n    }\n\n    const dimensions = this.store.getSimulcastDimensions('screen');\n    const [videoTrack, audioTrack] = await this.transport!.getLocalScreen(\n      new HMSVideoTrackSettingsBuilder()\n        // Don't cap maxBitrate for screenshare.\n        // If publish params doesn't have bitRate value - don't set maxBitrate.\n        .maxBitrate(screen.bitRate, false)\n        .codec(screen.codec as HMSVideoCodec)\n        .maxFramerate(screen.frameRate)\n        .setWidth(dimensions?.width || screen.width)\n        .setHeight(dimensions?.height || screen.height)\n        .build(),\n      new HMSAudioTrackSettingsBuilder().build(),\n    );\n\n    const handleEnded = () => {\n      this.stopEndedScreenshare(onStop);\n    };\n\n    const tracks = [];\n    if (audioOnly) {\n      videoTrack.nativeTrack.stop();\n      if (!audioTrack) {\n        throw Error('Select share audio when sharing screen');\n      }\n      tracks.push(audioTrack);\n      audioTrack.nativeTrack.onended = handleEnded;\n    } else {\n      tracks.push(videoTrack);\n      videoTrack.nativeTrack.onended = handleEnded;\n      // audio track is not always available\n      if (audioTrack) {\n        tracks.push(audioTrack);\n      }\n    }\n    await this.transport.publish(tracks);\n    tracks.forEach((track) => {\n      track.peerId = this.localPeer?.peerId;\n      this.localPeer?.auxiliaryTracks.push(track);\n      this.listener?.onTrackUpdate(HMSTrackUpdate.TRACK_ADDED, track, this.localPeer!);\n    });\n  }\n\n  private async stopEndedScreenshare(onStop: () => void) {\n    HMSLogger.d(this.TAG, `✅ Screenshare ended natively`);\n    await this.stopScreenShare();\n    onStop();\n  }\n\n  async stopScreenShare() {\n    HMSLogger.d(this.TAG, `✅ Screenshare ended from app`);\n    const screenTracks = this.localPeer?.auxiliaryTracks.filter((t) => t.source === 'screen');\n    if (screenTracks) {\n      for (let track of screenTracks) {\n        await this.removeTrack(track.trackId);\n      }\n    }\n  }\n\n  async addTrack(track: MediaStreamTrack, source: HMSTrackSource = 'regular'): Promise<void> {\n    if (!track) {\n      HMSLogger.w(this.TAG, 'Please pass a valid MediaStreamTrack');\n      return;\n    }\n    if (!this.localPeer) {\n      throw ErrorFactory.GenericErrors.NotConnected(HMSAction.VALIDATION, 'No local peer present, cannot addTrack');\n    }\n    const isTrackPresent = this.localPeer.auxiliaryTracks.find((t) => t.trackId === track.id);\n    if (isTrackPresent) {\n      return;\n    }\n\n    const type = track.kind;\n    const nativeStream = new MediaStream([track]);\n    const stream = new HMSLocalStream(nativeStream);\n\n    const TrackKlass = type === 'audio' ? HMSLocalAudioTrack : HMSLocalVideoTrack;\n    const hmsTrack = new TrackKlass(stream, track, source);\n    if (source === 'videoplaylist') {\n      const settings: { maxBitrate?: number; width?: number; height?: number } = {};\n      if (type === 'audio') {\n        settings.maxBitrate = 64;\n      } else {\n        settings.maxBitrate = 1000;\n        const { width, height } = track.getSettings();\n        settings.width = width;\n        settings.height = height;\n      }\n      // TODO: rt update from policy once policy is updated\n      await hmsTrack.setSettings(settings);\n    } else if (source === 'audioplaylist') {\n      // TODO: rt update from policy once policy is updated\n      await hmsTrack.setSettings({ maxBitrate: 64 });\n    }\n\n    await this.transport?.publish([hmsTrack]);\n    hmsTrack.peerId = this.localPeer?.peerId;\n    this.localPeer?.auxiliaryTracks.push(hmsTrack);\n    this.listener?.onTrackUpdate(HMSTrackUpdate.TRACK_ADDED, hmsTrack, this.localPeer!);\n  }\n\n  async removeTrack(trackId: string) {\n    if (!this.localPeer) {\n      throw ErrorFactory.GenericErrors.NotConnected(HMSAction.VALIDATION, 'No local peer present, cannot removeTrack');\n    }\n    const trackIndex = this.localPeer.auxiliaryTracks.findIndex((t) => t.trackId === trackId);\n    if (trackIndex > -1) {\n      const track = this.localPeer.auxiliaryTracks[trackIndex];\n      await this.transport!.unpublish([track]);\n      this.localPeer.auxiliaryTracks.splice(trackIndex, 1);\n      this.listener?.onTrackUpdate(HMSTrackUpdate.TRACK_REMOVED, track, this.localPeer);\n    } else {\n      HMSLogger.w(this.TAG, `No track found for ${trackId}`);\n    }\n  }\n\n  setAnalyticsLevel(level: HMSAnalyticsLevel) {\n    analyticsEventsService.level = level;\n  }\n\n  setLogLevel(level: HMSLogLevel) {\n    HMSLogger.level = level;\n  }\n\n  addAudioListener(audioListener: HMSAudioListener) {\n    this.audioListener = audioListener;\n    this.notificationManager.setAudioListener(audioListener);\n  }\n\n  async changeRole(forPeer: HMSPeer, toRole: string, force: boolean = false) {\n    if (!forPeer.role || forPeer.role.name === toRole) {\n      return;\n    }\n\n    await this.transport?.changeRole(forPeer, toRole, force);\n  }\n\n  async acceptChangeRole(request: HMSRoleChangeRequest) {\n    await this.transport?.acceptRoleChange(request);\n  }\n\n  async endRoom(lock: boolean, reason: string) {\n    if (!this.localPeer) {\n      throw ErrorFactory.GenericErrors.NotConnected(HMSAction.VALIDATION, 'No local peer present, cannot end room');\n    }\n    await this.transport?.endRoom(lock, reason);\n  }\n\n  async removePeer(peer: HMSRemotePeer, reason: string) {\n    if (!this.localPeer) {\n      throw ErrorFactory.GenericErrors.NotConnected(HMSAction.VALIDATION, 'No local peer present, cannot remove peer');\n    }\n\n    if (!this.store.getPeerById(peer.peerId)) {\n      throw ErrorFactory.GenericErrors.ValidationFailed('Invalid peer, given peer not present in room', peer);\n    }\n    await this.transport?.removePeer(peer.peerId, reason);\n  }\n\n  async startRTMPOrRecording(params: RTMPRecordingConfig) {\n    if (!this.localPeer) {\n      throw ErrorFactory.GenericErrors.NotConnected(\n        HMSAction.VALIDATION,\n        'No local peer present, cannot start streaming or recording',\n      );\n    }\n    await this.transport?.startRTMPOrRecording(params);\n    // emit this notification to update current peer recording status\n    const rtmpStart = { method: HMSNotificationMethod.RTMP_START, params: {} };\n    const recordingStart = { method: HMSNotificationMethod.RECORDING_START, params: { type: 'Browser' } };\n    if (params.rtmpURLs?.length) {\n      this.notificationManager.handleNotification(rtmpStart);\n    }\n    if (params.record) {\n      this.notificationManager.handleNotification(recordingStart);\n    }\n  }\n\n  async stopRTMPAndRecording() {\n    if (!this.localPeer) {\n      throw ErrorFactory.GenericErrors.NotConnected(\n        HMSAction.VALIDATION,\n        'No local peer present, cannot stop streaming or recording',\n      );\n    }\n    await this.transport?.stopRTMPOrRecording();\n    // emit this notification to update current peer recording status\n    const { recording, rtmp } = this.store.getRoom();\n    if (recording?.browser.running) {\n      this.notificationManager.handleNotification({\n        method: HMSNotificationMethod.RECORDING_STOP,\n        params: { type: 'Browser' },\n      });\n    }\n    if (rtmp?.running) {\n      this.notificationManager.handleNotification({ method: HMSNotificationMethod.RTMP_STOP, params: {} });\n    }\n  }\n\n  getRoles(): HMSRole[] {\n    return Object.values(this.store.getKnownRoles());\n  }\n\n  async changeTrackState(forRemoteTrack: HMSRemoteTrack, enabled: boolean) {\n    if (forRemoteTrack.type === HMSTrackType.VIDEO && forRemoteTrack.source !== 'regular') {\n      HMSLogger.w(this.TAG, `Muting non-regular video tracks is currently not supported`);\n      return;\n    }\n\n    if (forRemoteTrack.enabled === enabled) {\n      HMSLogger.w(this.TAG, `Aborting change track state, track already has enabled - ${enabled}`, forRemoteTrack);\n      return;\n    }\n\n    if (!this.store.getTrackById(forRemoteTrack.trackId)) {\n      throw ErrorFactory.GenericErrors.ValidationFailed('No track found for change track state', forRemoteTrack);\n    }\n\n    const peer = this.store.getPeerByTrackId(forRemoteTrack.trackId);\n\n    if (!peer) {\n      throw ErrorFactory.GenericErrors.ValidationFailed('No peer found for change track state', forRemoteTrack);\n    }\n\n    await this.transport?.changeTrackState({\n      requested_for: peer.peerId,\n      track_id: forRemoteTrack.trackId,\n      stream_id: forRemoteTrack.stream.id,\n      mute: !enabled,\n    });\n  }\n\n  async changeMultiTrackState(params: HMSChangeMultiTrackStateParams) {\n    if (typeof params.enabled !== 'boolean') {\n      throw ErrorFactory.GenericErrors.ValidationFailed('Pass a boolean for enabled');\n    }\n    const { enabled, roles, type, source } = params;\n    await this.transport?.changeMultiTrackState({\n      value: !enabled,\n      type,\n      source,\n      roles: roles?.map((role) => role?.name),\n    });\n  }\n\n  private async publish(initialSettings: InitialSettings) {\n    const tracks = await this.localTrackManager.getTracksToPublish(initialSettings);\n    await this.setAndPublishTracks(tracks);\n    this.sdkState.published = true;\n  }\n\n  private async setAndPublishTracks(tracks: HMSLocalTrack[]) {\n    for (const track of tracks) {\n      await this.transport.publish([track]);\n      this.setLocalPeerTrack(track);\n      this.listener?.onTrackUpdate(HMSTrackUpdate.TRACK_ADDED, track, this.localPeer!);\n    }\n    await this.initDeviceManagers();\n  }\n\n  private setLocalPeerTrack(track: HMSLocalTrack) {\n    track.peerId = this.localPeer?.peerId;\n    switch (track.type) {\n      case HMSTrackType.AUDIO:\n        this.localPeer!.audioTrack = track as HMSLocalAudioTrack;\n        break;\n\n      case HMSTrackType.VIDEO:\n        this.localPeer!.videoTrack = track as HMSLocalVideoTrack;\n        break;\n    }\n  }\n\n  private async initDeviceManagers() {\n    // No need to initialise and add listeners if already initialised in preview\n    if (this.sdkState.deviceManagersInitialised) {\n      return;\n    }\n    this.sdkState.deviceManagersInitialised = true;\n    this.deviceManager.addEventListener('audio-device-change', this.handleDeviceChangeError);\n    this.deviceManager.addEventListener('video-device-change', this.handleDeviceChangeError);\n    await this.deviceManager.init();\n    this.deviceManager.updateOutputDevice(DeviceStorageManager.getSelection()?.audioOutput?.deviceId);\n    this.audioSinkManager.init(this.store.getConfig()?.audioSinkElementId);\n  }\n\n  private cleanDeviceManagers() {\n    this.deviceManager.removeEventListener('audio-device-change', this.handleDeviceChangeError);\n    this.deviceManager.removeEventListener('video-device-change', this.handleDeviceChangeError);\n    this.deviceManager.cleanUp();\n    this.audioSinkManager.removeEventListener(AutoplayError, this.handleAutoplayError);\n    this.audioSinkManager.cleanUp();\n  }\n\n  private initPreviewTrackAudioLevelMonitor() {\n    this.localPeer?.audioTrack?.initAudioLevelMonitor();\n    this.localPeer?.audioTrack?.audioLevelMonitor?.on('AUDIO_LEVEL_UPDATE', (audioLevelUpdate) => {\n      const hmsSpeakers = audioLevelUpdate\n        ? [{ audioLevel: audioLevelUpdate.audioLevel, peer: this.localPeer!, track: this.localPeer?.audioTrack! }]\n        : [];\n      this.store.updateSpeakers(hmsSpeakers);\n      this.audioListener?.onAudioLevelUpdate(hmsSpeakers);\n    });\n  }\n\n  private get publishParams() {\n    return this.store?.getPublishParams();\n  }\n\n  private notifyJoin() {\n    const localPeer = this.store.getLocalPeer();\n\n    if (localPeer?.role) {\n      this.listener?.onJoin(this.store.getRoom());\n    } else {\n      this.notificationManager.once('policy-change', () => {\n        this.listener?.onJoin(this.store.getRoom());\n      });\n    }\n  }\n}\n","import { BuildGetMediaError, HMSGetMediaActions } from '../error/utils';\n\nexport async function getLocalStream(constraints: MediaStreamConstraints): Promise<MediaStream> {\n  try {\n    const stream = await navigator.mediaDevices.getUserMedia(constraints);\n    return stream;\n  } catch (err) {\n    throw BuildGetMediaError(err, HMSGetMediaActions.AV);\n  }\n}\n\nexport async function getLocalScreen(constraints: MediaStreamConstraints['video']): Promise<MediaStream> {\n  try {\n    // @ts-ignore [https://github.com/microsoft/TypeScript/issues/33232]\n    const stream = await navigator.mediaDevices.getDisplayMedia({ video: constraints, audio: false });\n    return stream;\n  } catch (err) {\n    throw BuildGetMediaError(err, HMSGetMediaActions.SCREEN);\n  }\n}\n\ninterface MediaDeviceGroups {\n  audioinput: MediaDeviceInfo[];\n  audiooutput: MediaDeviceInfo[];\n  videoinput: MediaDeviceInfo[];\n}\n\nexport async function getLocalDevices(): Promise<MediaDeviceGroups> {\n  try {\n    const devices = await navigator.mediaDevices.enumerateDevices();\n    const deviceGroups: MediaDeviceGroups = {\n      audioinput: [],\n      audiooutput: [],\n      videoinput: [],\n    };\n    devices.forEach((device) => deviceGroups[device.kind].push(device));\n    return deviceGroups;\n  } catch (err) {\n    throw BuildGetMediaError(err, HMSGetMediaActions.AV);\n  }\n}\n","import { HMSAction } from '../error/ErrorFactory';\nimport { HMSException } from '../error/HMSException';\nimport { HMSAudioTrackSettingsBuilder } from '../media/settings/HMSAudioTrackSettings';\nimport { HMSVideoTrackSettingsBuilder } from '../media/settings/HMSVideoTrackSettings';\nimport { getLocalStream } from './media';\nimport { getAudioTrack, getVideoTrack } from './track';\n\n// Errors out when there's any device error, returns false when there are no device errors.\nexport async function validateDeviceAV() {\n  const videoTrackSettings = new HMSVideoTrackSettingsBuilder().build();\n  const audioTrackSettings = new HMSAudioTrackSettingsBuilder().build();\n  /**\n   * Check audio failure.\n   * If audio failure - check AV failure.\n   * If AV failure - throw AV failure.\n   * If AV passed - throw audio failure.\n   *\n   * If audio passed - check video failure.\n   * If video failure - throw video failure.\n   * If video passed - no error - return false.\n   */\n  try {\n    const track = await getAudioTrack(audioTrackSettings);\n    track.stop();\n  } catch (audioError) {\n    if (isHMSDeviceError(audioError)) {\n      const stream = await getLocalStream({ audio: false, video: true });\n      stream.getTracks().forEach((track) => track.stop());\n      throw audioError;\n    }\n  }\n\n  const track = await getVideoTrack(videoTrackSettings);\n  track.stop();\n  return false;\n}\n\nfunction isHMSDeviceError(error: any) {\n  return error instanceof HMSException && error.action === HMSAction.TRACK;\n}\n","import adapter from 'webrtc-adapter';\n\nconsole.log(`%c ${adapter.browserDetails.browser} v${adapter.browserDetails.version}`, 'color: #2F80FF');\n\nexport * from './sdk';\nexport * from './media/tracks';\nexport * from './utils/media';\nexport * from './utils/device-error';\nexport * from './utils/support';\nexport * from './error/HMSException';\nexport * from './interfaces';\nexport * from './plugins';\nexport * from './utils/logger';\n"],"names":["HMSConnectionRole","HMSLogLevel","runtime","exports","Op","Object","prototype","hasOwn","hasOwnProperty","$Symbol","Symbol","iteratorSymbol","iterator","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","toStringTag","define","obj","key","value","defineProperty","enumerable","configurable","writable","err","wrap","innerFn","outerFn","self","tryLocsList","generator","create","Generator","context","Context","_invoke","state","method","arg","Error","undefined","done","delegate","delegateResult","maybeInvokeDelegate","ContinueSentinel","sent","_sent","dispatchException","abrupt","record","tryCatch","type","makeInvokeMethod","fn","call","GeneratorFunction","GeneratorFunctionPrototype","IteratorPrototype","this","getProto","getPrototypeOf","NativeIteratorPrototype","values","Gp","defineIteratorMethods","forEach","AsyncIterator","PromiseImpl","previousPromise","callInvokeWithMethodAndArg","resolve","reject","invoke","result","__await","then","unwrapped","error","TypeError","info","resultName","next","nextLoc","pushTryEntry","locs","entry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","push","resetTryEntry","completion","reset","iterable","iteratorMethod","isNaN","length","i","doneResult","displayName","isGeneratorFunction","genFun","ctor","constructor","name","mark","setPrototypeOf","__proto__","awrap","async","Promise","iter","keys","object","reverse","pop","skipTempReset","prev","charAt","slice","stop","rootRecord","rval","exception","handle","loc","caught","hasCatch","hasFinally","finallyEntry","complete","finish","catch","thrown","delegateYield","module","regeneratorRuntime","accidentalStrictMode","globalThis","Function","HMSLogger","v","tag","data","log","VERBOSE","d","DEBUG","INFO","w","WARN","e","ERROR","time","TIME","timeEnd","TIMEEND","cleanUp","performance","clearMarks","clearMeasures","level","valueOf","console","debug","warn","measure","duration","fixMsid","desc","tracks","parsedSdp","sdpTransform","sdp","origin","_parsedSdp$origin","username","startsWith","mediaTracks","Array","from","media","m","streamId","msid","_m$msid","split","trackId","find","val","stream_id","_mediaTracks$find","track_id","_m$msid2","replace","HMSAction","ErrorCodes","WebSocketConnectionErrors","GENERIC_CONNECT","WEBSOCKET_CONNECTION_LOST","InitAPIErrors","SERVER_ERRORS","CONNECTION_LOST","HTTP_ERROR","INVALID_ENDPOINT_URL","ENDPOINT_UNREACHABLE","INVALID_TOKEN_FORMAT","TracksErrors","GENERIC_TRACK","CANT_ACCESS_CAPTURE_DEVICE","DEVICE_NOT_AVAILABLE","DEVICE_IN_USE","DEVICE_LOST_MIDWAY","NOTHING_TO_RETURN","INVALID_VIDEO_SETTINGS","CODEC_CHANGE_NOT_PERMITTED","AUTOPLAY_ERROR","WebrtcErrors","CREATE_OFFER_FAILED","CREATE_ANSWER_FAILED","SET_LOCAL_DESCRIPTION_FAILED","SET_REMOTE_DESCRIPTION_FAILED","ICE_FAILURE","WebsocketMethodErrors","ALREADY_JOINED","CANNOT_JOIN_PREVIEW_IN_PROGRESS","GenericErrors","NOT_CONNECTED","SIGNALLING","UNKNOWN","NOT_READY","JSON_PARSING_FAILED","TRACK_METADATA_MISSING","RTC_TRACK_MISSING","PEER_METADATA_MISSING","INVALID_ROLE","PlaylistErrors","NO_ENTRY_TO_PLAY","NO_ENTRY_IS_PLAYING","HMSException","code","action","message","description","isTerminal","toString","toAnalyticsProperties","error_name","error_code","error_message","error_description","is_terminal","addNativeError","nativeError","HMSRoomUpdate","HMSPeerUpdate","HMSTrackUpdate","HMSRoomType","HMSSimulcastLayer","ErrorFactory","deviceInfo","entity","VALIDATION","JSON","stringify","TAG","HMSConnection","role","signal","addTransceiver","track","init","nativeConnection","createOffer","options","offer","includes","_context","createAnswer","answer","_context2","setLocalDescription","_context3","setRemoteDescription","_context4","addIceCandidate","candidate","getSenders","removeTrack","sender","setMaxBitrate","maxBitrate","s","id","getTrackIDBeingSent","params","getParameters","encodings","setParameters","getStats","reports","stat","close","iceConnectionState","connectionState","Publish","PUBLISH","SUBSCRIBE","remoteDescription","HMSPublishConnection","config","observer","transport","RTCPeerConnection","createDataChannel","protocol","onicecandidate","trickle","_this","oniceconnectionstatechange","onIceConnectionChange","onconnectionstatechange","onConnectionStateChange","initAfterJoin","onnegotiationneeded","_this2","onRenegotiationNeeded","trackUpdate","HMSMediaStream","nativeStream","HMSVideoCodec","HMSPlaylistType","simulcastMapping","f","HIGH","h","MEDIUM","q","LOW","HMSAudioCodec","HMSTrackType","HMSRemoteStream","connection","NONE","setAudio","enabled","audio","syncWithApiChannel","setVideo","layer","video","getSimulcastLayer","isAudioSubscribed","sendOverApiDataChannel","framerate","frameRate","HMSDataChannel","nativeChannel","metadata","onmessage","onMessage","send","label","readyState","HMSTrack","stream","source","nativeTrack","getMediaTrackSettings","getSettings","setEnabled","setSdpTrackId","sdpTrackId","setFirstTrackId","firstTrackId","cleanup","HMSAudioTrack","AUDIO","kind","getVolume","audioElement","volume","setVolume","subscribeToAudio","setAudioElement","element","getAudioElement","getOutputDevice","outputDevice","srcObject","remove","setOutputDevice","device","setSinkId","_this$audioElement","deviceId","removeSink","window","HMS","_window$HMS","AUDIO_SINK","addSink","_window$HMS2","MediaStream","getAudioTracks","_srcObject$getAudioTr","HMSRemoteAudioTrack","HMSVideoTrack","VIDEO","hasSinks","sinkCount","videoElement","addSinkInternal","getVideoTracks","_srcObject$getVideoTr","HMSRemoteVideoTrack","_degraded","preferLayer","updateLayer","getSimulcastDefinitions","_layerDefinitions","setSimulcastDefinitons","definitions","setDegraded","newLayer","degraded","HMSSubscribeConnection","Subscribe","Map","pendingMessageQueue","msg","initNativeConnectionCallbacks","ondatachannel","channel","apiChannel","onApiChannelMessage","onopen","handlePendingApiMessages","ontrack","streams","remoteStreams","has","remote","set","onremovetrack","toRemoveTrackIdx","findIndex","onTrackRemove","splice","get","mid","trackSection","parseInt","_trackSection$msid","getSdpTrackIdForMid","transceiver","_e$transceiver","onTrackAdd","parsedUserAgent","UAParser","isNode","process","versions","node","isBrowser","isSupported","checkIsSupported","createUserAgent","getDevice","browser","getBrowser","os","getOS","version","vendor","HMSSignalMethod","isMobile","userAgent","InitService","fetchInitConfig","token","initEndpoint","region","url","getUrl","fetch","headers","Authorization","response","json","body","status","statusText","INIT","_response2","transformInitConfig","endpoint","URL","trim","searchParams","rtcConfiguration","iceServers","ice_servers","convertSignalMethodtoErrorAction","JOIN","OFFER","ANSWER","TRACK_UPDATE","TRACK","HMSGetMediaActions","blankCanvas","JsonRpcSignal","addEventListener","isConnected","onCloseHandler","bind","onMessageHandler","uuid","socket","jsonrpc","callbacks","Number","notify","open","uri","_this3","removeEventListener","WebSocket","errorListener","openHandler","pingPongLoop","p","_this4","join","disableVidAutoSub","isJoinCompleted","pendingTrickle","_this5","target","TRICKLE","fromEntries","broadcast","BROADCAST","toSignalParams","recordStart","recordEnd","leave","LEAVE","endRoom","lock","reason","END_ROOM","sendEvent","event","ANALYTICS","ping","timeout","pingTime","Date","now","timer","setTimeout","pongTimeDiff","PING","timestamp","race","requestRoleChange","ROLE_CHANGE_REQUEST","acceptRoleChangeRequest","ROLE_CHANGE","requestTrackStateChange","TRACK_UPDATE_REQUEST","requestMultiTrackStateChange","CHANGE_TRACK_MUTE_STATE_REQUEST","removePeer","PEER_LEAVE_REQUEST","startRTMPOrRecording","START_RTMP_OR_RECORDING_REQUEST","stopRTMPAndRecording","STOP_RTMP_AND_RECORDING_REQUEST","parse","typedResponse","cb","onNotification","onOffer","onTrickle","SERVER_ERROR","onServerError","pingTimeout","_this6","_isConnected","newValue","old","onOffline","onOnline","HMSAudioTrackSettingsBuilder","OPUS","googEchoCancellation","exact","googExperimentalEchoCancellation","autoGainControl","noiseSuppression","googHighpassFilter","googAudioMirroring","_volume","codec","_codec","_maxBitrate","_deviceId","advanced","_advanced","build","HMSAudioTrackSettings","toConstraints","audio_bitrate","audio_codec","HMSVideoTrackSettingsBuilder","VP8","setWidth","width","_width","setHeight","height","_height","maxFramerate","_maxFramerate","useDefault","HMSVideoTrackSettings","video_bitrate","video_codec","HMSTrackSettingsBuilder","_video","_audio","screen","_screen","simulcast","_simulcast","HMSTrackSettings","properties","audio_enabled","video_enabled","BuildGetMediaError","toLowerCase","adapter","browserDetails","convertMediaErrorToHMSException","getAudioTrack","settings","navigator","mediaDevices","getUserMedia","getVideoTrack","isEmptyTrack","getEmptyVideoTrack","prevTrack","assign","document","createElement","getContext","fillRect","emptyTrack","captureStream","intervalID","setInterval","ctx","pixel","getImageData","fillStyle","clearInterval","onended","getEmptyAudioTrack","AudioContext","oscillator","createOscillator","dst","connect","createMediaStreamDestination","start","HMSAudioPluginType","DomainCategory","TypedEventEmitter","on","eventName","off","emit","listeners","EventEmitter","TrackAudioLevelMonitor","input","inputBuffer","getChannelData","sum","rms","Math","sqrt","rawLevel","max","averaging","audioContext","audioSource","createMediaStreamSource","processor","createScriptProcessor","processVolume","destination","updateAudioLevel","audioLevel","ceil","min","interval","getDomainCategory","baseurl","location","hostname","LOCAL","CUSTOM","HMSAnalyticsLevel","AnalyticsEventLevel","domainCategory","AnalyticsEvent","includesPII","getTime","domain","MediaPluginsAnalyticsFactory","failure","pluginName","plugin_name","audioPluginStats","load_time","loadTime","stats","avg_preprocessing_time","avgPreProcessingTime","avg_processing_time","avgProcessingTime","input_frame_rate","inputFrameRate","plugin_frame_rate","pluginFrameRate","analyticsEventsService","addTransport","transports","removeTransport","indexOf","queue","pendingEvents","bufferSize","removedEvent","shift","flush","AudioPluginsAnalytics","initTime","addedTimestamps","pluginAdded","added","removed","floor","clean","initWithTime","initFn","timeInMs","AUDIO_PLUGINS","HMSAudioPluginsManager","hmsTrack","plugins","pluginsMap","analytics","getPlugins","addPlugin","plugin","pluginAddInProgress","getName","addPluginInternal","startPluginsProcess","removePlugin","removePluginEntry","stopPluginsProcess","intermediateNode","disconnect","index","outputTrack","initElementsAndStream","sourceNode","audioStream","destinationNode","setProcessedTrack","processAudioThroughPlugins","processAudioTrack","LocalStorage","getStorage","storage","localStorage","stringItem","_this$getStorage","getItem","stringValue","setItem","clear","removeItem","DeviceStorageManager","setDevices","devices","rememberDevices","remember","updateSelection","groupId","newSelection","isSame","selectedDevices","getSelection","current","generateHasPropertyChanged","newSettings","oldSettings","prop","HMSVideoPluginType","HMSLocalAudioTrack","pluginsManager","publishedTrackId","replaceTrackWith","prevState","newTrack","localStream","replaceSenderTrack","processedTrack","replaceStreamTrack","setSettings","internal","hasPropertyChanged","isLevelMonitored","Boolean","audioLevelMonitor","eventListeners","_this$audioLevelMonit","destroyAudioLevelMonitor","initAudioLevelMonitor","applyConstraints","listener","_this2$audioLevelMoni","sleep","ms","RunningAverage","add","item","count","total","getAvg","VideoPluginsAnalytics","preProcessingAvgs","processingAvgs","pluginInputFrameRate","_this$processingAvgs$","VIDEO_PLUGINS","preProcessWithTime","preProcessFn","processWithTime","processFn","HMSVideoPluginsManager","pluginNumFramesToSkip","pluginNumFramesSkipped","numFramesToSkip","startPluginsLoop","stopPluginsLoop","waitForRestart","pluginsLoopRunning","pluginsLoopState","inputCanvas","outputCanvas","inputVideo","outputStream","pluginsLoop","resetCanvases","sleepTimeMs","processingTime","doPreProcessing","processFramesThroughPlugins","addTrackToVideo","updateInputCanvas","skipProcessing","checkIfSkipRequired","getPluginType","TRANSFORM","processVideoFrame","ANALYZE","pause","muted","play","drawImage","outputCtx","inputCtx","skip","HMSNotificationMethod","HMSLocalVideoTrack","replaceTrackWithBlank","HMSLocalStream","setConnection","getLocalScreen","videosettings","audioSettings","audioConstraints","constraints","googAutoGainControl","echoCancellation","getDisplayMedia","SCREEN","local","nativeVideoTrack","videoTrack","nativeAudioTrack","audioTrack","getLocalTracks","getEmptyLocalTracks","fetchTrackOptions","getNativeLocalTracks","nativeTracks","simulcastLayers","trackEncodings","active","direction","sendEncodings","setPreferredCodec","_this$connection","replaceTrack","withTrack","addTrack","_this$connection2","removeSender","removedSenderCount","toRemoveLocalTrackIdx","ActiveSpeakerManager","store","audioListener","handleActiveSpeakers","speakerList","speakers","hmsSpeakers","map","speaker","peer","getPeerById","peer_id","getTrackById","onAudioLevelUpdate","updateSpeakers","dominantSpeaker","dominantSpeakerPeer","onPeerUpdate","BECAME_DOMINANT_SPEAKER","RESIGNED_DOMINANT_SPEAKER","Message","recipientPeer","recipientRoles","roles","_this$recipientRoles","_this$recipientPeer","peerId","sendParams","HMSPeer","isLocal","customerUserId","customerDescription","updateRole","newRole","HMSIdFactory","uuidv4","TransportState","HMSLocalPeer","peerData","makePeerId","HMSRemotePeer","BroadcastManager","handleBroadcast","messageNotification","notifPeer","notifMessage","notifRoles","user_id","knownRoles","getKnownRoles","getLocalPeer","hmsMessage","onMessageReceived","PeerListManager","peerManager","trackManager","peerList","peers","handlePeerList","currentPeerList","getRemotePeers","peersToRemove","filter","hmsPeer","peerNotification","handlePeerLeave","newPeerNotification","oldPeer","newPeerTrackStates","getPeerTracks","removePeerTrack","onTrackUpdate","TRACK_REMOVED","trackData","setTrackState","trackInfo","handleTrackUpdate","handlePeerJoin","trackIndex","auxiliaryTracks","PeerManager","hmsPeers","makePeer","PEER_LIST","processPendingTracks","PEER_JOINED","getPeers","PEER_LEFT","handlePeerUpdate","notification","getPolicyForRole","ROLE_UPDATED","addPeer","PolicyChangeManager","eventEmitter","handlePolicyChange","localPeer","known_roles","setKnownRoles","publishParams","_params$known_roles$p","setPublishParams","screenSimulcastLayers","setVideoSimulcastLayers","videoSimulcastLayers","setScreenshareSimulcastLayers","oldRole","detail","RequestManager","handleRoleChangeRequest","request","requestedBy","requested_by","onRoleChangeRequest","handleTrackUpdateRequest","trackUpdateRequest","mute","getLocalPeerTracks","sendNotification","onChangeTrackStateRequest","handleChangeTrackStateRequest","tracksToBeUpdated","onChangeMultiTrackStateRequest","promises","all","RoomUpdateManager","onPeerList","room","recording","streaming","getRoom","getDefaultRecordingState","rtmp","running","server","sfu","beam","onRoomUpdate","RECORDING_STATE_UPDATED","onRTMPStart","setRTMPStatus","onRTMPStop","onRecordingStart","setRecordingStatus","onRecordingStop","SERVER_RECORDING_STATE_UPDATED","BROWSER_RECORDING_STATE_UPDATED","RTMP_STREAMING_STATE_UPDATED","TrackManager","tracksToProcess","trackStateEntry","getTrackState","removeAuxiliaryTrack","auxiliaryTrackIndex","currentTrackStateInfo","_this$store$getTrackS","trackEntry","TRACK_MUTED","TRACK_UNMUTED","TRACK_DESCRIPTION_CHANGED","handleTrackMetadataAdd","remoteTrack","simulcastDefinitions","getSimulcastDefinitionsForPeer","_this2$listener","TRACK_ADDED","NotificationManager","handleTrackAdd","handleTrackRemove","peerListManager","broadcastManager","policyChangeManager","requestManager","activeSpeakerManager","roomUpdateManager","setListener","setAudioListener","addListener","removeListener","once","handleNotification","isReconnecting","ACTIVE_SPEAKERS","PEER_JOIN","PEER_LEAVE","handleReconnectPeerList","handleInitialPeerList","TRACK_METADATA_ADD","POLICY_CHANGE","CHANGE_TRACK_MUTE_STATE_UPDATE","PEER_UPDATE","RTMP_START","RTMP_STOP","RECORDING_START","RECORDING_STOP","TrackState","AnalyticsEventFactory","requestedAt","respondedAt","eventNameFor","getPropertiesWithError","KEY_REQUESTED_AT","_requestedAt","KEY_RESPONDED_AT","_respondedAt","publish","subscribeFail","deviceChange","selection","rtcStats","ok","initialProperties","TransportFailureCategory","JoinParameters","authToken","peerName","autoSubscribeVideo","Dependencies","ConnectFailed","SignalDisconnect","PublishIceConnectionFailed","SubscribeIceConnectionFailed","PromiseWithCallbacks","promise","RetryScheduler","onStateChange","schedule","category","task","maxFailedRetries","changeState","scheduleTask","retryTaskIds","future","clearTimeout","inProgress","failedRetryCount","TFC","inProgressTask","taskPromise","_","__","hasFailedDependency","dependencies","TFCDependencies","dependency","dependencyTask","dep","Failed","Reconnecting","delay","getDelayForRetryCount","setTimeoutPromise","taskSucceeded","size","Joined","n","pow","jitter","random","round","timeoutId","AnalyticsTransport","sendSingleEvent","flushFailedEvents","failedEvents","dequeue","transportProvider","enqueue","LocalStorageEvents","initLocalStorageQueue","eventInstance","capacity","Infinity","SignalAnalyticsTransport","RTCStatsMonitor","connections","isMonitored","startLoop","handleConnectionsStats","totalPacketsLost","availableIncomingBitrate","availableOutgoingBitrate","conn","packetsLost","TrackDegradationController","storeParams","getSubscribeDegradationParams","PACKETS_LOST_THRESHOLD","packetLossThreshold","MIN_DEGRADE_GRACE_PERIOD","degradeGracePeriodSeconds","MIN_RECOVER_GRACE_PERIOD","recoverGracePeriodSeconds","degradeGracePeriod","recoverGracePeriod","handleRtcStatsChange","shouldDegrade","degrade","recover","isAttemptingRecover","cancelRecovery","degradeActiveTracksByHalf","recoveringTrack","getActiveTracks","activeTracks","halfCount","includeDegraded","getRemoteVideoTracks","sort","trackA","trackB","comparators","getComparator","getTrackComparators","screenShare","rolePriority","peerAudioLevel","stringComparator","recoverAttemptCount","getDelayForRecoverCount","MAX_RECOVER_GRACE_PERIOD","HMSTransport","deviceManager","Disconnected","jsep","subscribeConnection","candidates","ex","publishConnection","onFailure","joinParameters","retryScheduler","retrySignalDisconnectTask","Leaving","RECONNECT_SIGNAL","analyticsSignalTransport","signalObserver","performPublishRenegotiation","newState","handleIceConnectionFailure","callback","RESTART_ICE","extra","iceRestart","signalConnected","internalConnect","retryPublishIceFailedTask","trackStates","videoSettings","_context14","getDevices","_context15","_context16","customData","Connecting","metaData","joinRequestedAt","initConfig","connectionJoin","_context17","_context19","subscribeConnStatsMonitor","removeAllListeners","trackDegradationController","_this$publishConnecti","_this$subscribeConnec","_context20","publishTrack","_context21","unpublish","unpublishTrack","sendMessage","originalTrackState","trackState","newTrackState","changeRole","forPeer","toRole","force","requested_for","acceptRoleChange","rtmpURLs","_params$rtmpURLs","meeting_url","meetingURL","rtmp_urls","stopRTMPOrRecording","changeTrackState","changeMultiTrackState","getSimulcastLayers","currentTrackStates","UNPUBLISH","offerToReceiveAudio","offerToReceiveVideo","publishConnectionObserver","subscribeConnectionObserver","initRtcStatsMonitor","_context35","retrySubscribeIceFailedTask","connectRequestedAt","openSignal","_this5$trackDegradati","onTrackDegrade","onTrackRestore","decodeJWT","parts","payloadStr","atob","payload","roomId","room_id","userId","Room","INITIAL_STATE","autoplayFailed","initialized","autoplayCheckPromise","AudioSinkManager","notificationManager","Set","_audioEl$srcObject","playAudioFor","autoPausedTracks","handleTrackAddAsync","audioEl","style","display","handleAudioPaused","audioSink","append","unpauseAudioTracks","getElementById","childElementCount","handleAudioDeviceChange","updateAudioOutputVolume","unblockAutoplay","elementId","resume","AUTOPLAY","DeviceManager","newDevice","audioOutput","updateAudioOutputDevice","audioDevice","createIdentifier","_localPeer$audioTrack","videoDevice","_localPeer$videoTrack","audioInput","videoInput","prevDevices","currentDevices","some","enumerateDevices","prevVideoInput","prevAudioInput","hasMicrophonePermission","hasWebcamPermission","videoInputChanged","computeChange","audioInputChanged","logDevices","getCurrentSelection","handleAudioInputDeviceChange","handleVideoInputDeviceChange","args","apply","getNewAudioInputDevice","newAudioTrackSettings","newVideoTrackSettings","handleDeviceChange","defaultDevice","inputDevice","prevSelection","selected","AudioOutputManager","audioSinkManager","setDevice","updateOutputDevice","Comparator","a","b","getPeerComparators","videoEnabled","peerA","peerB","primitiveComparator","_peerA$videoTrack","_peerB$videoTrack","audioEnabled","_peerA$audioTrack","_peerB$audioTrack","getSpeakers","priority","getPeerByTrackId","Store","getConfig","getPublishParams","comparator","localPeerId","getTracks","concat","getSpeakerPeers","setRoom","updatePeersPolicy","setConfig","rememberDeviceSelection","_devices$audioInput","audioInputDeviceId","_devices$audioOutput","audioOutputDeviceId","_devices$videoInput","videoDeviceId","peerTrackStates","_this$getLocalPeer","_this$getLocalPeer$ro","subscribeParams","subscribeDegradation","screenshareLayers","layers","videoLayers","getSimulcastDimensions","convertSimulcastLayers","rid","resolution","scaleResolutionDownBy","setErrorListener","onError","RoleChangeManager","removeAuxillaryTrack","isPublishing","allowed","toRemove","removeVideo","removeAudio","removeScreen","wasPublishing","removeLocalTracks","initialSettings","isAudioMuted","isVideoMuted","tracksToUnpublish","localAuxTracks","LocalTrackManager","getTracksToPublish","canPublishAudio","canPublishVideo","tracksToPublish","trackSettings","getTrackSettings","localTracks","t","screenTrack","isVideoTrackPublished","isAudioTrackPublished","audioFailure","videoFailure","getAVTracks","videoError","audioError","AV","canPublishScreen","screenSettings","bitRate","dimensions","AudioContextManager","createMediaElementSource","resumeContext","PlaylistAudioManager","src","seeked","onerror","oncanplaythrough","audioContextManager","onseeked","getElement","removeAttribute","crossOrigin","PlaylistVideoManager","paused","ended","canvasContext","canvas","_this$canvas","_this$canvas2","DEFAUL_FPS","getVideoElement","videoWidth","videoHeight","clearCanvasAndTracks","onplay","_this2$canvas","_this2$canvas2","clearRect","list","currentIndex","PlaylistManager","sdk","audioManager","videoManager","addListeners","getList","setList","playItem","seek","PLAYLIST","updatedValue","currentTime","seekTo","getCurrentTime","getCurrentIndex","getCurrentProgress","activeUrl","_list$currentIndex","isPlaying","setDuration","playNext","playPrevious","manager","removeTracks","onProgress","progress","onNewTrackStart","onPlaylistEnded","el","handleEnded","defaultSettings","published","isInitialised","isPreviewInProgress","deviceManagersInitialised","HMSSdk","sdkState","handlePeerLeaveRequest","TRACK_DEGRADED","_this$store","TRACK_RESTORED","_this$store2","transportState","onReconnected","onReconnecting","onRemovedFromRoom","roomEnded","room_end","deviceChangeListener","onDeviceChange","_this$localPeer","_this$localPeer2","initStoreAndManagers","playlistManager","handleAutoplayError","localTrackManager","getPlaylistManager","getRecordingState","_this$store$getRoom","getRTMPState","_this$store$getRoom2","preview","HMSRoom","userName","policy","policyHandler","setLocalPeerTrack","initPreviewTrackAudioLevelMonitor","initDeviceManagers","onPreview","roleChangeManager","handleLocalPeerRoleUpdate","autoVideoSubscribe","JOIN_DELAY_FIX","notifyJoin","cleanDeviceManagers","_this$transport","getAudioOutput","sendMessageInternal","sendBroadcastMessage","sendGroupMessage","sendDirectMessage","startScreenShare","onStop","audioOnly","_this$localPeer5","_this$localPeer6","_this$localPeer6$auxi","stopEndedScreenshare","_this4$localPeer","stopScreenShare","screenTracks","_this$localPeer7","_this$transport2","_this$localPeer8","setAnalyticsLevel","setLogLevel","addAudioListener","_this$transport3","acceptChangeRole","_this$transport4","_this$transport5","_this$transport6","_this$transport7","rtmpStart","recordingStart","_this$transport8","getRoles","forRemoteTrack","_this$transport9","_this$transport10","setAndPublishTracks","_this$localPeer10","handleDeviceChangeError","_DeviceStorageManager","_DeviceStorageManager2","_this$store$getConfig","audioSinkElementId","audioLevelUpdate","_this5$localPeer","onJoin","_this$store3","_this$store4","getLocalStream","deviceGroups","audioinput","audiooutput","videoinput","videoTrackSettings","audioTrackSettings","isHMSDeviceError"],"mappings":"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"}