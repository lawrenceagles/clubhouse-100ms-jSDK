'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var produce = _interopDefault(require('immer'));
var create = _interopDefault(require('zustand/vanilla'));
var shallow = _interopDefault(require('zustand/shallow'));
var sdkTypes = require('@100mslive/hms-video');
var reselect = require('reselect');
var EventEmitter = _interopDefault(require('events'));

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it) return (it = it.call(o)).next.bind(it);

  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it) o = it;
    var i = 0;
    return function () {
      if (i >= o.length) return {
        done: true
      };
      return {
        done: false,
        value: o[i++]
      };
    };
  }

  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var runtime_1 = createCommonjsModule(function (module) {
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined$1; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
    return obj[key];
  }
  try {
    // IE 8 has a broken Object.defineProperty that only works on DOM objects.
    define({}, "");
  } catch (err) {
    define = function(obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  define(IteratorPrototype, iteratorSymbol, function () {
    return this;
  });

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = GeneratorFunctionPrototype;
  define(Gp, "constructor", GeneratorFunctionPrototype);
  define(GeneratorFunctionPrototype, "constructor", GeneratorFunction);
  GeneratorFunction.displayName = define(
    GeneratorFunctionPrototype,
    toStringTagSymbol,
    "GeneratorFunction"
  );

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      define(genFun, toStringTagSymbol, "GeneratorFunction");
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
    return this;
  });
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;

    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList),
      PromiseImpl
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined$1) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined$1;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined$1;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  define(Gp, toStringTagSymbol, "Generator");

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  define(Gp, iteratorSymbol, function() {
    return this;
  });

  define(Gp, "toString", function() {
    return "[object Generator]";
  });

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined$1;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined$1, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined$1;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined$1;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined$1;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined$1;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined$1;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
   module.exports 
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, in modern engines
  // we can explicitly access globalThis. In older engines we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  if (typeof globalThis === "object") {
    globalThis.regeneratorRuntime = runtime;
  } else {
    Function("r", "regeneratorRuntime = r")(runtime);
  }
}
});

(function (HMSRoomState) {
  HMSRoomState["Disconnected"] = "Disconnected";
  HMSRoomState["Preview"] = "Preview";
  HMSRoomState["Connecting"] = "Connecting";
  HMSRoomState["Connected"] = "Connected";
  HMSRoomState["Reconnecting"] = "Reconnecting";
  HMSRoomState["Failed"] = "Failed";
})(exports.HMSRoomState || (exports.HMSRoomState = {}));

/**
 * @internal
 */

var createDefaultStoreState = function createDefaultStoreState() {
  return {
    room: {
      id: '',
      isConnected: false,
      name: '',
      peers: [],
      shareableLink: '',
      localPeer: '',
      hasWaitingRoom: false,
      roomState: exports.HMSRoomState.Disconnected,
      recording: {
        browser: {
          running: false
        },
        server: {
          running: false
        }
      },
      rtmp: {
        running: false
      }
    },
    peers: {},
    tracks: {},
    playlist: {
      audio: {
        list: {},
        selection: {
          id: '',
          hasPrevious: false,
          hasNext: false
        },
        progress: 0,
        volume: 0,
        currentTime: 0
      },
      video: {
        list: {},
        selection: {
          id: '',
          hasPrevious: false,
          hasNext: false
        },
        progress: 0,
        volume: 0,
        currentTime: 0
      }
    },
    messages: {
      byID: {},
      allIDs: []
    },
    speakers: {},
    settings: {
      audioInputDeviceId: '',
      audioOutputDeviceId: '',
      videoInputDeviceId: ''
    },
    devices: {
      audioInput: [],
      audioOutput: [],
      videoInput: []
    },
    roles: {},
    roleChangeRequests: [],
    errors: []
  };
};

/**
 * @internal
 */

(function (HMSMessageType) {
  HMSMessageType["CHAT"] = "chat";
})(exports.HMSMessageType || (exports.HMSMessageType = {}));

(function (HMSNotificationSeverity) {
  HMSNotificationSeverity["INFO"] = "info";
  HMSNotificationSeverity["ERROR"] = "error";
  HMSNotificationSeverity["CRITICAL"] = "critical";
})(exports.HMSNotificationSeverity || (exports.HMSNotificationSeverity = {}));

(function (HMSNotificationTypes) {
  HMSNotificationTypes["PEER_JOINED"] = "PEER_JOINED";
  HMSNotificationTypes["PEER_LEFT"] = "PEER_LEFT";
  HMSNotificationTypes["PEER_LIST"] = "PEER_LIST";
  HMSNotificationTypes["NEW_MESSAGE"] = "NEW_MESSAGE";
  HMSNotificationTypes["ERROR"] = "ERROR";
  HMSNotificationTypes["RECONNECTING"] = "RECONNECTING";
  HMSNotificationTypes["RECONNECTED"] = "RECONNECTED";
  HMSNotificationTypes["TRACK_ADDED"] = "TRACK_ADDED";
  HMSNotificationTypes["TRACK_REMOVED"] = "TRACK_REMOVED";
  HMSNotificationTypes["TRACK_MUTED"] = "TRACK_MUTED";
  HMSNotificationTypes["TRACK_UNMUTED"] = "TRACK_UNMUTED";
  HMSNotificationTypes["ROLE_CHANGE_REQUEST"] = "ROLE_CHANGE_REQUEST";
  HMSNotificationTypes["ROLE_UPDATED"] = "ROLE_UPDATED";
  HMSNotificationTypes["CHANGE_TRACK_STATE_REQUEST"] = "CHANGE_TRACK_STATE_REQUEST";
  HMSNotificationTypes["CHANGE_MULTI_TRACK_STATE_REQUEST"] = "CHANGE_MULTI_TRACK_STATE_REQUEST";
  HMSNotificationTypes["ROOM_ENDED"] = "ROOM_ENDED";
  HMSNotificationTypes["REMOVED_FROM_ROOM"] = "REMOVED_FROM_ROOM";
  HMSNotificationTypes["DEVICE_CHANGE_UPDATE"] = "DEVICE_CHANGE_UPDATE";
})(exports.HMSNotificationTypes || (exports.HMSNotificationTypes = {}));

(function (HMSPlaylistType) {
  HMSPlaylistType["audio"] = "audio";
  HMSPlaylistType["video"] = "video";
})(exports.HMSPlaylistType || (exports.HMSPlaylistType = {}));

/**
 * updates draftPeers with newPeers ensuring minimal reference changes
 * @remarks
 * This is mutable and impure function, it modifies the passed in data to ensure
 * minimal reference changes
 * @param draftPeers the current peers object in store, an immer draft object
 * @param newPeers the latest update which needs to be stored
 * @param newHmsTracks this will be update if required
 * @param newHmsSDkTracks this is future value of local hms tacks map
 */
var mergeNewPeersInDraft = function mergeNewPeersInDraft(draftPeers, newPeers) {
  var peerIDs = union(Object.keys(draftPeers), Object.keys(newPeers));

  for (var _iterator = _createForOfIteratorHelperLoose(peerIDs), _step; !(_step = _iterator()).done;) {
    var peerID = _step.value;
    var oldPeer = draftPeers[peerID];
    var newPeer = newPeers[peerID];

    if (isEntityUpdated(oldPeer, newPeer)) {
      if (areArraysEqual(oldPeer.auxiliaryTracks, newPeer.auxiliaryTracks)) {
        newPeer.auxiliaryTracks = oldPeer.auxiliaryTracks;
      }

      Object.assign(oldPeer, newPeer);
    } else if (isEntityRemoved(oldPeer, newPeer)) {
      delete draftPeers[peerID];
    } else if (isEntityAdded(oldPeer, newPeer)) {
      draftPeers[peerID] = newPeer;
    }
  }
};
var mergeNewTracksInDraft = function mergeNewTracksInDraft(draftTracks, newTracks) {
  var trackIDs = union(Object.keys(draftTracks), Object.keys(newTracks));

  for (var _iterator2 = _createForOfIteratorHelperLoose(trackIDs), _step2; !(_step2 = _iterator2()).done;) {
    var trackID = _step2.value;
    var oldTrack = draftTracks[trackID];
    var newTrack = newTracks[trackID];

    if (isEntityUpdated(oldTrack, newTrack)) {
      mergeTrackArrayFields(oldTrack, newTrack);
      Object.assign(oldTrack, newTrack);
    } else if (isEntityRemoved(oldTrack, newTrack)) {
      delete draftTracks[trackID];
    } else if (isEntityAdded(oldTrack, newTrack)) {
      draftTracks[trackID] = newTrack;
    }
  }
};
/**
 * array's are usually created with new reference, avoid that update if both arrays are same
 */

var mergeTrackArrayFields = function mergeTrackArrayFields(oldTrack, newTrack) {
  if (oldTrack.plugins && areArraysEqual(oldTrack.plugins, newTrack.plugins)) {
    newTrack.plugins = oldTrack.plugins;
  }

  if (oldTrack.layerDefinitions && areArraysEqual(oldTrack.layerDefinitions, newTrack.layerDefinitions)) {
    newTrack.layerDefinitions = oldTrack.layerDefinitions;
  }
};

var isEntityUpdated = function isEntityUpdated(oldItem, newItem) {
  return oldItem && newItem;
};

var isEntityRemoved = function isEntityRemoved(oldItem, newItem) {
  return oldItem && !newItem;
};

var isEntityAdded = function isEntityAdded(oldItem, newItem) {
  return !oldItem && newItem;
}; // eslint-disable-next-line complexity


var areArraysEqual = function areArraysEqual(arr1, arr2) {
  if (arr1 === arr2 || arr1.length === 0 && (arr2 == null ? void 0 : arr2.length) === 0) {
    // reference check
    return true;
  }

  if (!arr1 || !arr2 || !(arr1.length === arr2.length)) {
    return false;
  }

  for (var i = 0; i < arr1.length; i++) {
    if (arr1[i] !== arr2[i]) {
      return false;
    }
  }

  return true;
};

var union = function union(arr1, arr2) {
  var set = new Set();

  for (var _iterator3 = _createForOfIteratorHelperLoose(arr1), _step3; !(_step3 = _iterator3()).done;) {
    var elem = _step3.value;
    set.add(elem);
  }

  for (var _iterator4 = _createForOfIteratorHelperLoose(arr2), _step4; !(_step4 = _iterator4()).done;) {
    var _elem = _step4.value;
    set.add(_elem);
  }

  return Array.from(set);
};

var SDKToHMS = /*#__PURE__*/function () {
  function SDKToHMS() {}

  SDKToHMS.convertPeer = function convertPeer(sdkPeer) {
    var _sdkPeer$role, _sdkPeer$videoTrack, _sdkPeer$audioTrack;

    return {
      id: sdkPeer.peerId,
      name: sdkPeer.name,
      roleName: (_sdkPeer$role = sdkPeer.role) == null ? void 0 : _sdkPeer$role.name,
      isLocal: sdkPeer.isLocal,
      videoTrack: (_sdkPeer$videoTrack = sdkPeer.videoTrack) == null ? void 0 : _sdkPeer$videoTrack.trackId,
      audioTrack: (_sdkPeer$audioTrack = sdkPeer.audioTrack) == null ? void 0 : _sdkPeer$audioTrack.trackId,
      auxiliaryTracks: sdkPeer.auxiliaryTracks.map(function (track) {
        return track.trackId;
      }),
      customerUserId: sdkPeer.customerUserId,
      customerDescription: sdkPeer.customerDescription
    };
  };

  SDKToHMS.convertTrack = function convertTrack(sdkTrack, peerId) {
    var track = {
      id: sdkTrack.trackId,
      source: sdkTrack.source,
      type: sdkTrack.type,
      enabled: sdkTrack.enabled,
      displayEnabled: sdkTrack.enabled,
      peerId: sdkTrack.peerId || peerId
    };
    this.enrichTrack(track, sdkTrack);
    return track;
  };

  SDKToHMS.enrichTrack = function enrichTrack(track, sdkTrack) {
    var mediaSettings = sdkTrack.getMediaTrackSettings();

    if (track.source === 'screen' && track.type === 'video') {
      // @ts-ignore
      track.displaySurface = mediaSettings.displaySurface;
    }

    track.height = mediaSettings.height;
    track.width = mediaSettings.width;
    track.deviceID = mediaSettings.deviceId;

    if (sdkTrack instanceof sdkTypes.HMSRemoteAudioTrack) {
      track.volume = sdkTrack.getVolume() || 0;
    }

    SDKToHMS.enrichVideoTrack(track, sdkTrack);
    SDKToHMS.enrichPluginsDetails(track, sdkTrack);
  };

  SDKToHMS.enrichVideoTrack = function enrichVideoTrack(track, sdkTrack) {
    if (sdkTrack instanceof sdkTypes.HMSRemoteVideoTrack) {
      track.layer = sdkTrack.getSimulcastLayer();
      track.degraded = sdkTrack.degraded;

      if (!areArraysEqual(sdkTrack.getSimulcastDefinitions(), track.layerDefinitions)) {
        track.layerDefinitions = sdkTrack.getSimulcastDefinitions();
      }
    }
  };

  SDKToHMS.enrichPluginsDetails = function enrichPluginsDetails(track, sdkTrack) {
    if (sdkTrack instanceof sdkTypes.HMSLocalVideoTrack || sdkTrack instanceof sdkTypes.HMSLocalAudioTrack) {
      if (!areArraysEqual(sdkTrack.getPlugins(), track.plugins)) {
        track.plugins = sdkTrack.getPlugins();
      }
    }
  };

  SDKToHMS.convertRoom = function convertRoom(sdkRoom) {
    var _sdkRoom$localPeer$pe, _sdkRoom$localPeer, _sdkRoom$recording, _sdkRoom$recording2, _sdkRoom$rtmp;

    return {
      id: sdkRoom.id,
      name: sdkRoom.name,
      localPeer: (_sdkRoom$localPeer$pe = (_sdkRoom$localPeer = sdkRoom.localPeer) == null ? void 0 : _sdkRoom$localPeer.peerId) != null ? _sdkRoom$localPeer$pe : '',
      hasWaitingRoom: sdkRoom.hasWaitingRoom,
      shareableLink: sdkRoom.shareableLink,
      recording: {
        browser: {
          running: !!((_sdkRoom$recording = sdkRoom.recording) != null && _sdkRoom$recording.browser.running)
        },
        server: {
          running: !!((_sdkRoom$recording2 = sdkRoom.recording) != null && _sdkRoom$recording2.server.running)
        }
      },
      rtmp: {
        running: !!((_sdkRoom$rtmp = sdkRoom.rtmp) != null && _sdkRoom$rtmp.running)
      }
    };
  };

  SDKToHMS.convertMessage = function convertMessage(sdkMessage) {
    var _sdkMessage$sender$ro, _sdkMessage$recipient, _sdkMessage$recipient2;

    return {
      sender: sdkMessage.sender.peerId,
      senderName: sdkMessage.sender.name,
      senderRole: (_sdkMessage$sender$ro = sdkMessage.sender.role) == null ? void 0 : _sdkMessage$sender$ro.name,
      senderUserId: sdkMessage.sender.customerUserId,
      recipientPeer: (_sdkMessage$recipient = sdkMessage.recipientPeer) == null ? void 0 : _sdkMessage$recipient.peerId,
      recipientRoles: (_sdkMessage$recipient2 = sdkMessage.recipientRoles) == null ? void 0 : _sdkMessage$recipient2.map(function (role) {
        return role.name;
      }),
      time: sdkMessage.time,
      type: sdkMessage.type,
      message: sdkMessage.message
    };
  };

  SDKToHMS.convertRoles = function convertRoles(sdkRoles) {
    var roles = {};

    if (sdkRoles) {
      sdkRoles.forEach(function (role) {
        roles[role.name] = role;
      });
    }

    return roles;
  };

  SDKToHMS.convertRoleChangeRequest = function convertRoleChangeRequest(req) {
    return {
      requestedBy: req.requestedBy.peerId,
      roleName: req.role.name,
      token: req.token
    };
  };

  SDKToHMS.convertException = function convertException(sdkException) {
    return {
      code: sdkException.code,
      action: sdkException.action,
      name: sdkException.name,
      message: sdkException.message,
      description: sdkException.description,
      isTerminal: sdkException.isTerminal,
      nativeError: sdkException.nativeError,
      timestamp: new Date()
    };
  };

  SDKToHMS.convertDeviceChangeUpdate = function convertDeviceChangeUpdate(sdkDeviceChangeEvent) {
    var convertedData = {
      devices: sdkDeviceChangeEvent.devices,
      selection: sdkDeviceChangeEvent.selection,
      type: sdkDeviceChangeEvent.type
    };

    if (sdkDeviceChangeEvent.error) {
      convertedData.error = this.convertException(sdkDeviceChangeEvent.error);
    }

    return convertedData;
  };

  SDKToHMS.convertPlaylist = function convertPlaylist(playlistManager) {
    var audioPlaylist = this.getConvertedPlaylistType(playlistManager, exports.HMSPlaylistType.audio);
    var videoPlaylist = this.getConvertedPlaylistType(playlistManager, exports.HMSPlaylistType.video);
    return {
      audio: audioPlaylist,
      video: videoPlaylist
    };
  };

  SDKToHMS.getConvertedPlaylistType = function getConvertedPlaylistType(playlistManager, type) {
    var convertedPlaylist = {};
    var currentSelection = playlistManager.getCurrentSelection(type);
    var progress = playlistManager.getCurrentProgress(type);
    var isPlaying = playlistManager.isPlaying(type);
    var volume = playlistManager.getVolume(type);
    var list = playlistManager.getList(type);
    var currentIndex = playlistManager.getCurrentIndex(type);
    playlistManager.getList(type).forEach(function (playlistItem) {
      var isSelected = playlistItem.url === (currentSelection == null ? void 0 : currentSelection.url);
      convertedPlaylist[playlistItem.id] = _extends({}, playlistItem, {
        type: playlistItem.type,
        selected: isSelected,
        playing: isSelected && isPlaying
      });
    });
    return {
      list: convertedPlaylist,
      selection: {
        id: currentSelection == null ? void 0 : currentSelection.id,
        hasPrevious: currentIndex > 0,
        hasNext: currentIndex < list.length - 1
      },
      progress: progress,
      volume: volume,
      currentTime: playlistManager.getCurrentTime(type)
    };
  };

  SDKToHMS.convertRecordingRTMPState = function convertRecordingRTMPState(recording, rtmp) {
    var _recording$browser, _recording$server;

    return {
      recording: {
        browser: {
          running: !!(recording != null && (_recording$browser = recording.browser) != null && _recording$browser.running)
        },
        server: {
          running: !!(recording != null && (_recording$server = recording.server) != null && _recording$server.running)
        }
      },
      rtmp: {
        running: !!(rtmp != null && rtmp.running)
      }
    };
  };

  return SDKToHMS;
}();

function getPeerTracksByCondition(tracks, peer, trackCheckFn) {
  if (trackCheckFn === void 0) {
    trackCheckFn = isScreenShare;
  }

  var videoTrack = undefined;
  var audioTrack = undefined;

  if (peer) {
    for (var _iterator = _createForOfIteratorHelperLoose(peer.auxiliaryTracks), _step; !(_step = _iterator()).done;) {
      var trackID = _step.value;
      var track = tracks[trackID];

      if (trackCheckFn(track)) {
        audioTrack = isAudio(track) ? track : audioTrack;
        videoTrack = isVideo(track) ? track : videoTrack;
      }
    }
  }

  return {
    video: videoTrack,
    audio: audioTrack
  };
}
function isAudio(track) {
  return track && track.type === 'audio';
}
function isVideo(track) {
  return track && track.type === 'video';
}
function isScreenShare(track) {
  return track && track.source === 'screen';
}
function isAudioPlaylist(track) {
  return track && track.source === 'audioplaylist';
}
function isVideoPlaylist(track) {
  return track && track.source === 'videoplaylist';
}
function isDegraded(track) {
  return Boolean(track == null ? void 0 : track.degraded);
}
function isTrackEnabled(store, trackID) {
  if (trackID && store.tracks[trackID]) {
    return store.tracks[trackID].enabled;
  }

  return false;
}
/**
 * Should UI show the video track as enabled
 */

function isTrackDisplayEnabled(store, trackID) {
  if (trackID && store.tracks[trackID]) {
    return store.tracks[trackID].displayEnabled;
  }

  return false;
}

/**
 * Select the current {@link HMSRoom} object to which you are connected.
 * @param store
 */

var selectRoom = function selectRoom(store) {
  return store.room;
};
/**
 * @internal
 */

var selectPeersMap = function selectPeersMap(store) {
  return store.peers;
};
/**
 * @internal
 */

var selectMessagesMap = function selectMessagesMap(store) {
  return store.messages.byID;
};
/**
 * Select IDs of messages you've sent or received sorted chronologically.
 */

var selectMessageIDsInOrder = function selectMessageIDsInOrder(store) {
  return store.messages.allIDs;
};
/**
 * @internal
 */

var selectTracksMap = function selectTracksMap(store) {
  return store.tracks;
};
/**
 * Select your media settings
 * i.e., choosen audio input device, audio output device and video input device.
 * @param store
 */

var selectLocalMediaSettings = function selectLocalMediaSettings(store) {
  return store.settings;
};
/**
 * Select the available audio input, audio output and video input devices on your machine.
 * @param store
 * @returns An object of array of available audio input, audio output and video input devices.
 * ```
 * type DeviceMap = {
 *   audioInput: InputDeviceInfo[];
 *   audioOutput: MediaDeviceInfo[];
 *   videoInput: InputDeviceInfo[];
 * }
 * ```
 */

var selectDevices = function selectDevices(store) {
  return store.devices;
};
var selectSpeakers = function selectSpeakers(store) {
  return store.speakers;
};
/**
 * Select a boolean flag denoting whether you've joined a room.
 * NOTE: Returns true only after join, returns false during preview.
 */

var selectIsConnectedToRoom = /*#__PURE__*/reselect.createSelector([selectRoom], function (room) {
  return room && room.isConnected;
});
var selectPeerCount = /*#__PURE__*/reselect.createSelector(selectRoom, function (room) {
  return room.peers.length;
});
/**
 * Select an array of peers(remote peers and your local peer) present in the room.
 */

var selectPeers = /*#__PURE__*/reselect.createSelector([selectRoom, selectPeersMap], function (room, storePeers) {
  return room.peers.map(function (peerID) {
    return storePeers[peerID];
  });
});
/**
 * Select an array of tracks(remote peer tracks and your local tracks) present in the room.
 */

var selectTracks = /*#__PURE__*/reselect.createSelector(selectTracksMap, function (storeTracks) {
  return Object.values(storeTracks);
});
/**
 * Select the local peer object object assigned to you.
 */

var selectLocalPeer = /*#__PURE__*/reselect.createSelector(selectRoom, selectPeersMap, function (room, peers) {
  return peers[room.localPeer];
});
/**
 * Select the peer ID of your local peer.
 */

var selectLocalPeerID = /*#__PURE__*/reselect.createSelector(selectRoom, function (room) {
  return room.localPeer;
});
/**
 * Select the track ID of your local peer's primary audio track
 */

var selectLocalAudioTrackID = /*#__PURE__*/reselect.createSelector(selectLocalPeer, function (peer) {
  return peer == null ? void 0 : peer.audioTrack;
});
/**
 * Select the track ID of your local peer's primary video track
 */

var selectLocalVideoTrackID = /*#__PURE__*/reselect.createSelector(selectLocalPeer, function (peer) {
  return peer == null ? void 0 : peer.videoTrack;
});
/**
 * Select an array of track IDs of your local peer's auxiliary tracks
 */

var selectLocalAuxiliaryTrackIDs = /*#__PURE__*/reselect.createSelector(selectLocalPeer, function (peer) {
  return peer == null ? void 0 : peer.auxiliaryTracks;
});
/**
 * Select an array of track IDs of all your local peer's tracks
 */

var selectLocalTrackIDs = /*#__PURE__*/reselect.createSelector([selectLocalAudioTrackID, selectLocalVideoTrackID, selectLocalAuxiliaryTrackIDs], function (audioTrackID, videoTrackID, auxiliaryTrackIDs) {
  var trackIDs = [].concat(auxiliaryTrackIDs);
  audioTrackID && trackIDs.unshift(audioTrackID);
  videoTrackID && trackIDs.unshift(videoTrackID);
  return trackIDs;
});
/**
 * Select remote peers(other users you're connected with via the internet) present in the room.
 */

var selectRemotePeers = /*#__PURE__*/reselect.createSelector(selectPeers, function (peers) {
  return peers.filter(function (p) {
    return !p.isLocal;
  });
});
/**
 * Select the peer who's speaking the loudest at the moment
 */

var selectDominantSpeaker = /*#__PURE__*/reselect.createSelector(selectPeersMap, selectSpeakers, function (peersMap, speakers) {
  // sort in descending order by audio level
  var speakersInOrder = Object.entries(speakers).sort(function (s1, s2) {
    var _s1$, _s2$;

    var s1Level = ((_s1$ = s1[1]) == null ? void 0 : _s1$.audioLevel) || 0;
    var s2Level = ((_s2$ = s2[1]) == null ? void 0 : _s2$.audioLevel) || 0;
    return s2Level > s1Level ? 1 : -1;
  });

  if (speakersInOrder.length > 0 && speakersInOrder[0][1].audioLevel && speakersInOrder[0][1].audioLevel > 0) {
    var peerID = speakersInOrder[0][1].peerID;

    if (peerID in peersMap) {
      return peersMap[peerID];
    }
  }

  return null;
});
/**
 * Select a boolean denoting whether your local audio is unmuted
 * and the audio from your microphone is shared to remote peers
 */

var selectIsLocalAudioEnabled = function selectIsLocalAudioEnabled(store) {
  var localPeer = selectLocalPeer(store);
  return isTrackEnabled(store, localPeer == null ? void 0 : localPeer.audioTrack);
};
/**
 * Select a boolean denoting whether your local video is unmuted
 * and the video from your camera is shared to remote peers
 */

var selectIsLocalVideoEnabled = function selectIsLocalVideoEnabled(store) {
  var localPeer = selectLocalPeer(store);
  return isTrackEnabled(store, localPeer == null ? void 0 : localPeer.videoTrack);
};
/**
 * Select a boolean denoting whether you've chosen to unmute and share your local video.
 *
 * NOTE: Once you call `hmsActions.setLocalVideoEnabled(true)`to unmute your local video,
 * it takes some time to fetch your video from your video source.
 * This displayEnabled property gives immediate feedback for a more interactive UI,
 * without waiting for the video source
 */

var selectIsLocalVideoDisplayEnabled = function selectIsLocalVideoDisplayEnabled(store) {
  var localPeer = selectLocalPeer(store);
  return isTrackDisplayEnabled(store, localPeer == null ? void 0 : localPeer.videoTrack);
};
/**
 * Select a boolean denoting whether your screen is shared to remote peers in the room.
 */

var selectIsLocalScreenShared = /*#__PURE__*/reselect.createSelector(selectLocalPeer, selectTracksMap, function (localPeer, tracksMap) {
  var _getPeerTracksByCondi = getPeerTracksByCondition(tracksMap, localPeer),
      video = _getPeerTracksByCondi.video,
      audio = _getPeerTracksByCondi.audio;

  return !!(video || audio);
});
/**
 * Select the first peer who is currently sharing their screen.
 */

var selectPeerScreenSharing = /*#__PURE__*/reselect.createSelector(selectPeersMap, selectTracksMap, function (peersMap, tracksMap) {
  var screensharePeer = undefined;

  for (var peerID in peersMap) {
    var peer = peersMap[peerID];

    var _getPeerTracksByCondi2 = getPeerTracksByCondition(tracksMap, peer),
        video = _getPeerTracksByCondi2.video,
        audio = _getPeerTracksByCondi2.audio;

    if (video) {
      return peer;
    } else if (audio && !screensharePeer) {
      screensharePeer = peer;
    }
  }

  return screensharePeer;
});
/**
 * Select a boolean denoting whether someone is sharing screen in the room.
 */

var selectIsSomeoneScreenSharing = /*#__PURE__*/reselect.createSelector(selectPeerScreenSharing, function (peer) {
  return !!peer;
});
/**
 * Select the first peer who is currently sharing their audio only screen
 */

var selectPeerSharingAudio = /*#__PURE__*/reselect.createSelector(selectPeersMap, selectTracksMap, function (peersMap, tracksMap) {
  for (var peerID in peersMap) {
    var peer = peersMap[peerID];

    var _getPeerTracksByCondi3 = getPeerTracksByCondition(tracksMap, peer),
        audio = _getPeerTracksByCondi3.audio,
        video = _getPeerTracksByCondi3.video;

    if (!video && !!audio) {
      return peer;
    }
  }

  return undefined;
});
/**
 * Select an array of peers who are currently sharing their screen.
 */

var selectPeersScreenSharing = /*#__PURE__*/reselect.createSelector(selectPeersMap, selectTracksMap, function (peersMap, tracksMap) {
  var videoPeers = [];
  var audioPeers = [];

  for (var peerID in peersMap) {
    var peer = peersMap[peerID];

    var _getPeerTracksByCondi4 = getPeerTracksByCondition(tracksMap, peer),
        video = _getPeerTracksByCondi4.video,
        audio = _getPeerTracksByCondi4.audio;

    if (video) {
      videoPeers.push(peer);
    } else if (audio) {
      audioPeers.push(peer);
    }
  }

  return videoPeers.concat(audioPeers);
});
var selectPeerSharingVideoPlaylist = /*#__PURE__*/reselect.createSelector(selectPeersMap, selectTracksMap, function (peersMap, tracksMap) {
  for (var peerID in peersMap) {
    var peer = peersMap[peerID];

    var _getPeerTracksByCondi5 = getPeerTracksByCondition(tracksMap, peer, isVideoPlaylist),
        video = _getPeerTracksByCondi5.video;

    if (video) {
      return peer;
    }
  }

  return undefined;
});
/**
 * Select an array of tracks that have been degraded(receiving lower video quality/no video) due to bad network locally.
 */

var selectDegradedTracks = /*#__PURE__*/reselect.createSelector(selectTracks, function (tracks) {
  return tracks.filter(isDegraded);
});
/**
 * Select the number of messages(sent and received).
 */

var selectHMSMessagesCount = /*#__PURE__*/reselect.createSelector(selectMessageIDsInOrder, function (messageIDs) {
  return messageIDs.length;
});
/**
 * Select the number of unread messages.
 */

var selectUnreadHMSMessagesCount = /*#__PURE__*/reselect.createSelector(selectMessagesMap, function (messages) {
  return Object.values(messages).filter(function (m) {
    return !m.read;
  }).length;
});
/**
 * Select an array of messages in the room(sent and received).
 */

var selectHMSMessages = /*#__PURE__*/reselect.createSelector(selectMessageIDsInOrder, selectMessagesMap, function (msgIDs, msgMap) {
  var messages = [];
  msgIDs.forEach(function (msgId) {
    messages.push(msgMap[msgId]);
  });
  return messages;
});
/**
 * Select the current state of the room.
 */

var selectRoomState = /*#__PURE__*/reselect.createSelector([selectRoom], function (room) {
  return room && room.roomState;
});
/**
 * Select a boolean denoting whether the room is in Preview state.
 */

var selectIsInPreview = /*#__PURE__*/reselect.createSelector(selectRoomState, function (roomState) {
  return roomState === exports.HMSRoomState.Preview;
});
var selectRoomStarted = /*#__PURE__*/reselect.createSelector(selectRoom, function (room) {
  return room.roomState !== exports.HMSRoomState.Disconnected;
});
/**
 * Select available roles in the room as a map between the role name and {@link HMSRole} object.
 */

var selectRolesMap = function selectRolesMap(store) {
  return store.roles;
};
/**
 * Select an array of names of available roles in the room.
 */

var selectAvailableRoleNames = /*#__PURE__*/reselect.createSelector([selectRolesMap], function (rolesMap) {
  return Object.keys(rolesMap);
});
/**
 * Select the {@link HMSRole} object of your local peer.
 */

var selectLocalPeerRole = /*#__PURE__*/reselect.createSelector([selectLocalPeer, selectRolesMap], function (localPeer, rolesMap) {
  return localPeer != null && localPeer.roleName ? rolesMap[localPeer.roleName] : null;
});
/**
 * Select a boolean denoting whether if your local peer is allowed to subscribe to any other role.
 */

var selectIsAllowedToSubscribe = /*#__PURE__*/reselect.createSelector([selectLocalPeerRole], function (role) {
  var _role$subscribeParams;

  if (!(role != null && (_role$subscribeParams = role.subscribeParams) != null && _role$subscribeParams.subscribeToRoles)) {
    return false;
  }

  return role.subscribeParams.subscribeToRoles.length > 0;
});
/**
 * Select the permissions which determine what actions the local peer can do.
 */

var selectPermissions = /*#__PURE__*/reselect.createSelector(selectLocalPeerRole, function (role) {
  return role == null ? void 0 : role.permissions;
});
var selectRecordingState = /*#__PURE__*/reselect.createSelector(selectRoom, function (room) {
  return room.recording;
});
var selectRTMPState = /*#__PURE__*/reselect.createSelector(selectRoom, function (room) {
  return room.rtmp;
});

/**
 * @internal
 */

var selectPlaylistMap = function selectPlaylistMap(type) {
  if (type === void 0) {
    type = exports.HMSPlaylistType.audio;
  }

  return function (store) {
    return store.playlist[type].list;
  };
};

var selectPlaylistSelection = function selectPlaylistSelection(type) {
  if (type === void 0) {
    type = exports.HMSPlaylistType.audio;
  }

  return function (store) {
    return store.playlist[type].selection;
  };
};

var selectPlaylistProgress = function selectPlaylistProgress(type) {
  if (type === void 0) {
    type = exports.HMSPlaylistType.audio;
  }

  return function (store) {
    return store.playlist[type].progress;
  };
};

var selectPlaylistCurrentTime = function selectPlaylistCurrentTime(type) {
  if (type === void 0) {
    type = exports.HMSPlaylistType.audio;
  }

  return function (store) {
    return store.playlist[type].currentTime;
  };
};

var selectPlaylistVolume = function selectPlaylistVolume(type) {
  if (type === void 0) {
    type = exports.HMSPlaylistType.audio;
  }

  return function (store) {
    return store.playlist[type].volume;
  };
};
/**
 * Select an array of playlist items.
 */


var selectPlaylist = function selectPlaylist(type) {
  if (type === void 0) {
    type = exports.HMSPlaylistType.audio;
  }

  return reselect.createSelector(selectPlaylistMap(type), function (storePlaylist) {
    return Object.values(storePlaylist);
  });
};

var selectPlaylistSelectedItem = function selectPlaylistSelectedItem(type) {
  if (type === void 0) {
    type = exports.HMSPlaylistType.audio;
  }

  return reselect.createSelector(selectPlaylistMap(type), selectPlaylistSelection(type), function (storePlaylist, currentSelection) {
    if (!currentSelection.id) {
      return;
    }

    return storePlaylist[currentSelection.id];
  });
};

var selectAudioPlaylist = {
  selection: /*#__PURE__*/selectPlaylistSelection(exports.HMSPlaylistType.audio),
  progress: /*#__PURE__*/selectPlaylistProgress(exports.HMSPlaylistType.audio),
  currentTime: /*#__PURE__*/selectPlaylistCurrentTime(exports.HMSPlaylistType.audio),
  volume: /*#__PURE__*/selectPlaylistVolume(exports.HMSPlaylistType.audio),
  list: /*#__PURE__*/selectPlaylist(exports.HMSPlaylistType.audio),
  selectedItem: /*#__PURE__*/selectPlaylistSelectedItem(exports.HMSPlaylistType.audio)
};
var selectVideoPlaylist = {
  selection: /*#__PURE__*/selectPlaylistSelection(exports.HMSPlaylistType.video),
  progress: /*#__PURE__*/selectPlaylistProgress(exports.HMSPlaylistType.video),
  currentTime: /*#__PURE__*/selectPlaylistCurrentTime(exports.HMSPlaylistType.audio),
  volume: /*#__PURE__*/selectPlaylistVolume(exports.HMSPlaylistType.video),
  list: /*#__PURE__*/selectPlaylist(exports.HMSPlaylistType.video),
  selectedItem: /*#__PURE__*/selectPlaylistSelectedItem(exports.HMSPlaylistType.video)
};

var HMS_STORE_TAG = 'HMS-Store:';
var HMSLogger = /*#__PURE__*/function () {
  function HMSLogger() {}

  HMSLogger.v = function v(tag) {
    for (var _len = arguments.length, data = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      data[_key - 1] = arguments[_key];
    }

    this.log.apply(this, [sdkTypes.HMSLogLevel.VERBOSE, tag].concat(data));
  };

  HMSLogger.d = function d() {
    for (var _len2 = arguments.length, data = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      data[_key2] = arguments[_key2];
    }

    this.log.apply(this, [sdkTypes.HMSLogLevel.DEBUG].concat(data));
  };

  HMSLogger.i = function i() {
    for (var _len3 = arguments.length, data = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      data[_key3] = arguments[_key3];
    }

    this.log.apply(this, [sdkTypes.HMSLogLevel.INFO].concat(data));
  };

  HMSLogger.w = function w() {
    for (var _len4 = arguments.length, data = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      data[_key4] = arguments[_key4];
    }

    this.log.apply(this, [sdkTypes.HMSLogLevel.WARN].concat(data));
  };

  HMSLogger.e = function e() {
    for (var _len5 = arguments.length, data = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
      data[_key5] = arguments[_key5];
    }

    this.log.apply(this, [sdkTypes.HMSLogLevel.ERROR].concat(data));
  };

  HMSLogger.time = function time(mark) {
    this.log(sdkTypes.HMSLogLevel.TIME, '[HMSPerformanceTiming]', mark);
  };

  HMSLogger.timeEnd = function timeEnd(mark) {
    this.log(sdkTypes.HMSLogLevel.TIMEEND, '[HMSPerformanceTiming]', mark, mark);
  };

  HMSLogger.cleanUp = function cleanUp() {
    performance.clearMarks();
    performance.clearMeasures();
  }
  /* eslint-disable */
  ;

  HMSLogger.log = function log(level) {
    if (this.level.valueOf() > level.valueOf()) {
      return;
    }

    for (var _len6 = arguments.length, data = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {
      data[_key6 - 1] = arguments[_key6];
    }

    switch (level) {
      case sdkTypes.HMSLogLevel.VERBOSE:
        {
          var _console;

          (_console = console).log.apply(_console, [HMS_STORE_TAG].concat(data));

          break;
        }

      case sdkTypes.HMSLogLevel.DEBUG:
        {
          var _console2;

          (_console2 = console).debug.apply(_console2, [HMS_STORE_TAG].concat(data));

          break;
        }

      case sdkTypes.HMSLogLevel.INFO:
        {
          var _console3;

          (_console3 = console).info.apply(_console3, [HMS_STORE_TAG].concat(data));

          break;
        }

      case sdkTypes.HMSLogLevel.WARN:
        {
          var _console4;

          (_console4 = console).warn.apply(_console4, [HMS_STORE_TAG].concat(data));

          break;
        }

      case sdkTypes.HMSLogLevel.ERROR:
        {
          var _console5;

          (_console5 = console).error.apply(_console5, [HMS_STORE_TAG].concat(data));

          break;
        }

      case sdkTypes.HMSLogLevel.TIME:
        {
          performance.mark(data[1]);
          break;
        }

      case sdkTypes.HMSLogLevel.TIMEEND:
        {
          var tag = data[0];
          var mark = data[1];

          try {
            var entry = performance.measure(mark, mark); //@ts-ignore

            this.log(sdkTypes.HMSLogLevel.DEBUG, tag, mark, entry == null ? void 0 : entry.duration);
            performance.clearMarks(mark);
            performance.clearMeasures(mark);
          } catch (error) {
            this.log(sdkTypes.HMSLogLevel.DEBUG, tag, mark, error);
          }

          break;
        }
    }
  };

  return HMSLogger;
}();
HMSLogger.level = sdkTypes.HMSLogLevel.VERBOSE;

/**
 * takes in a normal selector which has store and id as input and curries it to make it easier to use.
 * Before: store.getState((store) => normalSelector(store, peerID))
 * After: store.getState(curriedSelector(peerID))
 */

function byIDCurry(selector) {
  return function (id) {
    return function (store) {
      return selector(store, id);
    };
  };
}

var selectPeerID = function selectPeerID(_store, peerID) {
  return peerID;
};

var selectTrackID = function selectTrackID(_store, trackID) {
  return trackID;
};

var selectRoleName = function selectRoleName(_store, roleName) {
  return roleName;
};

var selectPeerByIDBare = /*#__PURE__*/reselect.createSelector([selectPeersMap, selectPeerID], function (storePeers, peerID) {
  return peerID ? storePeers[peerID] : null;
});
var selectTrackByIDBare = /*#__PURE__*/reselect.createSelector([selectTracksMap, selectTrackID], function (storeTracks, trackID) {
  return trackID ? storeTracks[trackID] : null;
});
/**
 * Select the {@link HMSPeer} object given a peer ID.
 */

var selectPeerByID = /*#__PURE__*/byIDCurry(selectPeerByIDBare);
/**
 * Select the name of a {@link HMSPeer} given a peer ID.
 */

var selectPeerNameByID = /*#__PURE__*/byIDCurry( /*#__PURE__*/reselect.createSelector(selectPeerByIDBare, function (peer) {
  return peer == null ? void 0 : peer.name;
}));
/**
 * Select the {@link HMSTrack} object given a track ID.
 */

var selectTrackByID = /*#__PURE__*/byIDCurry(selectTrackByIDBare);
/**
 * Select the primary video track of a peer given a peer ID.
 */

var selectVideoTrackByPeerID = /*#__PURE__*/byIDCurry(function (store, peerID) {
  var peer = selectPeerByIDBare(store, peerID);

  if (peer && peer.videoTrack && peer.videoTrack !== '') {
    return store.tracks[peer.videoTrack];
  }

  return undefined;
});
/**
 * Select the primary audio track of a peer given a peer ID.
 */

var selectAudioTrackByPeerID = /*#__PURE__*/byIDCurry(function (store, peerID) {
  var peer = selectPeerByIDBare(store, peerID);

  if (peer && peer.audioTrack && peer.audioTrack !== '') {
    return store.tracks[peer.audioTrack];
  }

  return undefined;
});
/**
 * Select the camera stream of a peer given a peer ID.
 * This is the primary video track of a peer.
 */

var selectCameraStreamByPeerID = selectVideoTrackByPeerID;
/**
 * Select an array of auxiliary tracks of a peer given a peer ID.
 */

var selectAuxiliaryTracksByPeerID = /*#__PURE__*/byIDCurry(function (store, peerID) {
  var peer = selectPeerByIDBare(store, peerID);
  return (peer == null ? void 0 : peer.auxiliaryTracks.map(function (trackID) {
    return store.tracks[trackID];
  })) || [];
});

var selectSpeakerByTrackID = function selectSpeakerByTrackID(store, trackID) {
  return trackID ? store.speakers[trackID] : null;
};
/**
 * Select the audio level of a track given a track ID.
 */


var selectTrackAudioByID = /*#__PURE__*/byIDCurry( /*#__PURE__*/reselect.createSelector(selectSpeakerByTrackID, function (speaker) {
  return (speaker == null ? void 0 : speaker.audioLevel) || 0;
}));
/**
 * Select speaker object of audioTrack of a peer given a peer ID.
 */

var selectSpeakerByPeerID = function selectSpeakerByPeerID(store, peerID) {
  var peerAudioTrack = selectAudioTrackByPeerID(peerID)(store);
  return selectSpeakerByTrackID(store, peerAudioTrack == null ? void 0 : peerAudioTrack.id);
};
/**
 * Select audio level of audioTrack of a peer given a peer ID.
 */


var selectPeerAudioByID = /*#__PURE__*/byIDCurry( /*#__PURE__*/reselect.createSelector(selectSpeakerByPeerID, function (speaker) {
  return (speaker == null ? void 0 : speaker.audioLevel) || 0;
}));
/**
 * Select the first auxiliary audio track of a peer given a peer ID.
 */

var selectAuxiliaryAudioByPeerID = /*#__PURE__*/byIDCurry(function (store, peerID) {
  var peer = selectPeerByIDBare(store, peerID);

  if (peer) {
    var trackID = peer == null ? void 0 : peer.auxiliaryTracks.find(function (trackID) {
      return isAudio(store.tracks[trackID]);
    });
    return trackID ? store.tracks[trackID] : undefined;
  }

  return undefined;
});
var selectVideoPlaylistVideoTrackByPeerID = /*#__PURE__*/byIDCurry( /*#__PURE__*/reselect.createSelector(selectTracksMap, selectPeerByIDBare, function (tracks, peer) {
  var trackID = peer == null ? void 0 : peer.auxiliaryTracks.find(function (trackID) {
    var track = tracks[trackID];
    return isVideoPlaylist(track) && isVideo(track);
  });
  return trackID ? tracks[trackID] : undefined;
}));
var selectVideoPlaylistAudioTrackByPeerID = /*#__PURE__*/byIDCurry( /*#__PURE__*/reselect.createSelector(selectTracksMap, selectPeerByIDBare, function (tracks, peer) {
  var trackID = peer == null ? void 0 : peer.auxiliaryTracks.find(function (trackID) {
    var track = tracks[trackID];
    return isVideoPlaylist(track) && isAudio(track);
  });
  return trackID ? tracks[trackID] : undefined;
}));
var selectAudioPlaylistTrackByPeerID = /*#__PURE__*/byIDCurry( /*#__PURE__*/reselect.createSelector(selectTracksMap, selectPeerByIDBare, function (tracks, peer) {
  var trackID = peer == null ? void 0 : peer.auxiliaryTracks.find(function (trackID) {
    var track = tracks[trackID];
    return isAudioPlaylist(track) && isAudio(track);
  });
  return trackID ? tracks[trackID] : undefined;
}));
var selectScreenSharesByPeerId = /*#__PURE__*/byIDCurry( /*#__PURE__*/reselect.createSelector(selectTracksMap, selectPeerByIDBare, function (tracks, peer) {
  return getPeerTracksByCondition(tracks, peer);
}));
/**
 * Select the screen share video track of a peer given a peer ID.
 */

var selectScreenShareByPeerID = function selectScreenShareByPeerID(id) {
  return reselect.createSelector(selectScreenSharesByPeerId(id), function (screenshare) {
    return screenshare.video;
  });
};
/**
 * Select the screen share audio track of a peer given a peer ID.
 */

var selectScreenShareAudioByPeerID = function selectScreenShareAudioByPeerID(id) {
  return reselect.createSelector(selectScreenSharesByPeerId(id), function (screenshare) {
    return screenshare.audio;
  });
};
/**
 * Select a boolean denoting whether a peer has unmuted audio and sharing it to other peers.
 */

var selectIsPeerAudioEnabled = /*#__PURE__*/byIDCurry(function (store, peerID) {
  var peer = selectPeerByIDBare(store, peerID);
  return isTrackEnabled(store, peer == null ? void 0 : peer.audioTrack);
});
/**
 * Select a boolean denoting whether a peer has unmuted video and sharing it to other peers.
 */

var selectIsPeerVideoEnabled = /*#__PURE__*/byIDCurry(function (store, peerID) {
  var peer = selectPeerByIDBare(store, peerID);
  return isTrackEnabled(store, peer == null ? void 0 : peer.videoTrack);
});
/**
 * Select a boolean denoting whether you've muted an audio track locally(only for you) given a track ID.
 */

var selectIsAudioLocallyMuted = /*#__PURE__*/byIDCurry(function (store, trackID) {
  if (trackID && store.tracks[trackID]) {
    return store.tracks[trackID].volume === 0;
  }

  return undefined;
});
/**
 * Select a boolean denoting whether you've muted the primary audio track of a peer locally(only for you) given a peer ID.
 */

var selectIsLocallyMutedByPeerID = /*#__PURE__*/byIDCurry(function (store, peerID) {
  var peer = selectPeerByIDBare(store, peerID);
  return selectIsAudioLocallyMuted(peer == null ? void 0 : peer.audioTrack)(store);
});
/**
 * Select a boolean denoting whether you've muted the screen share audio track of a peer locally(only for you) given a peer ID.
 */

var selectIsScreenShareLocallyMutedByPeerID = /*#__PURE__*/byIDCurry(function (store, peerID) {
  var track = selectScreenShareAudioByPeerID(peerID)(store);
  return selectIsAudioLocallyMuted(track == null ? void 0 : track.id)(store);
});
/**
 * Select the local audio volume of an audio track given a track ID.
 *
 * NOTE: **Volume** of a track is different from **Audio Level** of a track,
 * - Audio Level measures the audio of a track and it comes from 100ms's servers.
 * - Volume is how loud you hear the audio of a track, this is controlled by you at the client side.
 */

var selectAudioTrackVolume = /*#__PURE__*/byIDCurry(function (store, trackID) {
  var track = selectTrackByIDBare(store, trackID);

  if (track) {
    if (track.type !== 'audio') {
      HMSLogger.w('Please pass audio track here');
      return undefined;
    }

    return track.volume;
  }

  return undefined;
});
/**
 * Select the local audio volume of the primary audio track of a peer given a peer ID.
 */

var selectAudioVolumeByPeerID = /*#__PURE__*/byIDCurry(function (store, peerID) {
  var peer = selectPeerByIDBare(store, peerID);
  return selectAudioTrackVolume(peer == null ? void 0 : peer.audioTrack)(store);
});
/**
 * Select the local audio volume of the screen share of a peer given a peer ID.
 */

var selectScreenshareAudioVolumeByPeerID = /*#__PURE__*/byIDCurry(function (store, peerID) {
  var track = selectScreenShareAudioByPeerID(peerID)(store);
  return selectAudioTrackVolume(track == null ? void 0 : track.id)(store);
});
/**
 * Select the current simulcast layer of a track given a track ID.
 */

var selectSimulcastLayerByTrack = /*#__PURE__*/byIDCurry(function (store, trackID) {
  var track = selectTrackByIDBare(store, trackID);

  if (track) {
    if (track.type !== 'video') {
      HMSLogger.w('Please pass video track here');
      return undefined;
    }

    return track.layer;
  }

  return undefined;
});
var selectMessagesByPeerIDInternal = /*#__PURE__*/reselect.createSelector([selectHMSMessages, selectLocalPeerID, selectPeerID], function (messages, localPeerID, peerID) {
  if (!peerID) {
    return undefined;
  }

  return messages.filter(function (message) {
    var _message$recipientRol;

    // Broadcast message
    if (!message.recipientPeer && !((_message$recipientRol = message.recipientRoles) != null && _message$recipientRol.length)) {
      return false;
    } // if localPeer or peerID is not a sender remove this


    if (![localPeerID, peerID].includes(message.sender)) {
      return false;
    } // at this point we know the sender is one of local or passed in peer, check the recipient side


    return [localPeerID, peerID].includes(message.recipientPeer);
  });
});
var selectMessagesByRoleInternal = /*#__PURE__*/reselect.createSelector([selectHMSMessages, selectRoleName], function (messages, roleName) {
  if (!roleName) {
    return undefined;
  }

  return messages.filter(function (message) {
    var _message$recipientRol2, _message$recipientRol3;

    // Not Role message - Broadcast message or Private Peer message
    if (!((_message$recipientRol2 = message.recipientRoles) != null && _message$recipientRol2.length)) {
      return false;
    }

    return (_message$recipientRol3 = message.recipientRoles) == null ? void 0 : _message$recipientRol3.includes(roleName);
  });
});
var selectBroadcastMessages = /*#__PURE__*/reselect.createSelector(selectHMSMessages, function (messages) {
  return messages.filter(function (message) {
    var _message$recipientRol4;

    if (!message.recipientPeer && !((_message$recipientRol4 = message.recipientRoles) != null && _message$recipientRol4.length)) {
      return true;
    }

    return false;
  });
});
var selectUnreadMessageCountByRole = /*#__PURE__*/reselect.createSelector([selectMessagesByRoleInternal, selectRoleName], function (messages) {
  if (!messages) {
    return 0;
  }

  return messages.filter(function (m) {
    return !m.read;
  }).length;
});
var selectUnreadMessageCountByPeerID = /*#__PURE__*/reselect.createSelector([selectMessagesByPeerIDInternal, selectPeerID], function (messages) {
  if (!messages) {
    return 0;
  }

  return messages.filter(function (m) {
    return !m.read;
  }).length;
});
var selectBroadcastMessagesUnreadCount = /*#__PURE__*/reselect.createSelector(selectBroadcastMessages, function (messages) {
  return messages.filter(function (m) {
    return !m.read;
  }).length;
});
var selectMessagesByPeerID = /*#__PURE__*/byIDCurry(selectMessagesByPeerIDInternal);
var selectMessagesByRole = /*#__PURE__*/byIDCurry(selectMessagesByRoleInternal);
var selectMessagesUnreadCountByRole = /*#__PURE__*/byIDCurry(selectUnreadMessageCountByRole);
var selectMessagesUnreadCountByPeerID = /*#__PURE__*/byIDCurry(selectUnreadMessageCountByPeerID);

var selectPeersWithAudioStatus = /*#__PURE__*/reselect.createSelector([selectPeersMap, selectTracksMap], function (peersMap, tracksMap) {
  var participants = Object.values(peersMap).map(function (peer) {
    var _tracksMap$peer$audio;

    return {
      peer: peer,
      isAudioEnabled: peer.audioTrack ? (_tracksMap$peer$audio = tracksMap[peer.audioTrack]) == null ? void 0 : _tracksMap$peer$audio.enabled : false
    };
  });
  return participants;
});

var selectRoleChangeStoreRequest = function selectRoleChangeStoreRequest(store) {
  return store.roleChangeRequests[0] || null;
};
/**
 * Select the role change request received for your local peer.
 */


var selectRoleChangeRequest = /*#__PURE__*/reselect.createSelector([selectRoleChangeStoreRequest, selectPeersMap, selectRolesMap], function (request, peersMap, rolesMap) {
  if (!request) {
    return null;
  }

  return {
    requestedBy: peersMap[request.requestedBy],
    role: rolesMap[request.roleName],
    token: request.token
  };
});
/**
 * Select what streams is the local peer allowed to publish from video, audio and screenshare.
 */

var selectIsAllowedToPublish = /*#__PURE__*/reselect.createSelector([selectLocalPeerRole], function (role) {
  var _role$publishParams;

  var video = false,
      audio = false,
      screen = false;

  if (role != null && (_role$publishParams = role.publishParams) != null && _role$publishParams.allowed) {
    video = role.publishParams.allowed.includes('video');
    audio = role.publishParams.allowed.includes('audio');
    screen = role.publishParams.allowed.includes('screen');
  }

  return {
    video: video,
    audio: audio,
    screen: screen
  };
});

var selectRoleByRoleName = function selectRoleByRoleName(roleName) {
  return reselect.createSelector([selectRolesMap], function (rolesMap) {
    return rolesMap[roleName];
  });
};
var selectLocalVideoPlugins = /*#__PURE__*/reselect.createSelector([selectLocalVideoTrackID, selectTracksMap], function (trackID, tracksMap) {
  var _track;

  var track = null;

  if (trackID) {
    track = tracksMap[trackID];
  }

  return ((_track = track) == null ? void 0 : _track.plugins) || [];
});
var selectLocalAudioPlugins = /*#__PURE__*/reselect.createSelector([selectLocalAudioTrackID, selectTracksMap], function (trackID, tracksMap) {
  var _track2;

  var track = null;

  if (trackID) {
    track = tracksMap[trackID];
  }

  return ((_track2 = track) == null ? void 0 : _track2.plugins) || [];
});
var selectIsLocalVideoPluginPresent = function selectIsLocalVideoPluginPresent(pluginName) {
  return reselect.createSelector([selectLocalVideoPlugins], function (plugins) {
    return plugins.includes(pluginName);
  });
};
var selectIsLocalAudioPluginPresent = function selectIsLocalAudioPluginPresent(pluginName) {
  return reselect.createSelector([selectLocalAudioPlugins], function (plugins) {
    return plugins.includes(pluginName);
  });
};

function isRemoteTrack(track) {
  return track instanceof sdkTypes.HMSRemoteAudioTrack || track instanceof sdkTypes.HMSRemoteVideoTrack;
}

var HMSPlaylist = /*#__PURE__*/function () {
  function HMSPlaylist(playlistManager, type, syncPlaylistState, store) {
    this.playlistManager = playlistManager;
    this.syncPlaylistState = syncPlaylistState;
    this.store = store;
    this.type = type;
  }

  var _proto = HMSPlaylist.prototype;

  _proto.play = /*#__PURE__*/function () {
    var _play = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(id) {
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (id) {
                _context.next = 3;
                break;
              }

              HMSLogger.w('Please pass id to play');
              return _context.abrupt("return");

            case 3:
              _context.next = 5;
              return this.playlistManager.setEnabled(true, {
                id: id,
                type: this.type
              });

            case 5:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function play(_x) {
      return _play.apply(this, arguments);
    }

    return play;
  }();

  _proto.pause = /*#__PURE__*/function () {
    var _pause = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2() {
      var selector, selection;
      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              selector = this.type === exports.HMSPlaylistType.audio ? selectAudioPlaylist : selectVideoPlaylist;
              selection = this.store.getState(selector.selection);

              if (selection.id) {
                _context2.next = 5;
                break;
              }

              HMSLogger.w('No item is currently playing to pause');
              return _context2.abrupt("return");

            case 5:
              _context2.next = 7;
              return this.playlistManager.setEnabled(false, {
                id: selection.id,
                type: this.type
              });

            case 7:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));

    function pause() {
      return _pause.apply(this, arguments);
    }

    return pause;
  }();

  _proto.playNext = /*#__PURE__*/function () {
    var _playNext = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3() {
      return runtime_1.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              _context3.next = 2;
              return this.playlistManager.playNext(this.type);

            case 2:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, this);
    }));

    function playNext() {
      return _playNext.apply(this, arguments);
    }

    return playNext;
  }();

  _proto.playPrevious = /*#__PURE__*/function () {
    var _playPrevious = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4() {
      return runtime_1.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              _context4.next = 2;
              return this.playlistManager.playPrevious(this.type);

            case 2:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4, this);
    }));

    function playPrevious() {
      return _playPrevious.apply(this, arguments);
    }

    return playPrevious;
  }();

  _proto.seek = function seek(seekValue) {
    this.playlistManager.seek(seekValue, this.type);
    this.syncPlaylistState("seekOn" + this.type + "Playlist");
  };

  _proto.seekTo = function seekTo(seekValue) {
    this.playlistManager.seekTo(seekValue, this.type);
    this.syncPlaylistState("seekToOn" + this.type + "Playlist");
  };

  _proto.setVolume = function setVolume(volume) {
    this.playlistManager.setVolume(volume, this.type);
    this.syncPlaylistState("setVolumeOn" + this.type + "Playlist");
  };

  _proto.setList = function setList(list) {
    this.playlistManager.setList(list);
    this.syncPlaylistState("setListOn" + this.type + "Playlist");
  };

  _proto.stop = /*#__PURE__*/function () {
    var _stop = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee5() {
      return runtime_1.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              _context5.next = 2;
              return this.playlistManager.stop(this.type);

            case 2:
              this.syncPlaylistState("stop" + this.type + "Playlist");

            case 3:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5, this);
    }));

    function stop() {
      return _stop.apply(this, arguments);
    }

    return stop;
  }();

  return HMSPlaylist;
}();

/**
 * This class implements the IHMSActions interface for 100ms SDK. It connects with SDK
 * and takes control of data management by letting every action pass through it. The
 * passed in store is ensured to be the single source of truth reflecting current
 * room related data at any point in time.
 *
 * @privateRemarks
 * Things to keep in mind while updating store -
 * 1. Treat setState as an atomic operation, if an action results in multiple changes,
 *    the changes should all happen within single setState function.
 * 2. While updating the state it's very important to not update the reference if
 *    something is unchanged. Copy data in same reference object don't assign new
 *    object.
 * 3. Mental Model(1) - Actions from backend -> Listeners of this class -> update store -> views update themselves
 *    eg. for this - peer added, remote muted etc.
 * 4. Mental Model(2) - Actions from local -> View calls actions -> update store -> views update themselves
 *    eg. local track enabled, join, leave etc.
 * 5. State is immutable, a new copy with new references is created when there is a change,
 *    if you try to modify state outside of setState, there'll be an error.
 */

var HMSSDKActions = /*#__PURE__*/function () {
  function HMSSDKActions(store, sdk, notificationManager) {
    var _this = this;

    this.hmsSDKTracks = {};
    this.hmsSDKPeers = {};
    this.isRoomJoinCalled = false;

    this.setProgress = function (_ref) {
      var type = _ref.type,
          progress = _ref.progress;

      _this.setState(function (draftStore) {
        draftStore.playlist[type].progress = progress;
        draftStore.playlist[type].currentTime = _this.sdk.getPlaylistManager().getCurrentTime(type);
      }, 'playlistProgress');
    };

    this.syncPlaylistState = function (action) {
      _this.setState(function (draftStore) {
        Object.assign(draftStore.playlist, SDKToHMS.convertPlaylist(_this.sdk.getPlaylistManager()));
      }, action);
    };

    this.sendPeerUpdateNotification = function (type, sdkPeer) {
      var peer = _this.store.getState(selectPeerByID(sdkPeer.peerId));

      var actionName = 'peerUpdate';

      if (type === sdkTypes.HMSPeerUpdate.PEER_JOINED) {
        actionName = 'peerJoined';
      } else if (type === sdkTypes.HMSPeerUpdate.PEER_LEFT) {
        actionName = 'peerLeft';
      }

      _this.syncRoomState(actionName); // if peer wasn't available before sync(will happen if event is peer join)


      if (!peer) {
        peer = _this.store.getState(selectPeerByID(sdkPeer.peerId));
      }

      _this.hmsNotifications.sendPeerUpdate(type, peer);
    };
    /**
     * setState is separate so any future changes to how state change can be done from one place.
     * @param fn
     * @param name
     */


    this.setState = function (fn, name) {
      return _this.store.namedSetState(fn, name);
    };

    this.store = store;
    this.sdk = sdk;
    this.hmsNotifications = notificationManager; // this.actionBatcher = new ActionBatcher(store);
  }

  var _proto = HMSSDKActions.prototype;

  _proto.unblockAudio = /*#__PURE__*/function () {
    var _unblockAudio = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee() {
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return this.sdk.getAudioOutput().unblockAutoplay();

            case 2:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function unblockAudio() {
      return _unblockAudio.apply(this, arguments);
    }

    return unblockAudio;
  }();

  _proto.setVolume = function setVolume(value, trackId) {
    if (trackId) {
      this.setTrackVolume(value, trackId);
    } else {
      this.sdk.getAudioOutput().setVolume(value);
      this.syncRoomState('setOutputVolume');
    }
  };

  _proto.setAudioOutputDevice = function setAudioOutputDevice(deviceId) {
    var deviceInfo = this.sdk.getAudioOutput().setDevice(deviceId);

    if (deviceInfo) {
      this.setState(function (draftStore) {
        draftStore.settings.audioOutputDeviceId = deviceId;
      }, 'setAudioOutputDevice');
    }
  };

  _proto.setPreferredLayer = function setPreferredLayer(trackId, layer) {
    var track = this.hmsSDKTracks[trackId];

    if (track) {
      if (track instanceof sdkTypes.HMSRemoteVideoTrack) {
        track.preferLayer(layer);
        this.updateVideoLayer(trackId, 'setPreferredLayer');
      } else {
        HMSLogger.w("track " + trackId + " is not an video track");
      }
    } else {
      this.logPossibleInconsistency("track " + trackId + " not present, unable to set preffer layer");
    }
  };

  _proto.preview = /*#__PURE__*/function () {
    var _preview = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(config) {
      var roomState;
      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (!this.isRoomJoinCalled) {
                _context2.next = 3;
                break;
              }

              this.logPossibleInconsistency('attempting to call preview after join was called');
              return _context2.abrupt("return");

            case 3:
              roomState = this.store.getState(selectRoomState);

              if (!(roomState === exports.HMSRoomState.Preview || roomState === exports.HMSRoomState.Connecting)) {
                _context2.next = 7;
                break;
              }

              this.logPossibleInconsistency('attempting to call preview while room is in preview/connecting');
              return _context2.abrupt("return");

            case 7:
              _context2.prev = 7;
              _context2.next = 10;
              return this.sdkPreviewWithListeners(config);

            case 10:
              this.setState(function (store) {
                store.room.roomState = exports.HMSRoomState.Connecting;
              }, 'preview');
              _context2.next = 17;
              break;

            case 13:
              _context2.prev = 13;
              _context2.t0 = _context2["catch"](7);
              HMSLogger.e('Cannot show preview. Failed to connect to room - ', _context2.t0);
              throw _context2.t0;

            case 17:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this, [[7, 13]]);
    }));

    function preview(_x) {
      return _preview.apply(this, arguments);
    }

    return preview;
  }();

  _proto.join = function join(config) {
    if (this.isRoomJoinCalled) {
      this.logPossibleInconsistency('room join is called again');
      return; // ignore
    }

    try {
      this.sdkJoinWithListeners(config);
      this.isRoomJoinCalled = true;
      this.setState(function (store) {
        store.room.roomState = exports.HMSRoomState.Connecting;
      }, 'join');
    } catch (err) {
      this.isRoomJoinCalled = false; // so it can be called again if needed

      HMSLogger.e('Failed to connect to room - ', err);
      throw err;
    }
  };

  _proto.leave = /*#__PURE__*/function () {
    var _leave = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3() {
      var _this2 = this;

      var hasRoomStarted;
      return runtime_1.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              hasRoomStarted = this.store.getState(selectRoomStarted);

              if (hasRoomStarted) {
                _context3.next = 4;
                break;
              }

              this.logPossibleInconsistency('room leave is called when no room is connected');
              return _context3.abrupt("return");

            case 4:
              return _context3.abrupt("return", this.sdk.leave().then(function () {
                _this2.resetState('leave');

                HMSLogger.i('left room');
              })["catch"](function (err) {
                HMSLogger.e('error in leaving room - ', err);
              }));

            case 5:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, this);
    }));

    function leave() {
      return _leave.apply(this, arguments);
    }

    return leave;
  }();

  _proto.setScreenShareEnabled = /*#__PURE__*/function () {
    var _setScreenShareEnabled = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4(enabled, audioOnly) {
      return runtime_1.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              if (!enabled) {
                _context4.next = 5;
                break;
              }

              _context4.next = 3;
              return this.startScreenShare(audioOnly);

            case 3:
              _context4.next = 7;
              break;

            case 5:
              _context4.next = 7;
              return this.stopScreenShare();

            case 7:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4, this);
    }));

    function setScreenShareEnabled(_x2, _x3) {
      return _setScreenShareEnabled.apply(this, arguments);
    }

    return setScreenShareEnabled;
  }();

  _proto.addTrack = /*#__PURE__*/function () {
    var _addTrack = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee5(track, type) {
      return runtime_1.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              if (type === void 0) {
                type = 'regular';
              }

              _context5.next = 3;
              return this.sdk.addTrack(track, type);

            case 3:
              this.syncRoomState('addTrack');

            case 4:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5, this);
    }));

    function addTrack(_x4, _x5) {
      return _addTrack.apply(this, arguments);
    }

    return addTrack;
  }();

  _proto.removeTrack = /*#__PURE__*/function () {
    var _removeTrack = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee6(trackId) {
      return runtime_1.wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              _context6.next = 2;
              return this.sdk.removeTrack(trackId);

            case 2:
              this.syncRoomState('removeTrack');

            case 3:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6, this);
    }));

    function removeTrack(_x6) {
      return _removeTrack.apply(this, arguments);
    }

    return removeTrack;
  }();

  _proto.setLocalAudioEnabled = /*#__PURE__*/function () {
    var _setLocalAudioEnabled = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee7(enabled) {
      var trackID;
      return runtime_1.wrap(function _callee7$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              trackID = this.store.getState(selectLocalAudioTrackID);

              if (!trackID) {
                _context7.next = 4;
                break;
              }

              _context7.next = 4;
              return this.setEnabledTrack(trackID, enabled);

            case 4:
            case "end":
              return _context7.stop();
          }
        }
      }, _callee7, this);
    }));

    function setLocalAudioEnabled(_x7) {
      return _setLocalAudioEnabled.apply(this, arguments);
    }

    return setLocalAudioEnabled;
  }();

  _proto.setLocalVideoEnabled = /*#__PURE__*/function () {
    var _setLocalVideoEnabled = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee8(enabled) {
      var trackID;
      return runtime_1.wrap(function _callee8$(_context8) {
        while (1) {
          switch (_context8.prev = _context8.next) {
            case 0:
              trackID = this.store.getState(selectLocalVideoTrackID);

              if (!trackID) {
                _context8.next = 4;
                break;
              }

              _context8.next = 4;
              return this.setEnabledTrack(trackID, enabled);

            case 4:
            case "end":
              return _context8.stop();
          }
        }
      }, _callee8, this);
    }));

    function setLocalVideoEnabled(_x8) {
      return _setLocalVideoEnabled.apply(this, arguments);
    }

    return setLocalVideoEnabled;
  }();

  _proto.setEnabledTrack = /*#__PURE__*/function () {
    var _setEnabledTrack = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee9(trackID, enabled) {
      var _this$store$getState$,
          _this3 = this;

      var alreadyInSameState, type;
      return runtime_1.wrap(function _callee9$(_context9) {
        while (1) {
          switch (_context9.prev = _context9.next) {
            case 0:
              // if mute/unmute is clicked multiple times for same operation, ignore repeated ones
              alreadyInSameState = ((_this$store$getState$ = this.store.getState().tracks[trackID]) == null ? void 0 : _this$store$getState$.enabled) === enabled;

              if (!alreadyInSameState) {
                _context9.next = 4;
                break;
              }

              // it could also be a case of possible inconsistency where UI state is out of sync with truth
              this.logPossibleInconsistency("local track[" + trackID + "] enabled state - " + enabled);
              return _context9.abrupt("return");

            case 4:
              this.setState(function (store) {
                // show on UI immediately
                if (!store.tracks[trackID]) {
                  _this3.logPossibleInconsistency('track id not found for setEnabled');
                } else {
                  store.tracks[trackID].displayEnabled = enabled;
                }
              }, 'displayEnabled');
              _context9.prev = 5;
              _context9.next = 8;
              return this.setEnabledSDKTrack(trackID, enabled);

            case 8:
              // do the operation
              this.syncRoomState('setEnabled');
              _context9.next = 16;
              break;

            case 11:
              _context9.prev = 11;
              _context9.t0 = _context9["catch"](5);
              // rollback on failure
              this.setState(function (store) {
                store.tracks[trackID].displayEnabled = !enabled;
              }, 'rollbackDisplayEnabled');
              this.hmsNotifications.sendError(SDKToHMS.convertException(_context9.t0));
              throw _context9.t0;

            case 16:
              type = enabled ? sdkTypes.HMSTrackUpdate.TRACK_UNMUTED : sdkTypes.HMSTrackUpdate.TRACK_MUTED;
              this.hmsNotifications.sendTrackUpdate(type, trackID);

            case 18:
            case "end":
              return _context9.stop();
          }
        }
      }, _callee9, this, [[5, 11]]);
    }));

    function setEnabledTrack(_x9, _x10) {
      return _setEnabledTrack.apply(this, arguments);
    }

    return setEnabledTrack;
  }();

  _proto.setAudioSettings = /*#__PURE__*/function () {
    var _setAudioSettings = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee10(settings) {
      var trackID;
      return runtime_1.wrap(function _callee10$(_context10) {
        while (1) {
          switch (_context10.prev = _context10.next) {
            case 0:
              trackID = this.store.getState(selectLocalAudioTrackID);

              if (!trackID) {
                _context10.next = 5;
                break;
              }

              _context10.next = 4;
              return this.setSDKLocalAudioTrackSettings(trackID, settings);

            case 4:
              this.syncRoomState('setAudioSettings');

            case 5:
            case "end":
              return _context10.stop();
          }
        }
      }, _callee10, this);
    }));

    function setAudioSettings(_x11) {
      return _setAudioSettings.apply(this, arguments);
    }

    return setAudioSettings;
  }();

  _proto.setVideoSettings = /*#__PURE__*/function () {
    var _setVideoSettings = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee11(settings) {
      var trackID;
      return runtime_1.wrap(function _callee11$(_context11) {
        while (1) {
          switch (_context11.prev = _context11.next) {
            case 0:
              trackID = this.store.getState(selectLocalVideoTrackID);

              if (!trackID) {
                _context11.next = 5;
                break;
              }

              _context11.next = 4;
              return this.setSDKLocalVideoTrackSettings(trackID, settings);

            case 4:
              this.syncRoomState('setVideoSettings');

            case 5:
            case "end":
              return _context11.stop();
          }
        }
      }, _callee11, this);
    }));

    function setVideoSettings(_x12) {
      return _setVideoSettings.apply(this, arguments);
    }

    return setVideoSettings;
  }();

  _proto.sendMessage = function sendMessage(message) {
    this.sendBroadcastMessage(message);
  };

  _proto.sendBroadcastMessage = /*#__PURE__*/function () {
    var _sendBroadcastMessage = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee12(message, type) {
      var sdkMessage;
      return runtime_1.wrap(function _callee12$(_context12) {
        while (1) {
          switch (_context12.prev = _context12.next) {
            case 0:
              _context12.next = 2;
              return this.sdk.sendBroadcastMessage(message, type);

            case 2:
              sdkMessage = _context12.sent;
              this.updateMessageInStore(sdkMessage, {
                message: message,
                type: type
              });

            case 4:
            case "end":
              return _context12.stop();
          }
        }
      }, _callee12, this);
    }));

    function sendBroadcastMessage(_x13, _x14) {
      return _sendBroadcastMessage.apply(this, arguments);
    }

    return sendBroadcastMessage;
  }();

  _proto.sendGroupMessage = /*#__PURE__*/function () {
    var _sendGroupMessage = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee13(message, roles, type) {
      var storeRoles, hmsRoles, sdkMessage;
      return runtime_1.wrap(function _callee13$(_context13) {
        while (1) {
          switch (_context13.prev = _context13.next) {
            case 0:
              storeRoles = this.store.getState(selectRolesMap);
              hmsRoles = roles.map(function (roleName) {
                return storeRoles[roleName];
              });
              _context13.next = 4;
              return this.sdk.sendGroupMessage(message, hmsRoles, type);

            case 4:
              sdkMessage = _context13.sent;
              this.updateMessageInStore(sdkMessage, {
                message: message,
                recipientRoles: roles,
                type: type
              });

            case 6:
            case "end":
              return _context13.stop();
          }
        }
      }, _callee13, this);
    }));

    function sendGroupMessage(_x15, _x16, _x17) {
      return _sendGroupMessage.apply(this, arguments);
    }

    return sendGroupMessage;
  }();

  _proto.sendDirectMessage = /*#__PURE__*/function () {
    var _sendDirectMessage = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee14(message, peerID, type) {
      var hmsPeer, sdkMessage;
      return runtime_1.wrap(function _callee14$(_context14) {
        while (1) {
          switch (_context14.prev = _context14.next) {
            case 0:
              hmsPeer = this.hmsSDKPeers[peerID];
              _context14.next = 3;
              return this.sdk.sendDirectMessage(message, hmsPeer);

            case 3:
              sdkMessage = _context14.sent;
              this.updateMessageInStore(sdkMessage, {
                message: message,
                recipientPeer: hmsPeer.peerId,
                type: type
              });

            case 5:
            case "end":
              return _context14.stop();
          }
        }
      }, _callee14, this);
    }));

    function sendDirectMessage(_x18, _x19, _x20) {
      return _sendDirectMessage.apply(this, arguments);
    }

    return sendDirectMessage;
  }();

  _proto.updateMessageInStore = function updateMessageInStore(sdkMessage, messageInput) {
    if (!sdkMessage) {
      HMSLogger.w('sendMessage', 'Failed to send message', messageInput);
      throw Error("sendMessage Failed - " + JSON.stringify(messageInput));
    }

    var hmsMessage = SDKToHMS.convertMessage(sdkMessage);
    hmsMessage.read = true;
    hmsMessage.senderName = 'You';
    this.onHMSMessage(hmsMessage);
    return hmsMessage;
  };

  _proto.setMessageRead = function setMessageRead(readStatus, messageId) {
    var _this4 = this;

    this.setState(function (store) {
      if (messageId) {
        if (!store.messages.byID[messageId]) {
          _this4.logPossibleInconsistency('no message with id is found');
        } else {
          store.messages.byID[messageId].read = readStatus;
        }
      } else {
        store.messages.allIDs.forEach(function (id) {
          store.messages.byID[id].read = readStatus;
        });
      }
    }, 'setMessageRead');
  };

  _proto.attachVideo = /*#__PURE__*/function () {
    var _attachVideo = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee16(trackID, videoElement) {
      var _this5 = this;

      return runtime_1.wrap(function _callee16$(_context16) {
        while (1) {
          switch (_context16.prev = _context16.next) {
            case 0:
              if (!this.localAndVideoUnmuting(trackID)) {
                _context16.next = 4;
                break;
              }

              return _context16.abrupt("return", new Promise(function (resolve) {
                var unsub = _this5.store.subscribe( /*#__PURE__*/function () {
                  var _ref2 = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee15(enabled) {
                    return runtime_1.wrap(function _callee15$(_context15) {
                      while (1) {
                        switch (_context15.prev = _context15.next) {
                          case 0:
                            if (!enabled) {
                              _context15.next = 5;
                              break;
                            }

                            _context15.next = 3;
                            return _this5.attachVideoInternal(trackID, videoElement);

                          case 3:
                            unsub();
                            resolve();

                          case 5:
                          case "end":
                            return _context15.stop();
                        }
                      }
                    }, _callee15);
                  }));

                  return function (_x23) {
                    return _ref2.apply(this, arguments);
                  };
                }(), selectIsLocalVideoEnabled);
              }));

            case 4:
              _context16.next = 6;
              return this.attachVideoInternal(trackID, videoElement);

            case 6:
            case "end":
              return _context16.stop();
          }
        }
      }, _callee16, this);
    }));

    function attachVideo(_x21, _x22) {
      return _attachVideo.apply(this, arguments);
    }

    return attachVideo;
  }();

  _proto.detachVideo = /*#__PURE__*/function () {
    var _detachVideo = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee17(trackID, videoElement) {
      var sdkTrack;
      return runtime_1.wrap(function _callee17$(_context17) {
        while (1) {
          switch (_context17.prev = _context17.next) {
            case 0:
              sdkTrack = this.hmsSDKTracks[trackID];

              if (!(sdkTrack && sdkTrack.type === 'video')) {
                _context17.next = 7;
                break;
              }

              _context17.next = 4;
              return sdkTrack.removeSink(videoElement);

            case 4:
              this.updateVideoLayer(trackID, 'detachVideo');
              _context17.next = 8;
              break;

            case 7:
              this.logPossibleInconsistency('no video track found to remove sink');

            case 8:
            case "end":
              return _context17.stop();
          }
        }
      }, _callee17, this);
    }));

    function detachVideo(_x24, _x25) {
      return _detachVideo.apply(this, arguments);
    }

    return detachVideo;
  }();

  _proto.addPluginToVideoTrack = /*#__PURE__*/function () {
    var _addPluginToVideoTrack = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee18(plugin, pluginFrameRate) {
      return runtime_1.wrap(function _callee18$(_context18) {
        while (1) {
          switch (_context18.prev = _context18.next) {
            case 0:
              return _context18.abrupt("return", this.addRemoveVideoPlugin(plugin, 'add', pluginFrameRate));

            case 1:
            case "end":
              return _context18.stop();
          }
        }
      }, _callee18, this);
    }));

    function addPluginToVideoTrack(_x26, _x27) {
      return _addPluginToVideoTrack.apply(this, arguments);
    }

    return addPluginToVideoTrack;
  }();

  _proto.addPluginToAudioTrack = /*#__PURE__*/function () {
    var _addPluginToAudioTrack = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee19(plugin) {
      return runtime_1.wrap(function _callee19$(_context19) {
        while (1) {
          switch (_context19.prev = _context19.next) {
            case 0:
              return _context19.abrupt("return", this.addRemoveAudioPlugin(plugin, 'add'));

            case 1:
            case "end":
              return _context19.stop();
          }
        }
      }, _callee19, this);
    }));

    function addPluginToAudioTrack(_x28) {
      return _addPluginToAudioTrack.apply(this, arguments);
    }

    return addPluginToAudioTrack;
  }();

  _proto.removePluginFromVideoTrack = /*#__PURE__*/function () {
    var _removePluginFromVideoTrack = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee20(plugin) {
      return runtime_1.wrap(function _callee20$(_context20) {
        while (1) {
          switch (_context20.prev = _context20.next) {
            case 0:
              return _context20.abrupt("return", this.addRemoveVideoPlugin(plugin, 'remove'));

            case 1:
            case "end":
              return _context20.stop();
          }
        }
      }, _callee20, this);
    }));

    function removePluginFromVideoTrack(_x29) {
      return _removePluginFromVideoTrack.apply(this, arguments);
    }

    return removePluginFromVideoTrack;
  }();

  _proto.removePluginFromAudioTrack = /*#__PURE__*/function () {
    var _removePluginFromAudioTrack = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee21(plugin) {
      return runtime_1.wrap(function _callee21$(_context21) {
        while (1) {
          switch (_context21.prev = _context21.next) {
            case 0:
              return _context21.abrupt("return", this.addRemoveAudioPlugin(plugin, 'remove'));

            case 1:
            case "end":
              return _context21.stop();
          }
        }
      }, _callee21, this);
    }));

    function removePluginFromAudioTrack(_x30) {
      return _removePluginFromAudioTrack.apply(this, arguments);
    }

    return removePluginFromAudioTrack;
  }();

  _proto.changeRole = /*#__PURE__*/function () {
    var _changeRole = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee22(forPeerId, toRole, force) {
      var peer;
      return runtime_1.wrap(function _callee22$(_context22) {
        while (1) {
          switch (_context22.prev = _context22.next) {
            case 0:
              if (force === void 0) {
                force = false;
              }

              peer = this.hmsSDKPeers[forPeerId];

              if (peer) {
                _context22.next = 5;
                break;
              }

              this.logPossibleInconsistency("Unknown peer ID given " + forPeerId + " for changerole");
              return _context22.abrupt("return");

            case 5:
              _context22.next = 7;
              return this.sdk.changeRole(peer, toRole, force);

            case 7:
            case "end":
              return _context22.stop();
          }
        }
      }, _callee22, this);
    }));

    function changeRole(_x31, _x32, _x33) {
      return _changeRole.apply(this, arguments);
    }

    return changeRole;
  }() // TODO: separate out role related things in another file
  ;

  _proto.acceptChangeRole =
  /*#__PURE__*/
  function () {
    var _acceptChangeRole = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee23(request) {
      var sdkPeer, sdkRequest;
      return runtime_1.wrap(function _callee23$(_context23) {
        while (1) {
          switch (_context23.prev = _context23.next) {
            case 0:
              sdkPeer = request.requestedBy ? this.hmsSDKPeers[request.requestedBy.id] : undefined;

              if (!sdkPeer) {
                HMSLogger.w("peer for which role change is requested no longer available - " + request.requestedBy);
              }

              sdkRequest = {
                requestedBy: sdkPeer,
                role: request.role,
                token: request.token
              }; // TODO: hotfix for HMS-3639. Needs a better solution
              //@ts-ignore

              _context23.next = 5;
              return this.sdk.acceptChangeRole(sdkRequest);

            case 5:
              this.removeRoleChangeRequest(request);

            case 6:
            case "end":
              return _context23.stop();
          }
        }
      }, _callee23, this);
    }));

    function acceptChangeRole(_x34) {
      return _acceptChangeRole.apply(this, arguments);
    }

    return acceptChangeRole;
  }()
  /**
   * @privateRemarks
   * there is no corresponding sdk method for rejecting change role but as the store also maintains the full
   * state of current pending requests, this method allows it to clean up when the request is rejected
   */
  ;

  _proto.rejectChangeRole = function rejectChangeRole(request) {
    this.removeRoleChangeRequest(request);
  };

  _proto.endRoom = /*#__PURE__*/function () {
    var _endRoom = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee24(lock, reason) {
      var permissions;
      return runtime_1.wrap(function _callee24$(_context24) {
        while (1) {
          switch (_context24.prev = _context24.next) {
            case 0:
              permissions = this.store.getState(selectPermissions);

              if (permissions != null && permissions.endRoom) {
                _context24.next = 4;
                break;
              }

              HMSLogger.w('You are not allowed to perform this action - endRoom');
              return _context24.abrupt("return");

            case 4:
              _context24.next = 6;
              return this.sdk.endRoom(lock, reason);

            case 6:
            case "end":
              return _context24.stop();
          }
        }
      }, _callee24, this);
    }));

    function endRoom(_x35, _x36) {
      return _endRoom.apply(this, arguments);
    }

    return endRoom;
  }();

  _proto.removePeer = /*#__PURE__*/function () {
    var _removePeer = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee25(peerID, reason) {
      var peer;
      return runtime_1.wrap(function _callee25$(_context25) {
        while (1) {
          switch (_context25.prev = _context25.next) {
            case 0:
              peer = this.hmsSDKPeers[peerID];

              if (!(peer && !peer.isLocal)) {
                _context25.next = 6;
                break;
              }

              _context25.next = 4;
              return this.sdk.removePeer(peer, reason);

            case 4:
              _context25.next = 8;
              break;

            case 6:
              this.logPossibleInconsistency("No remote peer found for peerID - " + peerID);
              return _context25.abrupt("return");

            case 8:
            case "end":
              return _context25.stop();
          }
        }
      }, _callee25, this);
    }));

    function removePeer(_x37, _x38) {
      return _removePeer.apply(this, arguments);
    }

    return removePeer;
  }();

  _proto.startRTMPOrRecording = /*#__PURE__*/function () {
    var _startRTMPOrRecording = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee26(params) {
      return runtime_1.wrap(function _callee26$(_context26) {
        while (1) {
          switch (_context26.prev = _context26.next) {
            case 0:
              _context26.next = 2;
              return this.sdk.startRTMPOrRecording(params);

            case 2:
            case "end":
              return _context26.stop();
          }
        }
      }, _callee26, this);
    }));

    function startRTMPOrRecording(_x39) {
      return _startRTMPOrRecording.apply(this, arguments);
    }

    return startRTMPOrRecording;
  }();

  _proto.stopRTMPAndRecording = /*#__PURE__*/function () {
    var _stopRTMPAndRecording = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee27() {
      return runtime_1.wrap(function _callee27$(_context27) {
        while (1) {
          switch (_context27.prev = _context27.next) {
            case 0:
              _context27.next = 2;
              return this.sdk.stopRTMPAndRecording();

            case 2:
            case "end":
              return _context27.stop();
          }
        }
      }, _callee27, this);
    }));

    function stopRTMPAndRecording() {
      return _stopRTMPAndRecording.apply(this, arguments);
    }

    return stopRTMPAndRecording;
  }();

  _proto.setRemoteTrackEnabled = /*#__PURE__*/function () {
    var _setRemoteTrackEnabled = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee28(trackID, enabled) {
      var _this6 = this;

      var track;
      return runtime_1.wrap(function _callee28$(_context28) {
        while (1) {
          switch (_context28.prev = _context28.next) {
            case 0:
              if (!(typeof trackID === 'string')) {
                _context28.next = 10;
                break;
              }

              track = this.hmsSDKTracks[trackID];

              if (!(track && isRemoteTrack(track))) {
                _context28.next = 7;
                break;
              }

              _context28.next = 5;
              return this.sdk.changeTrackState(track, enabled);

            case 5:
              _context28.next = 8;
              break;

            case 7:
              this.logPossibleInconsistency("No remote track with ID " + trackID + " found for change track state");

            case 8:
              _context28.next = 11;
              break;

            case 10:
              if (Array.isArray(trackID)) {
                trackID.forEach(function (id) {
                  return _this6.setRemoteTrackEnabled(id, enabled);
                });
              }

            case 11:
            case "end":
              return _context28.stop();
          }
        }
      }, _callee28, this);
    }));

    function setRemoteTrackEnabled(_x40, _x41) {
      return _setRemoteTrackEnabled.apply(this, arguments);
    }

    return setRemoteTrackEnabled;
  }();

  _proto.setRemoteTracksEnabled = /*#__PURE__*/function () {
    var _setRemoteTracksEnabled = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee29(params) {
      var sdkRequest, rolesMap;
      return runtime_1.wrap(function _callee29$(_context29) {
        while (1) {
          switch (_context29.prev = _context29.next) {
            case 0:
              sdkRequest = {
                enabled: params.enabled,
                type: params.type,
                source: params.source
              };

              if (params.roles) {
                rolesMap = this.store.getState(selectRolesMap);
                sdkRequest.roles = params.roles.map(function (role) {
                  return rolesMap[role];
                });
              }

              _context29.next = 4;
              return this.sdk.changeMultiTrackState(sdkRequest);

            case 4:
            case "end":
              return _context29.stop();
          }
        }
      }, _callee29, this);
    }));

    function setRemoteTracksEnabled(_x42) {
      return _setRemoteTracksEnabled.apply(this, arguments);
    }

    return setRemoteTracksEnabled;
  }();

  _proto.setLogLevel = function setLogLevel(level) {
    HMSLogger.level = level;
    this.sdk.setLogLevel(level);
  };

  _proto.resetState = function resetState(reason) {
    if (reason === void 0) {
      reason = 'resetState';
    }

    this.setState(function (store) {
      Object.assign(store, createDefaultStoreState());
    }, reason);
    this.isRoomJoinCalled = false;
    this.hmsSDKTracks = {};
    HMSLogger.cleanUp();
  };

  _proto.sdkJoinWithListeners = function sdkJoinWithListeners(config) {
    this.sdk.join(config, {
      onJoin: this.onJoin.bind(this),
      onRoomUpdate: this.onRoomUpdate.bind(this),
      onPeerUpdate: this.onPeerUpdate.bind(this),
      onTrackUpdate: this.onTrackUpdate.bind(this),
      onMessageReceived: this.onMessageReceived.bind(this),
      onError: this.onError.bind(this),
      onReconnected: this.onReconnected.bind(this),
      onReconnecting: this.onReconnecting.bind(this),
      onRoleChangeRequest: this.onRoleChangeRequest.bind(this),
      onRoleUpdate: this.onRoleUpdate.bind(this),
      onDeviceChange: this.onDeviceChange.bind(this),
      onChangeTrackStateRequest: this.onChangeTrackStateRequest.bind(this),
      onChangeMultiTrackStateRequest: this.onChangeMultiTrackStateRequest.bind(this),
      onRemovedFromRoom: this.onRemovedFromRoom.bind(this)
    });
    this.sdk.addAudioListener({
      onAudioLevelUpdate: this.onAudioLevelUpdate.bind(this)
    });
  };

  _proto.onRemovedFromRoom = function onRemovedFromRoom(request) {
    var requestedBy = this.store.getState(selectPeerByID(request.requestedBy.peerId));

    if (!requestedBy) {
      this.logPossibleInconsistency("Not found peer who requested leave room, " + request.requestedBy);
      return;
    }

    this.hmsNotifications.sendLeaveRoom(_extends({}, request, {
      requestedBy: requestedBy
    }));
    HMSLogger.i('resetting state after peer removed', request);
    this.resetState(request.roomEnded ? 'roomEnded' : 'removedFromRoom');
  };

  _proto.onDeviceChange = function onDeviceChange(event) {
    var _this7 = this;

    var devices = event.devices;

    if (!devices) {
      return;
    }

    var localPeer = this.store.getState(selectLocalPeer);
    this.setState(function (store) {
      if (!areArraysEqual(store.devices.audioInput, devices.audioInput)) {
        store.devices.audioInput = devices.audioInput;
      }

      if (!areArraysEqual(store.devices.videoInput, devices.videoInput)) {
        store.devices.videoInput = devices.videoInput;
      }

      if (!areArraysEqual(store.devices.audioOutput, devices.audioOutput)) {
        store.devices.audioOutput = devices.audioOutput;
      }

      if (_this7.hmsSDKPeers[localPeer == null ? void 0 : localPeer.id]) {
        Object.assign(store.settings, _this7.getMediaSettings(_this7.hmsSDKPeers[localPeer == null ? void 0 : localPeer.id]));
      }
    }, 'deviceChange'); // sync is needed to update the current selected device
    // this.syncRoomState('deviceChangeSync');
    // send notification only on device change - selection is present

    if (event.selection) {
      var notification = SDKToHMS.convertDeviceChangeUpdate(event);
      this.hmsNotifications.sendDeviceChange(notification);
    }
  };

  _proto.sdkPreviewWithListeners = /*#__PURE__*/function () {
    var _sdkPreviewWithListeners = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee30(config) {
      return runtime_1.wrap(function _callee30$(_context30) {
        while (1) {
          switch (_context30.prev = _context30.next) {
            case 0:
              _context30.next = 2;
              return this.sdk.preview(config, {
                onPreview: this.onPreview.bind(this),
                onError: this.onError.bind(this),
                onDeviceChange: this.onDeviceChange.bind(this)
              });

            case 2:
              this.sdk.addAudioListener({
                onAudioLevelUpdate: this.onAudioLevelUpdate.bind(this)
              });

            case 3:
            case "end":
              return _context30.stop();
          }
        }
      }, _callee30, this);
    }));

    function sdkPreviewWithListeners(_x43) {
      return _sdkPreviewWithListeners.apply(this, arguments);
    }

    return sdkPreviewWithListeners;
  }();

  _proto.startScreenShare = /*#__PURE__*/function () {
    var _startScreenShare = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee31(audioOnly) {
      var _this8 = this;

      var isScreenShared;
      return runtime_1.wrap(function _callee31$(_context31) {
        while (1) {
          switch (_context31.prev = _context31.next) {
            case 0:
              isScreenShared = this.store.getState(selectIsLocalScreenShared);

              if (isScreenShared) {
                _context31.next = 7;
                break;
              }

              _context31.next = 4;
              return this.sdk.startScreenShare(function () {
                return _this8.syncRoomState('screenshareStopped');
              }, audioOnly);

            case 4:
              this.syncRoomState('startScreenShare');
              _context31.next = 8;
              break;

            case 7:
              this.logPossibleInconsistency("start screenshare is called while it's on");

            case 8:
            case "end":
              return _context31.stop();
          }
        }
      }, _callee31, this);
    }));

    function startScreenShare(_x44) {
      return _startScreenShare.apply(this, arguments);
    }

    return startScreenShare;
  }();

  _proto.stopScreenShare = /*#__PURE__*/function () {
    var _stopScreenShare = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee32() {
      var isScreenShared;
      return runtime_1.wrap(function _callee32$(_context32) {
        while (1) {
          switch (_context32.prev = _context32.next) {
            case 0:
              isScreenShared = this.store.getState(selectIsLocalScreenShared);

              if (!isScreenShared) {
                _context32.next = 7;
                break;
              }

              _context32.next = 4;
              return this.sdk.stopScreenShare();

            case 4:
              this.syncRoomState('stopScreenShare');
              _context32.next = 8;
              break;

            case 7:
              this.logPossibleInconsistency("stop screenshare is called while it's not on");

            case 8:
            case "end":
              return _context32.stop();
          }
        }
      }, _callee32, this);
    }));

    function stopScreenShare() {
      return _stopScreenShare.apply(this, arguments);
    }

    return stopScreenShare;
  }();

  _proto.attachVideoInternal = /*#__PURE__*/function () {
    var _attachVideoInternal = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee33(trackID, videoElement) {
      var sdkTrack;
      return runtime_1.wrap(function _callee33$(_context33) {
        while (1) {
          switch (_context33.prev = _context33.next) {
            case 0:
              sdkTrack = this.hmsSDKTracks[trackID];

              if (!(sdkTrack && sdkTrack.type === 'video')) {
                _context33.next = 7;
                break;
              }

              _context33.next = 4;
              return sdkTrack.addSink(videoElement);

            case 4:
              this.updateVideoLayer(trackID, 'attachVideo');
              _context33.next = 8;
              break;

            case 7:
              this.logPossibleInconsistency('no video track found to add sink');

            case 8:
            case "end":
              return _context33.stop();
          }
        }
      }, _callee33, this);
    }));

    function attachVideoInternal(_x45, _x46) {
      return _attachVideoInternal.apply(this, arguments);
    }

    return attachVideoInternal;
  }()
  /**
   * This is a very important function as it's responsible for maintaining the source of
   * truth with maximum efficiency. The efficiency comes from the fact that the only
   * those portions of the store are updated which have actually changed.
   * While making a change in this function don't use functions like map, reduce etc.
   * which return a new copy of the data. Use Object.assign etc. to ensure that if the data
   * doesn't change reference is also not changed.
   * The UI and selectors rely on the fact that the store is immutable that is if there is
   * any change and only if there is a change, they'll get a new copy of the data they're
   * interested in with a new reference.
   * @protected
   */
  ;

  _proto.syncRoomState = function syncRoomState(action) {
    var _this9 = this;

    HMSLogger.time("store-sync-" + action);
    var newHmsPeers = {};
    var newHmsPeerIDs = []; // to add in room.peers

    var newHmsTracks = {};
    var newHmsSDkTracks = {};
    var newMediaSettings = {};
    var sdkPeers = this.sdk.getPeers(); // first convert everything in the new format

    for (var _iterator = _createForOfIteratorHelperLoose(sdkPeers), _step; !(_step = _iterator()).done;) {
      var sdkPeer = _step.value;
      var hmsPeer = SDKToHMS.convertPeer(sdkPeer);
      newHmsPeers[hmsPeer.id] = hmsPeer;
      newHmsPeerIDs.push(hmsPeer.id);
      this.hmsSDKPeers[hmsPeer.id] = sdkPeer;
      var sdkTracks = [sdkPeer.audioTrack, sdkPeer.videoTrack].concat(sdkPeer.auxiliaryTracks);

      for (var _iterator2 = _createForOfIteratorHelperLoose(sdkTracks), _step2; !(_step2 = _iterator2()).done;) {
        var sdkTrack = _step2.value;

        if (!sdkTrack) {
          continue;
        }

        var hmsTrack = SDKToHMS.convertTrack(sdkTrack);
        newHmsTracks[hmsTrack.id] = hmsTrack;
        newHmsSDkTracks[sdkTrack.trackId] = sdkTrack;
      }

      if (hmsPeer.isLocal) {
        Object.assign(newMediaSettings, this.getMediaSettings(sdkPeer));
      }
    }

    var recording = this.sdk.getRecordingState();
    var rtmp = this.sdk.getRTMPState(); // then merge them carefully with our store so if something hasn't changed
    // the reference shouldn't change. Note that the draftStore is an immer draft
    // object.

    this.setState(function (draftStore) {
      draftStore.room.peers = newHmsPeerIDs;
      var draftPeers = draftStore.peers;
      var draftTracks = draftStore.tracks; // the order of below statements are important as merge functions are mutating

      mergeNewPeersInDraft(draftPeers, newHmsPeers);
      mergeNewTracksInDraft(draftTracks, newHmsTracks);
      Object.assign(draftStore.settings, newMediaSettings);
      _this9.hmsSDKTracks = newHmsSDkTracks;
      Object.assign(draftStore.roles, SDKToHMS.convertRoles(_this9.sdk.getRoles()));
      Object.assign(draftStore.playlist, SDKToHMS.convertPlaylist(_this9.sdk.getPlaylistManager()));
      Object.assign(draftStore.room, SDKToHMS.convertRecordingRTMPState(recording, rtmp));
    }, action);
    HMSLogger.timeEnd("store-sync-" + action);
  };

  _proto.onPreview = function onPreview(sdkRoom) {
    this.setState(function (store) {
      Object.assign(store.room, SDKToHMS.convertRoom(sdkRoom));
      store.room.roomState = exports.HMSRoomState.Preview;
    }, 'previewStart');
    this.syncRoomState('previewSync');
  };

  _proto.onJoin = function onJoin(sdkRoom) {
    var _this10 = this;

    this.audioPlaylist = new HMSPlaylist(this.sdk.getPlaylistManager(), exports.HMSPlaylistType.audio, this.syncPlaylistState.bind(this), this.store);
    this.videoPlaylist = new HMSPlaylist(this.sdk.getPlaylistManager(), exports.HMSPlaylistType.video, this.syncRoomState.bind(this), this.store);
    this.syncRoomState('joinSync');
    this.setState(function (store) {
      Object.assign(store.room, SDKToHMS.convertRoom(sdkRoom));
      store.room.isConnected = true;
      store.room.roomState = exports.HMSRoomState.Connected;
    }, 'joined');
    this.sdk.getPlaylistManager().onProgress(this.setProgress);
    this.sdk.getPlaylistManager().onNewTrackStart(function (item) {
      _this10.syncPlaylistState(item.type + "PlaylistUpdate");
    });
    this.sdk.getPlaylistManager().onPlaylistEnded(function (type) {
      _this10.syncPlaylistState(type + "PlaylistEnded");
    });
  } //@ts-ignore
  ;

  _proto.onRoomUpdate = function onRoomUpdate(type, room) {
    this.setState(function (store) {
      Object.assign(store.room, SDKToHMS.convertRoom(room));
    }, 'RoomUpdate');
  };

  _proto.onPeerUpdate = function onPeerUpdate(type, sdkPeer) {
    if ([sdkTypes.HMSPeerUpdate.BECAME_DOMINANT_SPEAKER, sdkTypes.HMSPeerUpdate.RESIGNED_DOMINANT_SPEAKER].includes(type)) {
      return; // ignore, high frequency update so no point of syncing peers
    }

    if (Array.isArray(sdkPeer)) {
      this.syncRoomState('peersJoined');
      var hmsPeers = [];

      for (var _iterator3 = _createForOfIteratorHelperLoose(sdkPeer), _step3; !(_step3 = _iterator3()).done;) {
        var peer = _step3.value;
        var hmsPeer = this.store.getState(selectPeerByID(peer.peerId));

        if (hmsPeer) {
          hmsPeers.push(hmsPeer);
        }
      }

      this.hmsNotifications.sendPeerList(hmsPeers);
      return;
    }

    this.sendPeerUpdateNotification(type, sdkPeer);
  };

  _proto.onTrackUpdate = function onTrackUpdate(type, track, peer) {
    // this check is needed because for track removed case, the notification needs to
    // be send before the track is removed from store
    if (type === sdkTypes.HMSTrackUpdate.TRACK_REMOVED) {
      this.hmsNotifications.sendTrackUpdate(type, track.trackId);
      this.handleTrackRemove(track, peer);
    } else {
      var actionName = type === sdkTypes.HMSTrackUpdate.TRACK_ADDED ? 'trackAdded' : 'trackUpdate';
      this.syncRoomState(actionName);
      this.hmsNotifications.sendTrackUpdate(type, track.trackId);
    }
  };

  _proto.onMessageReceived = function onMessageReceived(sdkMessage) {
    var hmsMessage = SDKToHMS.convertMessage(sdkMessage);
    hmsMessage.read = false;
    this.onHMSMessage(hmsMessage);
    this.hmsNotifications.sendMessageReceived(hmsMessage);
  };

  _proto.onHMSMessage = function onHMSMessage(hmsMessage) {
    var _this11 = this;

    this.setState(function (store) {
      hmsMessage.id = String(_this11.store.getState(selectHMSMessagesCount) + 1);
      store.messages.byID[hmsMessage.id] = hmsMessage;
      store.messages.allIDs.push(hmsMessage.id);
    }, 'newMessage');
  }
  /*
   * Note: speakers array contain the value only for peers who have audioLevel != 0
   */
  ;

  _proto.onAudioLevelUpdate = function onAudioLevelUpdate(sdkSpeakers) {
    this.setState(function (store) {
      var trackIDAudioLevelMap = {};
      sdkSpeakers.forEach(function (sdkSpeaker) {
        if (!sdkSpeaker.track || !sdkSpeaker.peer) {
          return;
        }

        var trackID = sdkSpeaker.track.trackId;
        trackIDAudioLevelMap[trackID] = sdkSpeaker.audioLevel;

        if (!store.speakers[trackID]) {
          // Set store instances(peers, tracks) references in speaker, not the new ones received.
          store.speakers[trackID] = {
            audioLevel: sdkSpeaker.audioLevel,
            peerID: sdkSpeaker.peer.peerId,
            trackID: trackID
          };
        }
      });
      var speakerEntries = Object.entries(store.speakers);

      for (var _i = 0, _speakerEntries = speakerEntries; _i < _speakerEntries.length; _i++) {
        var _speakerEntries$_i = _speakerEntries[_i],
            trackID = _speakerEntries$_i[0],
            speaker = _speakerEntries$_i[1];
        speaker.audioLevel = trackIDAudioLevelMap[trackID] || 0;

        if (speaker.audioLevel === 0) {
          delete store.speakers[trackID];
        }
      }
    }, 'audioLevel');
  };

  _proto.onChangeTrackStateRequest = function onChangeTrackStateRequest(request) {
    var requestedBy = this.store.getState(selectPeerByID(request.requestedBy.peerId));
    var storeTrackID = this.getStoreLocalTrackIDfromSDKTrack(request.track);
    var track = this.store.getState(selectTrackByID(storeTrackID));

    if (!requestedBy) {
      return this.logPossibleInconsistency("Not found peer who requested track state change, " + request.requestedBy);
    }

    if (!track) {
      return this.logPossibleInconsistency("Not found track for which track state change was requested, " + request.track);
    }

    if (!request.enabled) {
      this.syncRoomState('changeTrackStateRequest');
    }

    this.hmsNotifications.sendChangeTrackStateRequest({
      requestedBy: requestedBy,
      track: track,
      enabled: request.enabled
    });
  };

  _proto.onChangeMultiTrackStateRequest = function onChangeMultiTrackStateRequest(request) {
    var requestedBy = this.store.getState(selectPeerByID(request.requestedBy.peerId));

    if (!requestedBy) {
      return this.logPossibleInconsistency("Not found peer who requested track state change, " + request.requestedBy);
    }

    if (!request.enabled) {
      this.syncRoomState('changeMultiTrackStateRequest');
    }

    var tracks = [];
    var tracksMap = this.store.getState(selectTracksMap);

    for (var _iterator4 = _createForOfIteratorHelperLoose(request.tracks), _step4; !(_step4 = _iterator4()).done;) {
      var track = _step4.value;
      var storeTrackID = this.getStoreLocalTrackIDfromSDKTrack(track);

      if (storeTrackID && tracksMap[storeTrackID]) {
        tracks.push(tracksMap[storeTrackID]);
      }
    }

    this.hmsNotifications.sendChangeMultiTrackStateRequest({
      requestedBy: requestedBy,
      tracks: tracks,
      enabled: request.enabled,
      type: request.type,
      source: request.source
    });
  };

  _proto.onReconnected = function onReconnected() {
    this.syncRoomState('reconnectedSync');
    this.hmsNotifications.sendReconnected();
    this.setState(function (store) {
      store.room.roomState = exports.HMSRoomState.Connected;
    }, 'reconnected');
  };

  _proto.onReconnecting = function onReconnecting(sdkError) {
    var error = SDKToHMS.convertException(sdkError);
    HMSLogger.e('Reconnection: received error from sdk', error);
    this.hmsNotifications.sendReconnecting(error);
    this.setState(function (store) {
      store.room.roomState = exports.HMSRoomState.Reconnecting;
      store.errors.push(error);
    }, 'reconnecting');
  };

  _proto.onError = function onError(sdkException) {
    var error = SDKToHMS.convertException(sdkException);

    if (error.isTerminal) {
      // terminal error leave room as it is not recoverable
      this.leave().then(function () {
        return console.log('error from SDK, left room.');
      });
      this.setState(function (store) {
        store.room.roomState = exports.HMSRoomState.Failed;
        store.errors.push(error);
      }, 'errorTerminal');
    } else {
      var numExistingErrors = this.store.getState().errors.length; // just in case there is some infinite loop sending errors

      if (numExistingErrors < 50) {
        this.setState(function (store) {
          store.errors.push(error);
        }, 'error');
      }
    } // send notification


    this.hmsNotifications.sendError(error);
    HMSLogger.e('received error from sdk', error);
  }
  /**
   * the layer gets updated on addsink/removesink/preferlayer calls, for simulcast there
   * can be multiple layers, while for non simulcast there will be None and High.
   */
  ;

  _proto.updateVideoLayer = function updateVideoLayer(trackID, action) {
    var sdkTrack = this.hmsSDKTracks[trackID];

    if (sdkTrack && sdkTrack instanceof sdkTypes.HMSRemoteVideoTrack) {
      this.setState(function (draft) {
        draft.tracks[trackID].layer = sdkTrack.getSimulcastLayer();
      }, action);
    }
  };

  _proto.handleTrackRemove = function handleTrackRemove(sdkTrack, sdkPeer) {
    var _this12 = this;

    this.setState(function (draftStore) {
      var hmsPeer = draftStore.peers[sdkPeer.peerId];
      var draftTracks = draftStore.tracks;
      var trackId = sdkTrack.trackId; // find and remove the exact track from hmsPeer

      if (_this12.isSameStoreSDKTrack(trackId, hmsPeer == null ? void 0 : hmsPeer.audioTrack)) {
        hmsPeer == null ? true : delete hmsPeer.audioTrack;
      } else if (_this12.isSameStoreSDKTrack(trackId, hmsPeer == null ? void 0 : hmsPeer.videoTrack)) {
        hmsPeer == null ? true : delete hmsPeer.videoTrack;
      } else {
        var auxiliaryIndex = hmsPeer == null ? void 0 : hmsPeer.auxiliaryTracks.indexOf(trackId);

        if (auxiliaryIndex > -1 && _this12.isSameStoreSDKTrack(trackId, hmsPeer == null ? void 0 : hmsPeer.auxiliaryTracks[auxiliaryIndex])) {
          hmsPeer == null ? void 0 : hmsPeer.auxiliaryTracks.splice(auxiliaryIndex, 1);
        }
      }

      delete draftTracks[trackId];
      delete _this12.hmsSDKTracks[trackId];
    }, 'trackRemoved');
  };

  _proto.setEnabledSDKTrack = /*#__PURE__*/function () {
    var _setEnabledSDKTrack = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee34(trackID, enabled) {
      var track;
      return runtime_1.wrap(function _callee34$(_context34) {
        while (1) {
          switch (_context34.prev = _context34.next) {
            case 0:
              track = this.hmsSDKTracks[trackID];

              if (!track) {
                _context34.next = 6;
                break;
              }

              _context34.next = 4;
              return track.setEnabled(enabled);

            case 4:
              _context34.next = 7;
              break;

            case 6:
              this.logPossibleInconsistency("track " + trackID + " not present, unable to enabled/disable");

            case 7:
            case "end":
              return _context34.stop();
          }
        }
      }, _callee34, this);
    }));

    function setEnabledSDKTrack(_x47, _x48) {
      return _setEnabledSDKTrack.apply(this, arguments);
    }

    return setEnabledSDKTrack;
  }();

  _proto.setSDKLocalVideoTrackSettings = /*#__PURE__*/function () {
    var _setSDKLocalVideoTrackSettings = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee35(trackID, settings) {
      var track;
      return runtime_1.wrap(function _callee35$(_context35) {
        while (1) {
          switch (_context35.prev = _context35.next) {
            case 0:
              track = this.hmsSDKTracks[trackID];

              if (!track) {
                _context35.next = 6;
                break;
              }

              _context35.next = 4;
              return track.setSettings(settings);

            case 4:
              _context35.next = 7;
              break;

            case 6:
              this.logPossibleInconsistency("local track " + trackID + " not present, unable to set settings");

            case 7:
            case "end":
              return _context35.stop();
          }
        }
      }, _callee35, this);
    }));

    function setSDKLocalVideoTrackSettings(_x49, _x50) {
      return _setSDKLocalVideoTrackSettings.apply(this, arguments);
    }

    return setSDKLocalVideoTrackSettings;
  }();

  _proto.setSDKLocalAudioTrackSettings = /*#__PURE__*/function () {
    var _setSDKLocalAudioTrackSettings = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee36(trackID, settings) {
      var track;
      return runtime_1.wrap(function _callee36$(_context36) {
        while (1) {
          switch (_context36.prev = _context36.next) {
            case 0:
              track = this.hmsSDKTracks[trackID];

              if (!track) {
                _context36.next = 6;
                break;
              }

              _context36.next = 4;
              return track.setSettings(settings);

            case 4:
              _context36.next = 7;
              break;

            case 6:
              this.logPossibleInconsistency("local track " + trackID + " not present, unable to set settings");

            case 7:
            case "end":
              return _context36.stop();
          }
        }
      }, _callee36, this);
    }));

    function setSDKLocalAudioTrackSettings(_x51, _x52) {
      return _setSDKLocalAudioTrackSettings.apply(this, arguments);
    }

    return setSDKLocalAudioTrackSettings;
  }();

  _proto.getMediaSettings = function getMediaSettings(sdkPeer) {
    var _audioTrack$getMediaT, _videoTrack$getMediaT, _this$sdk$getAudioOut;

    var settings = this.store.getState(selectLocalMediaSettings);
    var audioTrack = sdkPeer.audioTrack;
    var videoTrack = sdkPeer.videoTrack;
    return {
      audioInputDeviceId: audioTrack && audioTrack.enabled ? (_audioTrack$getMediaT = audioTrack.getMediaTrackSettings()) == null ? void 0 : _audioTrack$getMediaT.deviceId : settings.audioInputDeviceId,
      videoInputDeviceId: videoTrack && videoTrack.enabled ? (_videoTrack$getMediaT = videoTrack.getMediaTrackSettings()) == null ? void 0 : _videoTrack$getMediaT.deviceId : settings.videoInputDeviceId,
      audioOutputDeviceId: (_this$sdk$getAudioOut = this.sdk.getAudioOutput().getDevice()) == null ? void 0 : _this$sdk$getAudioOut.deviceId
    };
  };

  _proto.setTrackVolume = function setTrackVolume(value, trackId) {
    var track = this.hmsSDKTracks[trackId];

    if (track) {
      if (track instanceof sdkTypes.HMSAudioTrack) {
        track.setVolume(value);
        this.setState(function (draftStore) {
          var track = draftStore.tracks[trackId];

          if (track) {
            track.volume = value;
          }
        }, 'trackVolume');
      } else {
        HMSLogger.w("track " + trackId + " is not an audio track");
      }
    } else {
      this.logPossibleInconsistency("track " + trackId + " not present, unable to set volume");
    }
  }
  /**
   * Tells if the trackID is for local peer and video unmute is in process
   * @private
   */
  ;

  _proto.localAndVideoUnmuting = function localAndVideoUnmuting(trackID) {
    var localPeer = this.store.getState(selectLocalPeer);

    if (localPeer.videoTrack !== trackID) {
      return false;
    }

    var displayEnabled = this.store.getState(selectIsLocalVideoDisplayEnabled);
    var actuallyEnabled = this.store.getState(selectIsLocalVideoEnabled);
    return displayEnabled && !actuallyEnabled;
  };

  _proto.logPossibleInconsistency = function logPossibleInconsistency(inconsistency) {
    HMSLogger.w('possible inconsistency detected - ', inconsistency);
  };

  _proto.addRemoveVideoPlugin = /*#__PURE__*/function () {
    var _addRemoveVideoPlugin = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee37(plugin, action, pluginFrameRate) {
      var trackID, sdkTrack;
      return runtime_1.wrap(function _callee37$(_context37) {
        while (1) {
          switch (_context37.prev = _context37.next) {
            case 0:
              if (plugin) {
                _context37.next = 3;
                break;
              }

              HMSLogger.w('Invalid plugin received in store');
              return _context37.abrupt("return");

            case 3:
              trackID = this.store.getState(selectLocalVideoTrackID);

              if (!trackID) {
                _context37.next = 19;
                break;
              }

              sdkTrack = this.hmsSDKTracks[trackID];

              if (!sdkTrack) {
                _context37.next = 18;
                break;
              }

              if (!(action === 'add')) {
                _context37.next = 12;
                break;
              }

              _context37.next = 10;
              return sdkTrack.addPlugin(plugin, pluginFrameRate);

            case 10:
              _context37.next = 15;
              break;

            case 12:
              if (!(action === 'remove')) {
                _context37.next = 15;
                break;
              }

              _context37.next = 15;
              return sdkTrack.removePlugin(plugin);

            case 15:
              this.syncRoomState(action + "VideoPlugin");
              _context37.next = 19;
              break;

            case 18:
              this.logPossibleInconsistency("track " + trackID + " not present, unable to remove plugin");

            case 19:
            case "end":
              return _context37.stop();
          }
        }
      }, _callee37, this);
    }));

    function addRemoveVideoPlugin(_x53, _x54, _x55) {
      return _addRemoveVideoPlugin.apply(this, arguments);
    }

    return addRemoveVideoPlugin;
  }();

  _proto.addRemoveAudioPlugin = /*#__PURE__*/function () {
    var _addRemoveAudioPlugin = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee38(plugin, action) {
      var trackID, sdkTrack;
      return runtime_1.wrap(function _callee38$(_context38) {
        while (1) {
          switch (_context38.prev = _context38.next) {
            case 0:
              if (plugin) {
                _context38.next = 3;
                break;
              }

              HMSLogger.w('Invalid plugin received in store');
              return _context38.abrupt("return");

            case 3:
              trackID = this.store.getState(selectLocalAudioTrackID);

              if (!trackID) {
                _context38.next = 19;
                break;
              }

              sdkTrack = this.hmsSDKTracks[trackID];

              if (!sdkTrack) {
                _context38.next = 18;
                break;
              }

              if (!(action === 'add')) {
                _context38.next = 12;
                break;
              }

              _context38.next = 10;
              return sdkTrack.addPlugin(plugin);

            case 10:
              _context38.next = 15;
              break;

            case 12:
              if (!(action === 'remove')) {
                _context38.next = 15;
                break;
              }

              _context38.next = 15;
              return sdkTrack.removePlugin(plugin);

            case 15:
              this.syncRoomState(action + "AudioPlugin");
              _context38.next = 19;
              break;

            case 18:
              this.logPossibleInconsistency("track " + trackID + " not present, unable to remove plugin");

            case 19:
            case "end":
              return _context38.stop();
          }
        }
      }, _callee38, this);
    }));

    function addRemoveAudioPlugin(_x56, _x57) {
      return _addRemoveAudioPlugin.apply(this, arguments);
    }

    return addRemoveAudioPlugin;
  }()
  /**
   * In case of replace track id is changed but not in store. Given the store id, check the real id
   * sdk is using to refer to the track and match them.
   */
  ;

  _proto.isSameStoreSDKTrack = function isSameStoreSDKTrack(sdkTrackID, storeTrackID) {
    var _this$hmsSDKTracks$st;

    if (!storeTrackID) {
      return false;
    }

    return ((_this$hmsSDKTracks$st = this.hmsSDKTracks[storeTrackID]) == null ? void 0 : _this$hmsSDKTracks$st.trackId) === sdkTrackID;
  }
  /**
   * convert new role change requests to store format and save.
   * keep only one request at a time in store till we figure out how to handle multiple requests at the same time
   */
  ;

  _proto.onRoleChangeRequest = function onRoleChangeRequest(request) {
    this.setState(function (store) {
      if (store.roleChangeRequests.length === 0) {
        store.roleChangeRequests.push(SDKToHMS.convertRoleChangeRequest(request));
      }
    }, 'roleChangeRequest');
  };

  _proto.removeRoleChangeRequest = function removeRoleChangeRequest(toRemove) {
    this.setState(function (store) {
      var index = store.roleChangeRequests.findIndex(function (req) {
        return req.token === toRemove.token;
      });

      if (index !== -1) {
        store.roleChangeRequests.splice(index, 1);
      }
    }, 'removeRoleChangeRequest');
  };

  _proto.onRoleUpdate = function onRoleUpdate() {
    this.syncRoomState('roleUpdate');
  };

  _proto.getStoreLocalTrackIDfromSDKTrack = function getStoreLocalTrackIDfromSDKTrack(sdkTrack) {
    var _this13 = this;

    var trackIDs = this.store.getState(selectLocalTrackIDs);
    return trackIDs.find(function (trackID) {
      return _this13.hmsSDKTracks[trackID].trackId === sdkTrack.trackId;
    });
  };

  return HMSSDKActions;
}();

var _PEER_NOTIFICATION_TY, _TRACK_NOTIFICATION_T;
var PEER_NOTIFICATION_TYPES = (_PEER_NOTIFICATION_TY = {}, _PEER_NOTIFICATION_TY[sdkTypes.HMSPeerUpdate.PEER_JOINED] = exports.HMSNotificationTypes.PEER_JOINED, _PEER_NOTIFICATION_TY[sdkTypes.HMSPeerUpdate.PEER_LEFT] = exports.HMSNotificationTypes.PEER_LEFT, _PEER_NOTIFICATION_TY[sdkTypes.HMSPeerUpdate.ROLE_UPDATED] = exports.HMSNotificationTypes.ROLE_UPDATED, _PEER_NOTIFICATION_TY[sdkTypes.HMSPeerUpdate.AUDIO_TOGGLED] = 'PEER_AUDIO_UPDATED', _PEER_NOTIFICATION_TY[sdkTypes.HMSPeerUpdate.VIDEO_TOGGLED] = 'PEER_VIDEO_UPDATED', _PEER_NOTIFICATION_TY);
var TRACK_NOTIFICATION_TYPES = (_TRACK_NOTIFICATION_T = {}, _TRACK_NOTIFICATION_T[sdkTypes.HMSTrackUpdate.TRACK_ADDED] = exports.HMSNotificationTypes.TRACK_ADDED, _TRACK_NOTIFICATION_T[sdkTypes.HMSTrackUpdate.TRACK_REMOVED] = exports.HMSNotificationTypes.TRACK_REMOVED, _TRACK_NOTIFICATION_T[sdkTypes.HMSTrackUpdate.TRACK_MUTED] = exports.HMSNotificationTypes.TRACK_MUTED, _TRACK_NOTIFICATION_T[sdkTypes.HMSTrackUpdate.TRACK_UNMUTED] = exports.HMSNotificationTypes.TRACK_UNMUTED, _TRACK_NOTIFICATION_T);

var HMS_NOTIFICATION_EVENT = 'hmsNotification';
var HMSNotifications = /*#__PURE__*/function () {
  function HMSNotifications(store) {
    var _this = this;

    this.id = 0;

    this.onNotification = function (cb) {
      _this.eventEmitter.addListener(HMS_NOTIFICATION_EVENT, cb);

      return function () {
        _this.eventEmitter.removeListener(HMS_NOTIFICATION_EVENT, cb);
      };
    };

    this.store = store;
    this.eventEmitter = new EventEmitter();
  }

  var _proto = HMSNotifications.prototype;

  _proto.sendDeviceChange = function sendDeviceChange(request) {
    var _request$selection;

    var notification = this.createNotification(exports.HMSNotificationTypes.DEVICE_CHANGE_UPDATE, request, request.error ? exports.HMSNotificationSeverity.ERROR : exports.HMSNotificationSeverity.INFO, "Selected " + request.type + " device - " + ((_request$selection = request.selection) == null ? void 0 : _request$selection.label));
    this.emitEvent(notification);
  };

  _proto.sendLeaveRoom = function sendLeaveRoom(request) {
    var notification = this.createNotification(request.roomEnded ? exports.HMSNotificationTypes.ROOM_ENDED : exports.HMSNotificationTypes.REMOVED_FROM_ROOM, request, exports.HMSNotificationSeverity.INFO, (request.roomEnded ? "Room ended" : 'Removed from room') + " by " + request.requestedBy.name);
    this.emitEvent(notification);
  };

  _proto.sendPeerList = function sendPeerList(peers) {
    var notification = this.createNotification(exports.HMSNotificationTypes.PEER_LIST, peers, exports.HMSNotificationSeverity.INFO);
    this.emitEvent(notification);
  };

  _proto.sendPeerUpdate = function sendPeerUpdate(type, peer) {
    var hmsPeer = this.store.getState(selectPeerByID(peer == null ? void 0 : peer.id)) || peer;
    var notificationType = PEER_NOTIFICATION_TYPES[type];

    if (notificationType) {
      var notification = this.createNotification(notificationType, hmsPeer, exports.HMSNotificationSeverity.INFO);
      this.emitEvent(notification);
    }
  };

  _proto.sendTrackUpdate = function sendTrackUpdate(type, trackID) {
    var hmsTrack = this.store.getState(selectTrackByID(trackID));
    var notificationType = TRACK_NOTIFICATION_TYPES[type];

    if (notificationType) {
      var notification = this.createNotification(notificationType, hmsTrack, exports.HMSNotificationSeverity.INFO);
      this.emitEvent(notification);
    }
  };

  _proto.sendMessageReceived = function sendMessageReceived(message) {
    var notification = this.createNotification(exports.HMSNotificationTypes.NEW_MESSAGE, message, exports.HMSNotificationSeverity.INFO);
    this.emitEvent(notification);
  };

  _proto.sendError = function sendError(error) {
    var notification = this.createNotification(exports.HMSNotificationTypes.ERROR, error, exports.HMSNotificationSeverity.ERROR);
    this.emitEvent(notification);
  };

  _proto.sendReconnecting = function sendReconnecting(error) {
    var notification = this.createNotification(exports.HMSNotificationTypes.RECONNECTING, error, exports.HMSNotificationSeverity.ERROR);
    this.emitEvent(notification);
  };

  _proto.sendReconnected = function sendReconnected() {
    var notification = this.createNotification(exports.HMSNotificationTypes.RECONNECTED, null, exports.HMSNotificationSeverity.INFO);
    this.emitEvent(notification);
  };

  _proto.sendChangeTrackStateRequest = function sendChangeTrackStateRequest(request) {
    var notification = this.createNotification(exports.HMSNotificationTypes.CHANGE_TRACK_STATE_REQUEST, request, exports.HMSNotificationSeverity.INFO);
    this.emitEvent(notification);
  };

  _proto.sendChangeMultiTrackStateRequest = function sendChangeMultiTrackStateRequest(request) {
    var notification = this.createNotification(exports.HMSNotificationTypes.CHANGE_MULTI_TRACK_STATE_REQUEST, request, exports.HMSNotificationSeverity.INFO);
    this.emitEvent(notification);
  };

  _proto.emitEvent = function emitEvent(notification) {
    this.eventEmitter.emit(HMS_NOTIFICATION_EVENT, notification);
  };

  _proto.createNotification = function createNotification(type, data, severity, message) {
    if (message === void 0) {
      message = '';
    }

    this.id++;
    return {
      id: this.id,
      type: type,
      message: message,
      data: data,
      severity: severity
    };
  };

  return HMSNotifications;
}();

var HMSReactiveStore = /*#__PURE__*/function () {
  function HMSReactiveStore(hmsStore, hmsActions, hmsNotifications) {
    if (hmsStore) {
      this.store = hmsStore;
    } else {
      this.store = HMSReactiveStore.createNewHMSStore();
    }

    if (hmsNotifications) {
      this.notifications = hmsNotifications;
    } else {
      this.notifications = new HMSNotifications(this.store);
    }

    if (hmsActions) {
      this.actions = hmsActions;
    } else {
      this.actions = new HMSSDKActions(this.store, new sdkTypes.HMSSdk(), this.notifications);
    }

    this.initialTriggerOnSubscribe = false;
  }
  /**
   * By default store.subscribe does not call the handler with the current state at time of subscription,
   * this behaviour can be modified by calling this function. What it means is that instead of calling the
   * handler only for changes which happen post subscription we'll also call it exactly once at the time
   * of subscription with the current state. This behaviour is similar to that of BehaviourSubject in rxjs.
   * This will be an irreversible change
   *
   * Note: you don't need this if you're using our react hooks, it takes care of this requirement.
   */


  var _proto = HMSReactiveStore.prototype;

  _proto.triggerOnSubscribe = function triggerOnSubscribe() {
    if (this.initialTriggerOnSubscribe) {
      // already done
      return;
    }

    HMSReactiveStore.makeStoreTriggerOnSubscribe(this.store);
    this.initialTriggerOnSubscribe = true;
  }
  /**
   * A reactive store which has a subscribe method you can use in combination with selectors
   * to subscribe to a subset of the store. The store serves as a single source of truth for
   * all data related to the corresponding HMS Room.
   */
  ;

  _proto.getStore = function getStore() {
    return this.store;
  }
  /**
   * Any action which may modify the store or may need to talk to the SDK will happen
   * through the IHMSActions instance returned by this
   */
  ;

  _proto.getHMSActions = function getHMSActions() {
    return this.actions;
  }
  /**
   * This return notification handler function to which you can pass your callback to
   * receive notifications like peer joined, peer left, etc. to show in your UI or use
   * for analytics
   */
  ;

  _proto.getNotifications = function getNotifications() {
    return {
      onNotification: this.notifications.onNotification
    };
  }
  /**
   * @internal
   */
  ;

  HMSReactiveStore.createNewHMSStore = function createNewHMSStore() {
    var hmsStore = create(function () {
      return createDefaultStoreState();
    }); // make set state immutable, by passing functions through immer

    var savedSetState = hmsStore.setState;

    hmsStore.setState = function (partial) {
      var nextState = typeof partial === 'function' ? produce(partial) : partial;
      savedSetState(nextState);
    }; // add option to pass selector to getState


    var prevGetState = hmsStore.getState; // eslint-disable-next-line complexity

    hmsStore.getState = function (selector) {
      if (selector) {
        var name = selector.name || 'byIDSelector'; // @ts-ignore

        if (!window.selectorsCount) {
          // @ts-ignore
          window.selectorsCount = {};
        } // @ts-ignore


        window.selectorsCount[name] = (window.selectorsCount[name] || 0) + 1;
        var start = performance.now();
        var updatedState = selector(prevGetState());
        var diff = performance.now() - start; // store selectors that take more than 1ms

        if (diff > 1) {
          // @ts-ignore
          window.expensiveSelectors = window.expensiveSelectors || new Map(); // @ts-ignore

          window.expensiveSelectors.set(name, diff);
        }

        return updatedState;
      }

      return prevGetState();
    };

    HMSReactiveStore.useShallowCheckInSubscribe(hmsStore);
    var namedSetState = HMSReactiveStore.setUpDevtools(hmsStore, 'HMSStore');
    return _extends({}, hmsStore, {
      namedSetState: namedSetState
    });
  }
  /**
   * @internal
   */
  ;

  HMSReactiveStore.makeStoreTriggerOnSubscribe = function makeStoreTriggerOnSubscribe(store) {
    var prevSubscribe = store.subscribe;

    store.subscribe = function (listener, selector, equalityFn) {
      // initial call, the prev state will always be null for this
      listener(store.getState(selector), undefined); // then subscribe

      return prevSubscribe(listener, selector, equalityFn);
    };
  }
  /**
   * use shallow equality check by default for subscribe to optimize for array/object selectors.
   * by default zustand does only reference matching so something like, getPeers for eg. would trigger
   * the corresponding component even if peers didn't actually change, as selectPeers creates a new array everytime.
   * Although the array reference changes, the order of peers and peer objects don't themselves change in this case,
   * and a shallow check avoids that triggering.
   * @private
   */
  ;

  HMSReactiveStore.useShallowCheckInSubscribe = function useShallowCheckInSubscribe(hmsStore) {
    var prevSubscribe = hmsStore.subscribe;

    hmsStore.subscribe = function (listener, selector, equalityFn) {
      if (!selector) {
        selector = function selector(store) {
          return store;
        };
      }

      equalityFn = equalityFn || shallow;
      return prevSubscribe(listener, selector, equalityFn);
    };
  }
  /**
   * @private
   * @privateRemarks
   * sets up redux devtools for the store, so redux extension can be used to visualize the store.
   * zustand's default devtool middleware only enhances the set function, we're here creating another nameSetState in
   * IHMStore which behaves like setState but takes an extra parameter for action name
   * https://github.com/zalmoxisus/redux-devtools-extension/blob/master/docs/API/Methods.md
   * modified version of zustand's devtools - https://github.com/pmndrs/zustand/blob/v3.5.7/src/middleware.ts#L46
   */
  ;

  HMSReactiveStore.setUpDevtools = function setUpDevtools(api, prefix) {
    var extension;

    try {
      extension = window.__REDUX_DEVTOOLS_EXTENSION__ || window.top.__REDUX_DEVTOOLS_EXTENSION__;
    } catch (_unused) {}

    if (!extension) {
      return function (fn) {
        api.setState(fn);
      };
    }

    var devtools = extension.connect(HMSReactiveStore.devtoolsOptions(prefix));
    devtools.prefix = prefix ? prefix + " > " : '';
    var savedSetState = api.setState;

    api.setState = function (fn) {
      savedSetState(fn);
      devtools.send(devtools.prefix + "setState", api.getState());
    };

    devtools.subscribe(HMSReactiveStore.devtoolsSubscribe(devtools, api, savedSetState));
    devtools.send('setUpStore', api.getState());
    return function (fn, action) {
      savedSetState(fn);
      var actionName = action ? action : devtools.prefix + "action";
      devtools.send(actionName, api.getState());
    };
  }
  /**
   * https://github.com/zalmoxisus/redux-devtools-extension/blob/master/docs/API/Arguments.md
   */
  ;

  HMSReactiveStore.devtoolsOptions = function devtoolsOptions(prefix) {
    return {
      name: prefix,
      actionsBlacklist: ['audioLevel', 'playlistProgress']
    };
  }
  /**
   * redux devtools allows for time travel debugging where it sends an action to update the store, users can
   * also export and import state in the devtools, listen to the corresponding functions from devtools and take
   * required action.
   * @param devtools - reference to devtools extension object
   * @param api
   * @param savedSetState - setState saved before its modified to update devtools
   * @private
   */
  ;

  HMSReactiveStore.devtoolsSubscribe = function devtoolsSubscribe(devtools, api, savedSetState) {
    // disabling complexity check instead of refactoring so as to keep the code close to zustand's and make
    // any future update based on upstream changes easier.
    // eslint-disable-next-line complexity
    return function (message) {
      var _message$payload, _message$payload2;

      if (message.type === 'DISPATCH' && message.state) {
        var ignoreState = ['JUMP_TO_ACTION', 'JUMP_TO_STATE'].includes(message.payload.type);

        if (!ignoreState) {
          // manual dispatch from the extension
          api.setState(JSON.parse(message.state));
        } else {
          // for time travel, no need to add new state changes in devtools
          savedSetState(JSON.parse(message.state));
        }
      } else if (message.type === 'DISPATCH' && ((_message$payload = message.payload) == null ? void 0 : _message$payload.type) === 'COMMIT') {
        devtools.init(api.getState());
      } else if (message.type === 'DISPATCH' && ((_message$payload2 = message.payload) == null ? void 0 : _message$payload2.type) === 'IMPORT_STATE') {
        var _message$payload$next, _message$payload$next2;

        var actions = (_message$payload$next = message.payload.nextLiftedState) == null ? void 0 : _message$payload$next.actionsById;
        var computedStates = ((_message$payload$next2 = message.payload.nextLiftedState) == null ? void 0 : _message$payload$next2.computedStates) || [];
        computedStates.forEach(function (_ref, index) {
          var state = _ref.state;
          var action = actions[index] || devtools.prefix + "setState";

          if (index === 0) {
            devtools.init(state);
          } else {
            savedSetState(state);
            devtools.send(action, api.getState());
          }
        });
      }
    };
  };

  return HMSReactiveStore;
}();

Object.defineProperty(exports, 'HMSLogLevel', {
  enumerable: true,
  get: function () {
    return sdkTypes.HMSLogLevel;
  }
});
Object.defineProperty(exports, 'HMSSimulcastLayer', {
  enumerable: true,
  get: function () {
    return sdkTypes.HMSSimulcastLayer;
  }
});
exports.HMSReactiveStore = HMSReactiveStore;
exports.createDefaultStoreState = createDefaultStoreState;
exports.selectAudioPlaylist = selectAudioPlaylist;
exports.selectAudioPlaylistTrackByPeerID = selectAudioPlaylistTrackByPeerID;
exports.selectAudioTrackByPeerID = selectAudioTrackByPeerID;
exports.selectAudioTrackVolume = selectAudioTrackVolume;
exports.selectAudioVolumeByPeerID = selectAudioVolumeByPeerID;
exports.selectAuxiliaryAudioByPeerID = selectAuxiliaryAudioByPeerID;
exports.selectAuxiliaryTracksByPeerID = selectAuxiliaryTracksByPeerID;
exports.selectAvailableRoleNames = selectAvailableRoleNames;
exports.selectBroadcastMessages = selectBroadcastMessages;
exports.selectBroadcastMessagesUnreadCount = selectBroadcastMessagesUnreadCount;
exports.selectCameraStreamByPeerID = selectCameraStreamByPeerID;
exports.selectDegradedTracks = selectDegradedTracks;
exports.selectDevices = selectDevices;
exports.selectDominantSpeaker = selectDominantSpeaker;
exports.selectHMSMessages = selectHMSMessages;
exports.selectHMSMessagesCount = selectHMSMessagesCount;
exports.selectIsAllowedToPublish = selectIsAllowedToPublish;
exports.selectIsAllowedToSubscribe = selectIsAllowedToSubscribe;
exports.selectIsAudioLocallyMuted = selectIsAudioLocallyMuted;
exports.selectIsConnectedToRoom = selectIsConnectedToRoom;
exports.selectIsInPreview = selectIsInPreview;
exports.selectIsLocalAudioEnabled = selectIsLocalAudioEnabled;
exports.selectIsLocalAudioPluginPresent = selectIsLocalAudioPluginPresent;
exports.selectIsLocalScreenShared = selectIsLocalScreenShared;
exports.selectIsLocalVideoDisplayEnabled = selectIsLocalVideoDisplayEnabled;
exports.selectIsLocalVideoEnabled = selectIsLocalVideoEnabled;
exports.selectIsLocalVideoPluginPresent = selectIsLocalVideoPluginPresent;
exports.selectIsLocallyMutedByPeerID = selectIsLocallyMutedByPeerID;
exports.selectIsPeerAudioEnabled = selectIsPeerAudioEnabled;
exports.selectIsPeerVideoEnabled = selectIsPeerVideoEnabled;
exports.selectIsScreenShareLocallyMutedByPeerID = selectIsScreenShareLocallyMutedByPeerID;
exports.selectIsSomeoneScreenSharing = selectIsSomeoneScreenSharing;
exports.selectLocalAudioTrackID = selectLocalAudioTrackID;
exports.selectLocalMediaSettings = selectLocalMediaSettings;
exports.selectLocalPeer = selectLocalPeer;
exports.selectLocalPeerID = selectLocalPeerID;
exports.selectLocalPeerRole = selectLocalPeerRole;
exports.selectLocalTrackIDs = selectLocalTrackIDs;
exports.selectLocalVideoTrackID = selectLocalVideoTrackID;
exports.selectMessageIDsInOrder = selectMessageIDsInOrder;
exports.selectMessagesByPeerID = selectMessagesByPeerID;
exports.selectMessagesByRole = selectMessagesByRole;
exports.selectMessagesMap = selectMessagesMap;
exports.selectMessagesUnreadCountByPeerID = selectMessagesUnreadCountByPeerID;
exports.selectMessagesUnreadCountByRole = selectMessagesUnreadCountByRole;
exports.selectPeerAudioByID = selectPeerAudioByID;
exports.selectPeerByID = selectPeerByID;
exports.selectPeerCount = selectPeerCount;
exports.selectPeerNameByID = selectPeerNameByID;
exports.selectPeerScreenSharing = selectPeerScreenSharing;
exports.selectPeerSharingAudio = selectPeerSharingAudio;
exports.selectPeerSharingVideoPlaylist = selectPeerSharingVideoPlaylist;
exports.selectPeers = selectPeers;
exports.selectPeersMap = selectPeersMap;
exports.selectPeersScreenSharing = selectPeersScreenSharing;
exports.selectPeersWithAudioStatus = selectPeersWithAudioStatus;
exports.selectPermissions = selectPermissions;
exports.selectRTMPState = selectRTMPState;
exports.selectRecordingState = selectRecordingState;
exports.selectRemotePeers = selectRemotePeers;
exports.selectRoleByRoleName = selectRoleByRoleName;
exports.selectRoleChangeRequest = selectRoleChangeRequest;
exports.selectRolesMap = selectRolesMap;
exports.selectRoom = selectRoom;
exports.selectRoomStarted = selectRoomStarted;
exports.selectRoomState = selectRoomState;
exports.selectScreenShareAudioByPeerID = selectScreenShareAudioByPeerID;
exports.selectScreenShareByPeerID = selectScreenShareByPeerID;
exports.selectScreenSharesByPeerId = selectScreenSharesByPeerId;
exports.selectScreenshareAudioVolumeByPeerID = selectScreenshareAudioVolumeByPeerID;
exports.selectSimulcastLayerByTrack = selectSimulcastLayerByTrack;
exports.selectSpeakers = selectSpeakers;
exports.selectTrackAudioByID = selectTrackAudioByID;
exports.selectTrackByID = selectTrackByID;
exports.selectTracksMap = selectTracksMap;
exports.selectUnreadHMSMessagesCount = selectUnreadHMSMessagesCount;
exports.selectVideoPlaylist = selectVideoPlaylist;
exports.selectVideoPlaylistAudioTrackByPeerID = selectVideoPlaylistAudioTrackByPeerID;
exports.selectVideoPlaylistVideoTrackByPeerID = selectVideoPlaylistVideoTrackByPeerID;
exports.selectVideoTrackByPeerID = selectVideoTrackByPeerID;
//# sourceMappingURL=hms-video-store.cjs.development.js.map
