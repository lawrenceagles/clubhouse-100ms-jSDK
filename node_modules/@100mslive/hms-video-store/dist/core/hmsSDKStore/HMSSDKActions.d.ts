import { HMSMessage, HMSTrackID, HMSTrackSource, HMSChangeMultiTrackStateParams, IHMSPlaylistActions } from '../schema';
import { IHMSActions } from '../IHMSActions';
import * as sdkTypes from './sdkTypes';
import { HMSRoleChangeRequest } from '../selectors';
import { HMSAudioPlugin, HMSException as SDKHMSException, HMSLogLevel, HMSChangeTrackStateRequest as SDKHMSChangeTrackStateRequest, HMSChangeMultiTrackStateRequest as SDKHMSChangeMultiTrackStateRequest, HMSSdk, HMSSimulcastLayer, HMSTrack as SDKHMSTrack, HMSVideoPlugin } from '@100mslive/hms-video';
import { IHMSStore } from '../IHMSStore';
import { HMSNotifications } from './HMSNotifications';
/**
 * This class implements the IHMSActions interface for 100ms SDK. It connects with SDK
 * and takes control of data management by letting every action pass through it. The
 * passed in store is ensured to be the single source of truth reflecting current
 * room related data at any point in time.
 *
 * @privateRemarks
 * Things to keep in mind while updating store -
 * 1. Treat setState as an atomic operation, if an action results in multiple changes,
 *    the changes should all happen within single setState function.
 * 2. While updating the state it's very important to not update the reference if
 *    something is unchanged. Copy data in same reference object don't assign new
 *    object.
 * 3. Mental Model(1) - Actions from backend -> Listeners of this class -> update store -> views update themselves
 *    eg. for this - peer added, remote muted etc.
 * 4. Mental Model(2) - Actions from local -> View calls actions -> update store -> views update themselves
 *    eg. local track enabled, join, leave etc.
 * 5. State is immutable, a new copy with new references is created when there is a change,
 *    if you try to modify state outside of setState, there'll be an error.
 */
export declare class HMSSDKActions implements IHMSActions {
    private hmsSDKTracks;
    private hmsSDKPeers;
    private readonly sdk;
    private readonly store;
    private isRoomJoinCalled;
    private hmsNotifications;
    audioPlaylist: IHMSPlaylistActions;
    videoPlaylist: IHMSPlaylistActions;
    constructor(store: IHMSStore, sdk: HMSSdk, notificationManager: HMSNotifications);
    unblockAudio(): Promise<void>;
    setVolume(value: number, trackId?: HMSTrackID): void;
    setAudioOutputDevice(deviceId: string): void;
    setPreferredLayer(trackId: string, layer: HMSSimulcastLayer): void;
    preview(config: sdkTypes.HMSConfig): Promise<void>;
    join(config: sdkTypes.HMSConfig): void;
    leave(): Promise<void>;
    setScreenShareEnabled(enabled: boolean, audioOnly?: boolean): Promise<void>;
    addTrack(track: MediaStreamTrack, type?: HMSTrackSource): Promise<void>;
    removeTrack(trackId: string): Promise<void>;
    setLocalAudioEnabled(enabled: boolean): Promise<void>;
    setLocalVideoEnabled(enabled: boolean): Promise<void>;
    setEnabledTrack(trackID: string, enabled: boolean): Promise<void>;
    setAudioSettings(settings: Partial<sdkTypes.HMSAudioTrackSettings>): Promise<void>;
    setVideoSettings(settings: Partial<sdkTypes.HMSVideoTrackSettings>): Promise<void>;
    sendMessage(message: string): void;
    sendBroadcastMessage(message: string, type?: string): Promise<void>;
    sendGroupMessage(message: string, roles: string[], type?: string): Promise<void>;
    sendDirectMessage(message: string, peerID: string, type?: string): Promise<void>;
    private updateMessageInStore;
    setMessageRead(readStatus: boolean, messageId?: string): void;
    attachVideo(trackID: string, videoElement: HTMLVideoElement): Promise<void>;
    detachVideo(trackID: string, videoElement: HTMLVideoElement): Promise<void>;
    addPluginToVideoTrack(plugin: HMSVideoPlugin, pluginFrameRate?: number): Promise<void>;
    addPluginToAudioTrack(plugin: HMSAudioPlugin): Promise<void>;
    removePluginFromVideoTrack(plugin: HMSVideoPlugin): Promise<void>;
    removePluginFromAudioTrack(plugin: HMSAudioPlugin): Promise<void>;
    changeRole(forPeerId: string, toRole: string, force?: boolean): Promise<void>;
    acceptChangeRole(request: HMSRoleChangeRequest): Promise<void>;
    /**
     * @privateRemarks
     * there is no corresponding sdk method for rejecting change role but as the store also maintains the full
     * state of current pending requests, this method allows it to clean up when the request is rejected
     */
    rejectChangeRole(request: HMSRoleChangeRequest): void;
    endRoom(lock: boolean, reason: string): Promise<void>;
    removePeer(peerID: string, reason: string): Promise<void>;
    startRTMPOrRecording(params: sdkTypes.RTMPRecordingConfig): Promise<void>;
    stopRTMPAndRecording(): Promise<void>;
    setRemoteTrackEnabled(trackID: HMSTrackID | HMSTrackID[], enabled: boolean): Promise<void>;
    setRemoteTracksEnabled(params: HMSChangeMultiTrackStateParams): Promise<void>;
    setLogLevel(level: HMSLogLevel): void;
    private resetState;
    private sdkJoinWithListeners;
    private onRemovedFromRoom;
    private onDeviceChange;
    private sdkPreviewWithListeners;
    private startScreenShare;
    private stopScreenShare;
    private attachVideoInternal;
    /**
     * This is a very important function as it's responsible for maintaining the source of
     * truth with maximum efficiency. The efficiency comes from the fact that the only
     * those portions of the store are updated which have actually changed.
     * While making a change in this function don't use functions like map, reduce etc.
     * which return a new copy of the data. Use Object.assign etc. to ensure that if the data
     * doesn't change reference is also not changed.
     * The UI and selectors rely on the fact that the store is immutable that is if there is
     * any change and only if there is a change, they'll get a new copy of the data they're
     * interested in with a new reference.
     * @protected
     */
    protected syncRoomState(action?: string): void;
    protected onPreview(sdkRoom: sdkTypes.HMSRoom): void;
    protected onJoin(sdkRoom: sdkTypes.HMSRoom): void;
    protected onRoomUpdate(type: sdkTypes.HMSRoomUpdate, room: sdkTypes.HMSRoom): void;
    protected onPeerUpdate(type: sdkTypes.HMSPeerUpdate, sdkPeer: sdkTypes.HMSPeer | sdkTypes.HMSPeer[]): void;
    protected onTrackUpdate(type: sdkTypes.HMSTrackUpdate, track: SDKHMSTrack, peer: sdkTypes.HMSPeer): void;
    protected onMessageReceived(sdkMessage: sdkTypes.HMSMessage): void;
    protected onHMSMessage(hmsMessage: HMSMessage): void;
    protected onAudioLevelUpdate(sdkSpeakers: sdkTypes.HMSSpeaker[]): void;
    protected onChangeTrackStateRequest(request: SDKHMSChangeTrackStateRequest): void;
    protected onChangeMultiTrackStateRequest(request: SDKHMSChangeMultiTrackStateRequest): void;
    protected onReconnected(): void;
    protected onReconnecting(sdkError: SDKHMSException): void;
    protected onError(sdkException: SDKHMSException): void;
    /**
     * the layer gets updated on addsink/removesink/preferlayer calls, for simulcast there
     * can be multiple layers, while for non simulcast there will be None and High.
     */
    private updateVideoLayer;
    private handleTrackRemove;
    private setEnabledSDKTrack;
    private setSDKLocalVideoTrackSettings;
    private setSDKLocalAudioTrackSettings;
    private getMediaSettings;
    private setTrackVolume;
    /**
     * Tells if the trackID is for local peer and video unmute is in process
     * @private
     */
    private localAndVideoUnmuting;
    private logPossibleInconsistency;
    private addRemoveVideoPlugin;
    private addRemoveAudioPlugin;
    /**
     * In case of replace track id is changed but not in store. Given the store id, check the real id
     * sdk is using to refer to the track and match them.
     */
    private isSameStoreSDKTrack;
    /**
     * convert new role change requests to store format and save.
     * keep only one request at a time in store till we figure out how to handle multiple requests at the same time
     */
    private onRoleChangeRequest;
    private removeRoleChangeRequest;
    private onRoleUpdate;
    private getStoreLocalTrackIDfromSDKTrack;
    private setProgress;
    private syncPlaylistState;
    private sendPeerUpdateNotification;
    /**
     * setState is separate so any future changes to how state change can be done from one place.
     * @param fn
     * @param name
     */
    private setState;
}
