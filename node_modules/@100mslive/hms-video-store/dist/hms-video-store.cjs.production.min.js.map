{"version":3,"file":"hms-video-store.cjs.production.min.js","sources":["../src/core/schema/room.ts","../node_modules/regenerator-runtime/runtime.js","../src/core/schema/notification.ts","../src/core/schema/playlist.ts","../src/core/schema/schema.ts","../src/core/schema/message.ts","../src/core/hmsSDKStore/sdkUtils/storeMergeUtils.ts","../src/core/hmsSDKStore/adapter.ts","../src/core/selectors/selectorUtils.ts","../src/core/selectors/selectors.ts","../src/core/selectors/playlistselectors.ts","../src/common/ui-logger.ts","../src/core/selectors/selectorsByID.ts","../src/core/selectors/derivedSelectors.ts","../src/core/selectors/selectorsByReference.ts","../src/core/hmsSDKStore/sdkUtils/sdkUtils.ts","../src/core/hmsSDKStore/HMSPlaylist.ts","../src/core/hmsSDKStore/HMSSDKActions.ts","../src/core/hmsSDKStore/common/mapping.ts","../src/core/hmsSDKStore/HMSNotifications.ts","../src/core/hmsSDKStore/HMSReactiveStore.ts"],"sourcesContent":["import { HMSRecording, HMSRTMP } from '@100mslive/hms-video';\nimport { HMSPeerID } from './peer';\n\nexport type HMSRoomID = string;\n\nexport enum HMSRoomState {\n  Disconnected = 'Disconnected',\n  Preview = 'Preview',\n  Connecting = 'Connecting',\n  Connected = 'Connected',\n  Reconnecting = 'Reconnecting',\n  Failed = 'Failed',\n}\n\nexport interface HMSRoom {\n  id: HMSRoomID;\n  name: string;\n  isConnected?: boolean;\n  peers: HMSPeerID[];\n  localPeer: HMSPeerID;\n  shareableLink: string;\n  hasWaitingRoom: boolean;\n  roomState: HMSRoomState;\n  recording: HMSRecording;\n  rtmp: HMSRTMP;\n}\n","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, \"\");\n  } catch (err) {\n    define = function(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  define(IteratorPrototype, iteratorSymbol, function () {\n    return this;\n  });\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = GeneratorFunctionPrototype;\n  define(Gp, \"constructor\", GeneratorFunctionPrototype);\n  define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction);\n  GeneratorFunction.displayName = define(\n    GeneratorFunctionPrototype,\n    toStringTagSymbol,\n    \"GeneratorFunction\"\n  );\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      define(prototype, method, function(arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {\n    return this;\n  });\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  define(Gp, toStringTagSymbol, \"Generator\");\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  define(Gp, iteratorSymbol, function() {\n    return this;\n  });\n\n  define(Gp, \"toString\", function() {\n    return \"[object Generator]\";\n  });\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, in modern engines\n  // we can explicitly access globalThis. In older engines we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  if (typeof globalThis === \"object\") {\n    globalThis.regeneratorRuntime = runtime;\n  } else {\n    Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n  }\n}\n","export interface HMSNotification {\n  id: number;\n  type: string;\n  message: string;\n  /**\n   * HMSPeer | HMSTrack | HMSMessage | HMSException\n   */\n  data?: any;\n  severity?: HMSNotificationSeverity;\n}\nexport enum HMSNotificationSeverity {\n  INFO = 'info',\n  ERROR = 'error',\n  CRITICAL = 'critical',\n}\n\nexport enum HMSNotificationTypes {\n  PEER_JOINED = 'PEER_JOINED',\n  PEER_LEFT = 'PEER_LEFT',\n  PEER_LIST = 'PEER_LIST',\n  NEW_MESSAGE = 'NEW_MESSAGE',\n  ERROR = 'ERROR',\n  RECONNECTING = 'RECONNECTING',\n  RECONNECTED = 'RECONNECTED',\n  TRACK_ADDED = 'TRACK_ADDED',\n  TRACK_REMOVED = 'TRACK_REMOVED',\n  TRACK_MUTED = 'TRACK_MUTED',\n  TRACK_UNMUTED = 'TRACK_UNMUTED',\n  ROLE_CHANGE_REQUEST = 'ROLE_CHANGE_REQUEST',\n  ROLE_UPDATED = 'ROLE_UPDATED',\n  CHANGE_TRACK_STATE_REQUEST = 'CHANGE_TRACK_STATE_REQUEST',\n  CHANGE_MULTI_TRACK_STATE_REQUEST = 'CHANGE_MULTI_TRACK_STATE_REQUEST',\n  ROOM_ENDED = 'ROOM_ENDED',\n  REMOVED_FROM_ROOM = 'REMOVED_FROM_ROOM',\n  DEVICE_CHANGE_UPDATE = 'DEVICE_CHANGE_UPDATE',\n}\n","import { HMSStore } from '../schema';\n\nexport enum HMSPlaylistType {\n  audio = 'audio',\n  video = 'video',\n}\nexport interface HMSPlaylistItem<T> {\n  name: string;\n  id: string;\n  metadata?: T;\n  url: string;\n  type: HMSPlaylistType;\n  duration?: number;\n  playing: boolean;\n  selected: boolean;\n}\n\nexport interface HMSPlaylistSelection {\n  id: string;\n  hasPrevious: boolean;\n  hasNext: boolean;\n}\n\nexport interface HMSPlaylist<T> {\n  audio: {\n    list: Record<string, HMSPlaylistItem<T>>;\n    selection: HMSPlaylistSelection;\n    progress: number;\n    volume: number;\n    currentTime: number;\n  };\n  video: {\n    list: Record<string, HMSPlaylistItem<T>>;\n    selection: HMSPlaylistSelection;\n    progress: number;\n    volume: number;\n    currentTime: number;\n  };\n}\n\nexport interface IHMSPlaylistActions {\n  /**\n   * Pass the id of the item to be played\n   * @param {string} id - id of playlist item\n   */\n  play(id: string): Promise<void>;\n  /**\n   * Pauses current playing item\n   */\n  pause(): Promise<void>;\n  /**\n   * PlayNext\n   */\n  playNext(): Promise<void>;\n  /**\n   * PlayPrevious\n   */\n  playPrevious(): Promise<void>;\n  /**\n   * seek passing seekValue - this is relative to current position\n   * @param {number} seekValue - number in seconds to move forwards(pass negative values to move backwards)\n   */\n  seek(seekValue: number): void;\n  /**\n   * seek passing seekValue  - seekValue will be absolute\n   * @param {number} seekValue - value in seconds of absolute position in the playlist item duration\n   */\n  seekTo(seekValue: number): void;\n  /**\n   * set volume passing volume\n   * @param {number} volume - number between 0-100\n   */\n  setVolume(volume: number): void;\n  /**\n   * pass list to set playlist\n   * @param {HMSPlaylistItem[]} - list of playlist items\n   */\n  setList<T>(list: HMSPlaylistItem<T>[]): void;\n  /**\n   * Stop the current playback and remove the tracks\n   */\n  stop(): Promise<void>;\n}\n\nexport interface HMSPlaylistSelector {\n  list: <T>(store: HMSStore) => HMSPlaylistItem<T>[];\n  /**\n   * This returns playlist selection with id, hasNext, hasPrev\n   * @returns {HMSPlaylistSelection}\n   */\n  selection: (store: HMSStore) => HMSPlaylistSelection;\n  /**\n   * This returns playlist item for corresponding Id in selection\n   * @returns {HMSPlaylistItem}\n   */\n  selectedItem: <T>(store: HMSStore) => HMSPlaylistItem<T>;\n  progress: (store: HMSStore) => number;\n  volume: (store: HMSStore) => number;\n  currentTime: (store: HMSStore) => number;\n}\n","import { HMSPeer, HMSPeerID, HMSTrackID, HMSTrack, HMSSpeaker } from './peer';\nimport { HMSMessage, HMSMessageID } from './message';\nimport { HMSRoom, HMSRoomState } from './room';\nimport { HMSMediaSettings } from './settings';\nimport { DeviceMap } from '../hmsSDKStore/sdkTypes';\nimport { HMSRole } from './role';\nimport { HMSRoleChangeStoreRequest } from './requests';\nimport { HMSException } from './error';\nimport { HMSPlaylist } from './playlist';\n\n/*\n * Defines the schema of the central store. UI Components are aware of the presence\n * of this central store. This is the global state - the single source of immutable truth.\n */\nexport interface HMSStore {\n  room: HMSRoom;\n  peers: Record<HMSPeerID, HMSPeer>;\n  speakers: Record<HMSTrackID, HMSSpeaker>;\n  tracks: Record<HMSTrackID, HMSTrack>;\n  playlist: HMSPlaylist<any>;\n  messages: {\n    byID: Record<HMSMessageID, HMSMessage>;\n    allIDs: HMSMessageID[];\n  };\n  settings: HMSMediaSettings;\n  devices: DeviceMap;\n  roles: Record<string, HMSRole>;\n  roleChangeRequests: HMSRoleChangeStoreRequest[];\n  errors: HMSException[]; // for the convenience of debugging and seeing any error in devtools\n}\n\n/**\n * @internal\n */\nexport const createDefaultStoreState = (): HMSStore => {\n  return {\n    room: {\n      id: '',\n      isConnected: false,\n      name: '',\n      peers: [],\n      shareableLink: '',\n      localPeer: '',\n      hasWaitingRoom: false,\n      roomState: HMSRoomState.Disconnected,\n      recording: {\n        browser: {\n          running: false,\n        },\n        server: {\n          running: false,\n        },\n      },\n      rtmp: {\n        running: false,\n      },\n    },\n    peers: {},\n    tracks: {},\n    playlist: {\n      audio: {\n        list: {},\n        selection: { id: '', hasPrevious: false, hasNext: false },\n        progress: 0,\n        volume: 0,\n        currentTime: 0,\n      },\n      video: {\n        list: {},\n        selection: { id: '', hasPrevious: false, hasNext: false },\n        progress: 0,\n        volume: 0,\n        currentTime: 0,\n      },\n    },\n    messages: { byID: {}, allIDs: [] },\n    speakers: {},\n    settings: {\n      audioInputDeviceId: '',\n      audioOutputDeviceId: '',\n      videoInputDeviceId: '',\n    },\n    devices: {\n      audioInput: [],\n      audioOutput: [],\n      videoInput: [],\n    },\n    roles: {},\n    roleChangeRequests: [],\n    errors: [],\n  };\n};\n","import { HMSPeerID } from './peer';\nimport { HMSRoleName } from './role';\n\nexport type HMSMessageID = string;\n\n/**\n * @internal\n */\nexport enum HMSMessageType {\n  CHAT = 'chat',\n}\n\nexport interface HMSMessage {\n  id: HMSMessageID;\n  sender: HMSPeerID;\n  senderName: string;\n  senderUserId?: string;\n  senderRole?: string;\n  recipientPeer?: HMSPeerID;\n  recipientRoles?: HMSRoleName[];\n  time: Date;\n  read: boolean;\n  type: string;\n  message: any;\n}\n\n/**\n * @internal\n */\nexport interface HMSMessageInput {\n  recipientPeer?: HMSPeerID;\n  recipientRoles?: HMSRoleName[];\n  type?: string;\n  message: any;\n}\n","import { HMSPeer, HMSPeerID, HMSTrack, HMSTrackID } from '../../schema';\n\n/**\n * updates draftPeers with newPeers ensuring minimal reference changes\n * @remarks\n * This is mutable and impure function, it modifies the passed in data to ensure\n * minimal reference changes\n * @param draftPeers the current peers object in store, an immer draft object\n * @param newPeers the latest update which needs to be stored\n * @param newHmsTracks this will be update if required\n * @param newHmsSDkTracks this is future value of local hms tacks map\n */\nexport const mergeNewPeersInDraft = (\n  draftPeers: Record<HMSPeerID, HMSPeer>,\n  newPeers: Record<HMSPeerID, Partial<HMSPeer>>,\n) => {\n  const peerIDs = union(Object.keys(draftPeers), Object.keys(newPeers));\n  for (let peerID of peerIDs) {\n    const oldPeer = draftPeers[peerID];\n    const newPeer = newPeers[peerID];\n    if (isEntityUpdated(oldPeer, newPeer)) {\n      if (areArraysEqual(oldPeer.auxiliaryTracks, newPeer.auxiliaryTracks)) {\n        newPeer.auxiliaryTracks = oldPeer.auxiliaryTracks;\n      }\n      Object.assign(oldPeer, newPeer);\n    } else if (isEntityRemoved(oldPeer, newPeer)) {\n      delete draftPeers[peerID];\n    } else if (isEntityAdded(oldPeer, newPeer)) {\n      draftPeers[peerID] = newPeer as HMSPeer;\n    }\n  }\n};\n\nexport const mergeNewTracksInDraft = (\n  draftTracks: Record<HMSTrackID, HMSTrack>,\n  newTracks: Record<HMSTrackID, Partial<HMSTrack>>,\n) => {\n  const trackIDs = union(Object.keys(draftTracks), Object.keys(newTracks));\n  for (let trackID of trackIDs) {\n    const oldTrack = draftTracks[trackID];\n    const newTrack = newTracks[trackID];\n    if (isEntityUpdated(oldTrack, newTrack)) {\n      mergeTrackArrayFields(oldTrack, newTrack);\n      Object.assign(oldTrack, newTrack);\n    } else if (isEntityRemoved(oldTrack, newTrack)) {\n      delete draftTracks[trackID];\n    } else if (isEntityAdded(oldTrack, newTrack)) {\n      draftTracks[trackID] = newTrack as HMSTrack;\n    }\n  }\n};\n\n/**\n * array's are usually created with new reference, avoid that update if both arrays are same\n */\nconst mergeTrackArrayFields = (oldTrack: HMSTrack, newTrack: Partial<HMSTrack>) => {\n  if (oldTrack.plugins && areArraysEqual(oldTrack.plugins, newTrack.plugins)) {\n    newTrack.plugins = oldTrack.plugins;\n  }\n  if (\n    oldTrack.layerDefinitions &&\n    areArraysEqual(oldTrack.layerDefinitions, newTrack.layerDefinitions)\n  ) {\n    newTrack.layerDefinitions = oldTrack.layerDefinitions;\n  }\n};\n\nconst isEntityUpdated = <T>(oldItem: T, newItem: T) => oldItem && newItem;\nconst isEntityRemoved = <T>(oldItem: T, newItem: T) => oldItem && !newItem;\nconst isEntityAdded = <T>(oldItem: T, newItem: T) => !oldItem && newItem;\n\n// eslint-disable-next-line complexity\nexport const areArraysEqual = <T>(arr1: T[], arr2?: T[]): boolean => {\n  if (arr1 === arr2 || (arr1.length === 0 && arr2?.length === 0)) {\n    // reference check\n    return true;\n  }\n  if (!arr1 || !arr2 || !(arr1.length === arr2.length)) {\n    return false;\n  }\n  for (let i = 0; i < arr1.length; i++) {\n    if (arr1[i] !== arr2[i]) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst union = <T>(arr1: T[], arr2: T[]): T[] => {\n  const set: Set<T> = new Set();\n  for (let elem of arr1) {\n    set.add(elem);\n  }\n  for (let elem of arr2) {\n    set.add(elem);\n  }\n  return Array.from(set);\n};\n","import {\n  HMSLocalAudioTrack as SDKHMSLocalAudioTrack,\n  HMSLocalVideoTrack as SDKHMSLocalVideoTrack,\n  HMSRemoteAudioTrack as SDKHMSRemoteAudioTrack,\n  HMSRemoteVideoTrack as SDKHMSRemoteVideoTrack,\n  HMSRoleChangeRequest as SDKHMSRoleChangeRequest,\n  HMSTrack as SDKHMSTrack,\n} from '@100mslive/hms-video';\nimport {\n  HMSDeviceChangeEvent,\n  HMSException,\n  HMSMessage,\n  HMSPeer,\n  HMSPeerID,\n  HMSPlaylistItem,\n  HMSPlaylistType,\n  HMSRole,\n  HMSRoleChangeStoreRequest,\n  HMSRoleName,\n  HMSRoom,\n  HMSTrack,\n} from '../schema';\n\nimport * as sdkTypes from './sdkTypes';\nimport { areArraysEqual } from './sdkUtils/storeMergeUtils';\n\nexport class SDKToHMS {\n  static convertPeer(sdkPeer: sdkTypes.HMSPeer): Partial<HMSPeer> & Pick<HMSPeer, 'id'> {\n    return {\n      id: sdkPeer.peerId,\n      name: sdkPeer.name,\n      roleName: sdkPeer.role?.name,\n      isLocal: sdkPeer.isLocal,\n      videoTrack: sdkPeer.videoTrack?.trackId,\n      audioTrack: sdkPeer.audioTrack?.trackId,\n      auxiliaryTracks: sdkPeer.auxiliaryTracks.map(track => track.trackId),\n      customerUserId: sdkPeer.customerUserId,\n      customerDescription: sdkPeer.customerDescription,\n    };\n  }\n\n  static convertTrack(sdkTrack: SDKHMSTrack, peerId?: HMSPeerID): HMSTrack {\n    const track: HMSTrack = {\n      id: sdkTrack.trackId,\n      source: sdkTrack.source,\n      type: sdkTrack.type,\n      enabled: sdkTrack.enabled,\n      displayEnabled: sdkTrack.enabled,\n      peerId: sdkTrack.peerId || peerId,\n    };\n    this.enrichTrack(track, sdkTrack);\n    return track;\n  }\n\n  static enrichTrack(track: HMSTrack, sdkTrack: SDKHMSTrack) {\n    const mediaSettings = sdkTrack.getMediaTrackSettings();\n    if (track.source === 'screen' && track.type === 'video') {\n      // @ts-ignore\n      track.displaySurface = mediaSettings.displaySurface;\n    }\n    track.height = mediaSettings.height;\n    track.width = mediaSettings.width;\n    track.deviceID = mediaSettings.deviceId;\n    if (sdkTrack instanceof SDKHMSRemoteAudioTrack) {\n      track.volume = sdkTrack.getVolume() || 0;\n    }\n    SDKToHMS.enrichVideoTrack(track, sdkTrack);\n    SDKToHMS.enrichPluginsDetails(track, sdkTrack);\n  }\n\n  static enrichVideoTrack(track: HMSTrack, sdkTrack: SDKHMSTrack) {\n    if (sdkTrack instanceof SDKHMSRemoteVideoTrack) {\n      track.layer = sdkTrack.getSimulcastLayer();\n      track.degraded = sdkTrack.degraded;\n      if (!areArraysEqual(sdkTrack.getSimulcastDefinitions(), track.layerDefinitions)) {\n        track.layerDefinitions = sdkTrack.getSimulcastDefinitions();\n      }\n    }\n  }\n\n  static enrichPluginsDetails(track: HMSTrack, sdkTrack: SDKHMSTrack) {\n    if (sdkTrack instanceof SDKHMSLocalVideoTrack || sdkTrack instanceof SDKHMSLocalAudioTrack) {\n      if (!areArraysEqual(sdkTrack.getPlugins(), track.plugins)) {\n        track.plugins = sdkTrack.getPlugins();\n      }\n    }\n  }\n\n  static convertRoom(sdkRoom: sdkTypes.HMSRoom): Partial<HMSRoom> {\n    return {\n      id: sdkRoom.id,\n      name: sdkRoom.name,\n      localPeer: sdkRoom.localPeer?.peerId ?? '',\n      hasWaitingRoom: sdkRoom.hasWaitingRoom,\n      shareableLink: sdkRoom.shareableLink,\n      recording: {\n        browser: {\n          running: !!sdkRoom.recording?.browser.running,\n        },\n        server: { running: !!sdkRoom.recording?.server.running },\n      },\n      rtmp: { running: !!sdkRoom.rtmp?.running },\n    };\n  }\n\n  static convertMessage(\n    sdkMessage: sdkTypes.HMSMessage,\n  ): Partial<HMSMessage> & Pick<HMSMessage, 'sender'> {\n    return {\n      sender: sdkMessage.sender.peerId,\n      senderName: sdkMessage.sender.name,\n      senderRole: sdkMessage.sender.role?.name,\n      senderUserId: sdkMessage.sender.customerUserId,\n      recipientPeer: sdkMessage.recipientPeer?.peerId,\n      recipientRoles: sdkMessage.recipientRoles?.map(role => role.name),\n      time: sdkMessage.time,\n      type: sdkMessage.type,\n      message: sdkMessage.message,\n    };\n  }\n\n  static convertRoles(sdkRoles: HMSRole[]): Record<HMSRoleName, HMSRole> {\n    const roles: Record<HMSRoleName, HMSRole> = {};\n    if (sdkRoles) {\n      sdkRoles.forEach(role => {\n        roles[role.name] = role;\n      });\n    }\n    return roles;\n  }\n\n  static convertRoleChangeRequest(req: SDKHMSRoleChangeRequest): HMSRoleChangeStoreRequest {\n    return {\n      requestedBy: req.requestedBy.peerId,\n      roleName: req.role.name,\n      token: req.token,\n    };\n  }\n\n  static convertException(sdkException: sdkTypes.HMSException): HMSException {\n    return {\n      code: sdkException.code,\n      action: sdkException.action,\n      name: sdkException.name,\n      message: sdkException.message,\n      description: sdkException.description,\n      isTerminal: sdkException.isTerminal,\n      nativeError: sdkException.nativeError,\n      timestamp: new Date(),\n    };\n  }\n\n  static convertDeviceChangeUpdate(\n    sdkDeviceChangeEvent: sdkTypes.HMSDeviceChangeEvent,\n  ): HMSDeviceChangeEvent {\n    const convertedData: HMSDeviceChangeEvent = {\n      devices: sdkDeviceChangeEvent.devices,\n      selection: sdkDeviceChangeEvent.selection,\n      type: sdkDeviceChangeEvent.type,\n    };\n    if (sdkDeviceChangeEvent.error) {\n      convertedData.error = this.convertException(sdkDeviceChangeEvent.error);\n    }\n    return convertedData;\n  }\n\n  static convertPlaylist(playlistManager: sdkTypes.HMSPlaylistManager) {\n    const audioPlaylist = this.getConvertedPlaylistType(playlistManager, HMSPlaylistType.audio);\n    const videoPlaylist = this.getConvertedPlaylistType(playlistManager, HMSPlaylistType.video);\n    return { audio: audioPlaylist, video: videoPlaylist };\n  }\n\n  private static getConvertedPlaylistType(\n    playlistManager: sdkTypes.HMSPlaylistManager,\n    type: HMSPlaylistType,\n  ) {\n    const convertedPlaylist: Record<string, HMSPlaylistItem<any>> = {};\n    const currentSelection = playlistManager.getCurrentSelection(type);\n    const progress = playlistManager.getCurrentProgress(type);\n    const isPlaying = playlistManager.isPlaying(type);\n    const volume = playlistManager.getVolume(type);\n    const list = playlistManager.getList(type);\n    const currentIndex = playlistManager.getCurrentIndex(type);\n\n    playlistManager.getList(type).forEach(playlistItem => {\n      const isSelected = playlistItem.url === currentSelection?.url;\n      convertedPlaylist[playlistItem.id] = {\n        ...playlistItem,\n        type: playlistItem.type as HMSPlaylistType,\n        selected: isSelected,\n        playing: isSelected && isPlaying,\n      };\n    });\n    return {\n      list: convertedPlaylist,\n      selection: {\n        id: currentSelection?.id,\n        hasPrevious: currentIndex > 0,\n        hasNext: currentIndex < list.length - 1,\n      },\n      progress,\n      volume,\n      currentTime: playlistManager.getCurrentTime(type),\n    };\n  }\n\n  static convertRecordingRTMPState(\n    recording: sdkTypes.HMSRecording | undefined,\n    rtmp: sdkTypes.HMSRTMP | undefined,\n  ): { recording: sdkTypes.HMSRecording; rtmp: sdkTypes.HMSRTMP } {\n    return {\n      recording: {\n        browser: {\n          running: !!recording?.browser?.running,\n        },\n        server: { running: !!recording?.server?.running },\n      },\n      rtmp: { running: !!rtmp?.running },\n    };\n  }\n}\n","import { HMSPeer, HMSStore, HMSTrack, HMSTrackID } from '../schema';\n\ntype trackCheck = (track: HMSTrack | undefined) => boolean | undefined;\n\nexport function getPeerTracksByCondition(\n  tracks: Record<HMSTrackID, HMSTrack>,\n  peer: HMSPeer | null,\n  trackCheckFn: trackCheck = isScreenShare,\n) {\n  let videoTrack = undefined;\n  let audioTrack = undefined;\n  if (peer) {\n    for (let trackID of peer.auxiliaryTracks) {\n      const track = tracks[trackID];\n      if (trackCheckFn(track)) {\n        audioTrack = isAudio(track) ? track : audioTrack;\n        videoTrack = isVideo(track) ? track : videoTrack;\n      }\n    }\n  }\n  return { video: videoTrack, audio: audioTrack };\n}\n\nexport function isAudio(track: HMSTrack | undefined) {\n  return track && track.type === 'audio';\n}\n\nexport function isVideo(track: HMSTrack | undefined) {\n  return track && track.type === 'video';\n}\n\nexport function isScreenShare(track: HMSTrack | undefined) {\n  return track && track.source === 'screen';\n}\n\nexport function isAudioPlaylist(track: HMSTrack | undefined) {\n  return track && track.source === 'audioplaylist';\n}\n\nexport function isVideoPlaylist(track: HMSTrack | undefined) {\n  return track && track.source === 'videoplaylist';\n}\n\nexport function isDegraded(track: HMSTrack | undefined) {\n  return Boolean(track?.degraded);\n}\n\nexport function isTrackEnabled(store: HMSStore, trackID?: string) {\n  if (trackID && store.tracks[trackID]) {\n    return store.tracks[trackID].enabled;\n  }\n  return false;\n}\n\n/**\n * Should UI show the video track as enabled\n */\nexport function isTrackDisplayEnabled(store: HMSStore, trackID?: string) {\n  if (trackID && store.tracks[trackID]) {\n    return store.tracks[trackID].displayEnabled;\n  }\n  return false;\n}\n","import { HMSMessage, HMSPeer, HMSPeerID, HMSRoom, HMSRoomState, HMSStore } from '../schema';\nimport { createSelector } from 'reselect';\n// noinspection ES6PreferShortImport\nimport { HMSRole } from '../hmsSDKStore/sdkTypes';\nimport {\n  getPeerTracksByCondition,\n  isDegraded,\n  isVideoPlaylist,\n  isTrackDisplayEnabled,\n  isTrackEnabled,\n} from './selectorUtils';\n\n/**\n * Select the current {@link HMSRoom} object to which you are connected.\n * @param store\n */\nexport const selectRoom = (store: HMSStore): HMSRoom => store.room;\n\n/**\n * @internal\n */\nexport const selectPeersMap = (store: HMSStore): Record<HMSPeerID, HMSPeer> => store.peers;\n\n/**\n * @internal\n */\nexport const selectMessagesMap = (store: HMSStore) => store.messages.byID;\n\n/**\n * Select IDs of messages you've sent or received sorted chronologically.\n */\nexport const selectMessageIDsInOrder = (store: HMSStore) => store.messages.allIDs;\n\n/**\n * @internal\n */\nexport const selectTracksMap = (store: HMSStore) => store.tracks;\n\n/**\n * Select your media settings\n * i.e., choosen audio input device, audio output device and video input device.\n * @param store\n */\nexport const selectLocalMediaSettings = (store: HMSStore) => store.settings;\n\n/**\n * Select the available audio input, audio output and video input devices on your machine.\n * @param store\n * @returns An object of array of available audio input, audio output and video input devices.\n * ```\n * type DeviceMap = {\n *   audioInput: InputDeviceInfo[];\n *   audioOutput: MediaDeviceInfo[];\n *   videoInput: InputDeviceInfo[];\n * }\n * ```\n */\nexport const selectDevices = (store: HMSStore) => {\n  return store.devices;\n};\n\nexport const selectSpeakers = (store: HMSStore) => {\n  return store.speakers;\n};\n\n/**\n * Select a boolean flag denoting whether you've joined a room.\n * NOTE: Returns true only after join, returns false during preview.\n */\nexport const selectIsConnectedToRoom = createSelector(\n  [selectRoom],\n  room => room && room.isConnected,\n);\n\nexport const selectPeerCount = createSelector(selectRoom, room => room.peers.length);\n\n/**\n * Select an array of peers(remote peers and your local peer) present in the room.\n */\nexport const selectPeers = createSelector([selectRoom, selectPeersMap], (room, storePeers) => {\n  return room.peers.map(peerID => storePeers[peerID]);\n});\n\n/**\n * Select an array of tracks(remote peer tracks and your local tracks) present in the room.\n */\nconst selectTracks = createSelector(selectTracksMap, storeTracks => {\n  return Object.values(storeTracks);\n});\n\n/**\n * Select the local peer object object assigned to you.\n */\nexport const selectLocalPeer = createSelector(selectRoom, selectPeersMap, (room, peers) => {\n  return peers[room.localPeer];\n});\n\n/**\n * Select the peer ID of your local peer.\n */\nexport const selectLocalPeerID = createSelector(selectRoom, room => {\n  return room.localPeer;\n});\n\n/**\n * Select the track ID of your local peer's primary audio track\n */\nexport const selectLocalAudioTrackID = createSelector(selectLocalPeer, peer => peer?.audioTrack);\n\n/**\n * Select the track ID of your local peer's primary video track\n */\nexport const selectLocalVideoTrackID = createSelector(selectLocalPeer, peer => peer?.videoTrack);\n\n/**\n * Select an array of track IDs of your local peer's auxiliary tracks\n */\nconst selectLocalAuxiliaryTrackIDs = createSelector(selectLocalPeer, peer => peer?.auxiliaryTracks);\n\n/**\n * Select an array of track IDs of all your local peer's tracks\n */\nexport const selectLocalTrackIDs = createSelector(\n  [selectLocalAudioTrackID, selectLocalVideoTrackID, selectLocalAuxiliaryTrackIDs],\n  (audioTrackID, videoTrackID, auxiliaryTrackIDs) => {\n    const trackIDs: string[] = [...auxiliaryTrackIDs];\n    audioTrackID && trackIDs.unshift(audioTrackID);\n    videoTrackID && trackIDs.unshift(videoTrackID);\n    return trackIDs;\n  },\n);\n\n/**\n * Select remote peers(other users you're connected with via the internet) present in the room.\n */\nexport const selectRemotePeers = createSelector(selectPeers, peers => {\n  return peers.filter(p => !p.isLocal);\n});\n\n/**\n * Select the peer who's speaking the loudest at the moment\n */\nexport const selectDominantSpeaker = createSelector(\n  selectPeersMap,\n  selectSpeakers,\n  (peersMap, speakers) => {\n    // sort in descending order by audio level\n    const speakersInOrder = Object.entries(speakers).sort((s1, s2) => {\n      const s1Level = s1[1]?.audioLevel || 0;\n      const s2Level = s2[1]?.audioLevel || 0;\n      return s2Level > s1Level ? 1 : -1;\n    });\n    if (\n      speakersInOrder.length > 0 &&\n      speakersInOrder[0][1].audioLevel &&\n      speakersInOrder[0][1].audioLevel > 0\n    ) {\n      const peerID = speakersInOrder[0][1].peerID;\n      if (peerID in peersMap) {\n        return peersMap[peerID];\n      }\n    }\n    return null;\n  },\n);\n\n/**\n * Select a boolean denoting whether your local audio is unmuted\n * and the audio from your microphone is shared to remote peers\n */\nexport const selectIsLocalAudioEnabled = (store: HMSStore) => {\n  const localPeer = selectLocalPeer(store);\n  return isTrackEnabled(store, localPeer?.audioTrack);\n};\n\n/**\n * Select a boolean denoting whether your local video is unmuted\n * and the video from your camera is shared to remote peers\n */\nexport const selectIsLocalVideoEnabled = (store: HMSStore) => {\n  const localPeer = selectLocalPeer(store);\n  return isTrackEnabled(store, localPeer?.videoTrack);\n};\n\n/**\n * Select a boolean denoting whether you've chosen to unmute and share your local video.\n *\n * NOTE: Once you call `hmsActions.setLocalVideoEnabled(true)`to unmute your local video,\n * it takes some time to fetch your video from your video source.\n * This displayEnabled property gives immediate feedback for a more interactive UI,\n * without waiting for the video source\n */\nexport const selectIsLocalVideoDisplayEnabled = (store: HMSStore) => {\n  const localPeer = selectLocalPeer(store);\n  return isTrackDisplayEnabled(store, localPeer?.videoTrack);\n};\n\n/**\n * Select a boolean denoting whether your screen is shared to remote peers in the room.\n */\nexport const selectIsLocalScreenShared = createSelector(\n  selectLocalPeer,\n  selectTracksMap,\n  (localPeer, tracksMap) => {\n    const { video, audio } = getPeerTracksByCondition(tracksMap, localPeer);\n    return !!(video || audio);\n  },\n);\n\n/**\n * Select the first peer who is currently sharing their screen.\n */\nexport const selectPeerScreenSharing = createSelector(\n  selectPeersMap,\n  selectTracksMap,\n  (peersMap, tracksMap) => {\n    let screensharePeer = undefined;\n    for (const peerID in peersMap) {\n      const peer = peersMap[peerID];\n      const { video, audio } = getPeerTracksByCondition(tracksMap, peer);\n      if (video) {\n        return peer;\n      } else if (audio && !screensharePeer) {\n        screensharePeer = peer;\n      }\n    }\n    return screensharePeer;\n  },\n);\n\n/**\n * Select a boolean denoting whether someone is sharing screen in the room.\n */\nexport const selectIsSomeoneScreenSharing = createSelector(selectPeerScreenSharing, peer => {\n  return !!peer;\n});\n\n/**\n * Select the first peer who is currently sharing their audio only screen\n */\nexport const selectPeerSharingAudio = createSelector(\n  selectPeersMap,\n  selectTracksMap,\n  (peersMap, tracksMap) => {\n    for (const peerID in peersMap) {\n      const peer = peersMap[peerID];\n      const { audio, video } = getPeerTracksByCondition(tracksMap, peer);\n      if (!video && !!audio) {\n        return peer;\n      }\n    }\n    return undefined;\n  },\n);\n\n/**\n * Select an array of peers who are currently sharing their screen.\n */\nexport const selectPeersScreenSharing = createSelector(\n  selectPeersMap,\n  selectTracksMap,\n  (peersMap, tracksMap) => {\n    const videoPeers = [];\n    const audioPeers = [];\n    for (const peerID in peersMap) {\n      const peer = peersMap[peerID];\n      const { video, audio } = getPeerTracksByCondition(tracksMap, peer);\n      if (video) {\n        videoPeers.push(peer);\n      } else if (audio) {\n        audioPeers.push(peer);\n      }\n    }\n    return videoPeers.concat(audioPeers);\n  },\n);\n\nexport const selectPeerSharingVideoPlaylist = createSelector(\n  selectPeersMap,\n  selectTracksMap,\n  (peersMap, tracksMap) => {\n    for (const peerID in peersMap) {\n      const peer = peersMap[peerID];\n      const { video } = getPeerTracksByCondition(tracksMap, peer, isVideoPlaylist);\n      if (video) {\n        return peer;\n      }\n    }\n    return undefined;\n  },\n);\n\n/**\n * Select an array of tracks that have been degraded(receiving lower video quality/no video) due to bad network locally.\n */\nexport const selectDegradedTracks = createSelector(selectTracks, tracks =>\n  tracks.filter(isDegraded),\n);\n\n/**\n * Select the number of messages(sent and received).\n */\nexport const selectHMSMessagesCount = createSelector(\n  selectMessageIDsInOrder,\n  messageIDs => messageIDs.length,\n);\n\n/**\n * Select the number of unread messages.\n */\nexport const selectUnreadHMSMessagesCount = createSelector(selectMessagesMap, messages => {\n  return Object.values(messages).filter(m => !m.read).length;\n});\n\n/**\n * Select an array of messages in the room(sent and received).\n */\nexport const selectHMSMessages = createSelector(\n  selectMessageIDsInOrder,\n  selectMessagesMap,\n  (msgIDs, msgMap) => {\n    const messages: HMSMessage[] = [];\n    msgIDs.forEach(msgId => {\n      messages.push(msgMap[msgId]);\n    });\n    return messages;\n  },\n);\n\n/**\n * Select the current state of the room.\n */\nexport const selectRoomState = createSelector([selectRoom], room => room && room.roomState);\n\n/**\n * Select a boolean denoting whether the room is in Preview state.\n */\nexport const selectIsInPreview = createSelector(\n  selectRoomState,\n  roomState => roomState === HMSRoomState.Preview,\n);\n\nexport const selectRoomStarted = createSelector(\n  selectRoom,\n  room => room.roomState !== HMSRoomState.Disconnected,\n);\n\n/**\n * Select available roles in the room as a map between the role name and {@link HMSRole} object.\n */\nexport const selectRolesMap = (store: HMSStore): Record<string, HMSRole> => {\n  return store.roles;\n};\n\n/**\n * Select an array of names of available roles in the room.\n */\nexport const selectAvailableRoleNames = createSelector([selectRolesMap], rolesMap =>\n  Object.keys(rolesMap),\n);\n\n/**\n * Select the {@link HMSRole} object of your local peer.\n */\nexport const selectLocalPeerRole = createSelector(\n  [selectLocalPeer, selectRolesMap],\n  (localPeer, rolesMap) => (localPeer?.roleName ? rolesMap[localPeer.roleName] : null),\n);\n\n/**\n * Select a boolean denoting whether if your local peer is allowed to subscribe to any other role.\n */\nexport const selectIsAllowedToSubscribe = createSelector([selectLocalPeerRole], (role): boolean => {\n  if (!role?.subscribeParams?.subscribeToRoles) {\n    return false;\n  }\n  return role.subscribeParams.subscribeToRoles.length > 0;\n});\n\n/**\n * Select the permissions which determine what actions the local peer can do.\n */\nexport const selectPermissions = createSelector(selectLocalPeerRole, role => role?.permissions);\nexport const selectRecordingState = createSelector(selectRoom, room => room.recording);\nexport const selectRTMPState = createSelector(selectRoom, room => room.rtmp);\n","import { createSelector } from 'reselect';\nimport { HMSPlaylistType, HMSStore, HMSPlaylistSelector } from '../schema';\n\n/**\n * @internal\n */\nconst selectPlaylistMap = (type: HMSPlaylistType = HMSPlaylistType.audio) => (store: HMSStore) =>\n  store.playlist[type].list;\n\nconst selectPlaylistSelection = (type: HMSPlaylistType = HMSPlaylistType.audio) => (\n  store: HMSStore,\n) => store.playlist[type].selection;\n\nconst selectPlaylistProgress = (type: HMSPlaylistType = HMSPlaylistType.audio) => (\n  store: HMSStore,\n) => store.playlist[type].progress;\n\nconst selectPlaylistCurrentTime = (type: HMSPlaylistType = HMSPlaylistType.audio) => (\n  store: HMSStore,\n) => store.playlist[type].currentTime;\n\nconst selectPlaylistVolume = (type: HMSPlaylistType = HMSPlaylistType.audio) => (store: HMSStore) =>\n  store.playlist[type].volume;\n\n/**\n * Select an array of playlist items.\n */\nconst selectPlaylist = (type: HMSPlaylistType = HMSPlaylistType.audio) =>\n  createSelector(selectPlaylistMap(type), storePlaylist => {\n    return Object.values(storePlaylist);\n  });\n\nconst selectPlaylistSelectedItem = (type: HMSPlaylistType = HMSPlaylistType.audio) =>\n  createSelector(\n    selectPlaylistMap(type),\n    selectPlaylistSelection(type),\n    (storePlaylist, currentSelection) => {\n      if (!currentSelection.id) {\n        return;\n      }\n      return storePlaylist[currentSelection.id];\n    },\n  );\n\nexport const selectAudioPlaylist: HMSPlaylistSelector = {\n  selection: selectPlaylistSelection(HMSPlaylistType.audio),\n  progress: selectPlaylistProgress(HMSPlaylistType.audio),\n  currentTime: selectPlaylistCurrentTime(HMSPlaylistType.audio),\n  volume: selectPlaylistVolume(HMSPlaylistType.audio),\n  list: selectPlaylist(HMSPlaylistType.audio),\n  selectedItem: <any>selectPlaylistSelectedItem(HMSPlaylistType.audio),\n};\n\nexport const selectVideoPlaylist: HMSPlaylistSelector = {\n  selection: selectPlaylistSelection(HMSPlaylistType.video),\n  progress: selectPlaylistProgress(HMSPlaylistType.video),\n  currentTime: selectPlaylistCurrentTime(HMSPlaylistType.audio),\n  volume: selectPlaylistVolume(HMSPlaylistType.video),\n  list: selectPlaylist(HMSPlaylistType.video),\n  selectedItem: <any>selectPlaylistSelectedItem(HMSPlaylistType.video),\n};\n","import { HMSLogLevel } from '../core/hmsSDKStore/sdkTypes';\n\nconst HMS_STORE_TAG = 'HMS-Store:';\n\nexport class HMSLogger {\n  static level: HMSLogLevel = HMSLogLevel.VERBOSE;\n\n  static v(tag: string, ...data: any[]) {\n    this.log(HMSLogLevel.VERBOSE, tag, ...data);\n  }\n\n  static d(...data: any[]) {\n    this.log(HMSLogLevel.DEBUG, ...data);\n  }\n\n  static i(...data: any[]) {\n    this.log(HMSLogLevel.INFO, ...data);\n  }\n\n  static w(...data: any[]) {\n    this.log(HMSLogLevel.WARN, ...data);\n  }\n\n  static e(...data: any[]) {\n    this.log(HMSLogLevel.ERROR, ...data);\n  }\n\n  static time(mark: string) {\n    this.log(HMSLogLevel.TIME, '[HMSPerformanceTiming]', mark);\n  }\n\n  static timeEnd(mark: string) {\n    this.log(HMSLogLevel.TIMEEND, '[HMSPerformanceTiming]', mark, mark);\n  }\n\n  static cleanUp() {\n    performance.clearMarks();\n    performance.clearMeasures();\n  }\n\n  /* eslint-disable */\n  private static log(level: HMSLogLevel, ...data: any[]) {\n    if (this.level.valueOf() > level.valueOf()) {\n      return;\n    }\n\n    switch (level) {\n      case HMSLogLevel.VERBOSE: {\n        console.log(HMS_STORE_TAG, ...data);\n        break;\n      }\n      case HMSLogLevel.DEBUG: {\n        console.debug(HMS_STORE_TAG, ...data);\n        break;\n      }\n      case HMSLogLevel.INFO: {\n        console.info(HMS_STORE_TAG, ...data);\n        break;\n      }\n      case HMSLogLevel.WARN: {\n        console.warn(HMS_STORE_TAG, ...data);\n        break;\n      }\n      case HMSLogLevel.ERROR: {\n        console.error(HMS_STORE_TAG, ...data);\n        break;\n      }\n      case HMSLogLevel.TIME: {\n        performance.mark(data[1]);\n        break;\n      }\n      case HMSLogLevel.TIMEEND: {\n        const tag = data[0];\n        const mark = data[1];\n        try {\n          const entry = performance.measure(mark, mark);\n          //@ts-ignore\n          this.log(HMSLogLevel.DEBUG, tag, mark, entry?.duration);\n          performance.clearMarks(mark);\n          performance.clearMeasures(mark);\n        } catch (error) {\n          this.log(HMSLogLevel.DEBUG, tag, mark, error);\n        }\n        break;\n      }\n    }\n  }\n}\n","import { createSelector } from 'reselect';\nimport { selectHMSMessages, selectLocalPeerID, selectPeersMap, selectTracksMap } from './selectors';\nimport { HMSPeerID, HMSRoleName, HMSStore, HMSTrack, HMSTrackID } from '../schema';\nimport {\n  getPeerTracksByCondition,\n  isAudio,\n  isVideoPlaylist,\n  isTrackEnabled,\n  isVideo,\n  isAudioPlaylist,\n} from './selectorUtils';\nimport { HMSLogger } from '../../common/ui-logger';\n\ntype byIDSelector<T> = (store: HMSStore, id?: string) => T;\n\n/**\n * StoreSelector is a function that takes in {@link HMSStore} as argument\n * and returns a part of the store that is queried using the selector.\n * @typeParam T Part of the store that you wish to query.\n */\ntype StoreSelector<T> = (store: HMSStore) => T;\n\n/**\n * takes in a normal selector which has store and id as input and curries it to make it easier to use.\n * Before: store.getState((store) => normalSelector(store, peerID))\n * After: store.getState(curriedSelector(peerID))\n */\nfunction byIDCurry<T>(selector: byIDSelector<T>): (id?: string) => StoreSelector<T> {\n  return (id?: string) => {\n    return (store: HMSStore) => selector(store, id);\n  };\n}\n\nconst selectPeerID = (_store: HMSStore, peerID: HMSPeerID | undefined) => peerID;\nconst selectTrackID = (_store: HMSStore, trackID: HMSTrackID | undefined) => trackID;\nconst selectRoleName = (_store: HMSStore, roleName: HMSRoleName | undefined) => roleName;\n\nconst selectPeerByIDBare = createSelector([selectPeersMap, selectPeerID], (storePeers, peerID) =>\n  peerID ? storePeers[peerID] : null,\n);\n\nconst selectTrackByIDBare = createSelector(\n  [selectTracksMap, selectTrackID],\n  (storeTracks, trackID) => (trackID ? storeTracks[trackID] : null),\n);\n\n/**\n * Select the {@link HMSPeer} object given a peer ID.\n */\nexport const selectPeerByID = byIDCurry(selectPeerByIDBare);\n\n/**\n * Select the name of a {@link HMSPeer} given a peer ID.\n */\nexport const selectPeerNameByID = byIDCurry(createSelector(selectPeerByIDBare, peer => peer?.name));\n\n/**\n * Select the {@link HMSTrack} object given a track ID.\n */\nexport const selectTrackByID = byIDCurry(selectTrackByIDBare);\n\n/**\n * Select the primary video track of a peer given a peer ID.\n */\nexport const selectVideoTrackByPeerID = byIDCurry((store: HMSStore, peerID?: HMSPeerID):\n  | HMSTrack\n  | undefined => {\n  const peer = selectPeerByIDBare(store, peerID);\n  if (peer && peer.videoTrack && peer.videoTrack !== '') {\n    return store.tracks[peer.videoTrack];\n  }\n  return undefined;\n});\n\n/**\n * Select the primary audio track of a peer given a peer ID.\n */\nexport const selectAudioTrackByPeerID = byIDCurry((store: HMSStore, peerID?: HMSPeerID):\n  | HMSTrack\n  | undefined => {\n  const peer = selectPeerByIDBare(store, peerID);\n  if (peer && peer.audioTrack && peer.audioTrack !== '') {\n    return store.tracks[peer.audioTrack];\n  }\n  return undefined;\n});\n\n/**\n * Select the camera stream of a peer given a peer ID.\n * This is the primary video track of a peer.\n */\nexport const selectCameraStreamByPeerID = selectVideoTrackByPeerID;\n\n/**\n * Select an array of auxiliary tracks of a peer given a peer ID.\n */\nexport const selectAuxiliaryTracksByPeerID = byIDCurry(\n  (store: HMSStore, peerID?: HMSPeerID): HMSTrack[] => {\n    const peer = selectPeerByIDBare(store, peerID);\n    return peer?.auxiliaryTracks.map(trackID => store.tracks[trackID]) || [];\n  },\n);\n\nconst selectSpeakerByTrackID = (store: HMSStore, trackID: HMSTrackID | undefined) => {\n  return trackID ? store.speakers[trackID] : null;\n};\n\n/**\n * Select the audio level of a track given a track ID.\n */\nexport const selectTrackAudioByID = byIDCurry(\n  createSelector(selectSpeakerByTrackID, speaker => speaker?.audioLevel || 0),\n);\n\n/**\n * Select speaker object of audioTrack of a peer given a peer ID.\n */\nconst selectSpeakerByPeerID = (store: HMSStore, peerID: HMSPeerID | undefined) => {\n  const peerAudioTrack = selectAudioTrackByPeerID(peerID)(store);\n  return selectSpeakerByTrackID(store, peerAudioTrack?.id);\n};\n\n/**\n * Select audio level of audioTrack of a peer given a peer IDß.\n */\nexport const selectPeerAudioByID = byIDCurry(\n  createSelector(selectSpeakerByPeerID, speaker => speaker?.audioLevel || 0),\n);\n\n/**\n * Select the first auxiliary audio track of a peer given a peer ID.\n */\nexport const selectAuxiliaryAudioByPeerID = byIDCurry((store: HMSStore, peerID?: HMSPeerID):\n  | HMSTrack\n  | undefined => {\n  const peer = selectPeerByIDBare(store, peerID);\n  if (peer) {\n    const trackID = peer?.auxiliaryTracks.find(trackID => isAudio(store.tracks[trackID]));\n    return trackID ? store.tracks[trackID] : undefined;\n  }\n  return undefined;\n});\n\nexport const selectVideoPlaylistVideoTrackByPeerID = byIDCurry(\n  createSelector(selectTracksMap, selectPeerByIDBare, (tracks, peer) => {\n    const trackID = peer?.auxiliaryTracks.find(trackID => {\n      const track = tracks[trackID];\n      return isVideoPlaylist(track) && isVideo(track);\n    });\n    return trackID ? tracks[trackID] : undefined;\n  }),\n);\n\nexport const selectVideoPlaylistAudioTrackByPeerID = byIDCurry(\n  createSelector(selectTracksMap, selectPeerByIDBare, (tracks, peer) => {\n    const trackID = peer?.auxiliaryTracks.find(trackID => {\n      const track = tracks[trackID];\n      return isVideoPlaylist(track) && isAudio(track);\n    });\n    return trackID ? tracks[trackID] : undefined;\n  }),\n);\n\nexport const selectAudioPlaylistTrackByPeerID = byIDCurry(\n  createSelector(selectTracksMap, selectPeerByIDBare, (tracks, peer) => {\n    const trackID = peer?.auxiliaryTracks.find(trackID => {\n      const track = tracks[trackID];\n      return isAudioPlaylist(track) && isAudio(track);\n    });\n    return trackID ? tracks[trackID] : undefined;\n  }),\n);\n\nexport const selectScreenSharesByPeerId = byIDCurry(\n  createSelector(selectTracksMap, selectPeerByIDBare, (tracks, peer) => {\n    return getPeerTracksByCondition(tracks, peer);\n  }),\n);\n\n/**\n * Select the screen share video track of a peer given a peer ID.\n */\nexport const selectScreenShareByPeerID = (id?: string) =>\n  createSelector(selectScreenSharesByPeerId(id), screenshare => {\n    return screenshare.video;\n  });\n\n/**\n * Select the screen share audio track of a peer given a peer ID.\n */\nexport const selectScreenShareAudioByPeerID = (id?: string) =>\n  createSelector(selectScreenSharesByPeerId(id), screenshare => {\n    return screenshare.audio;\n  });\n\n/**\n * Select a boolean denoting whether a peer has unmuted audio and sharing it to other peers.\n */\nexport const selectIsPeerAudioEnabled = byIDCurry((store: HMSStore, peerID?: string) => {\n  const peer = selectPeerByIDBare(store, peerID);\n  return isTrackEnabled(store, peer?.audioTrack);\n});\n\n/**\n * Select a boolean denoting whether a peer has unmuted video and sharing it to other peers.\n */\nexport const selectIsPeerVideoEnabled = byIDCurry((store: HMSStore, peerID?: string) => {\n  const peer = selectPeerByIDBare(store, peerID);\n  return isTrackEnabled(store, peer?.videoTrack);\n});\n\n/**\n * Select a boolean denoting whether you've muted an audio track locally(only for you) given a track ID.\n */\nexport const selectIsAudioLocallyMuted = byIDCurry((store: HMSStore, trackID?: string) => {\n  if (trackID && store.tracks[trackID]) {\n    return store.tracks[trackID].volume === 0;\n  }\n  return undefined;\n});\n\n/**\n * Select a boolean denoting whether you've muted the primary audio track of a peer locally(only for you) given a peer ID.\n */\nexport const selectIsLocallyMutedByPeerID = byIDCurry((store: HMSStore, peerID?: string) => {\n  const peer = selectPeerByIDBare(store, peerID);\n  return selectIsAudioLocallyMuted(peer?.audioTrack)(store);\n});\n\n/**\n * Select a boolean denoting whether you've muted the screen share audio track of a peer locally(only for you) given a peer ID.\n */\nexport const selectIsScreenShareLocallyMutedByPeerID = byIDCurry(\n  (store: HMSStore, peerID?: string) => {\n    const track = selectScreenShareAudioByPeerID(peerID)(store);\n    return selectIsAudioLocallyMuted(track?.id)(store);\n  },\n);\n\n/**\n * Select the local audio volume of an audio track given a track ID.\n *\n * NOTE: **Volume** of a track is different from **Audio Level** of a track,\n * - Audio Level measures the audio of a track and it comes from 100ms's servers.\n * - Volume is how loud you hear the audio of a track, this is controlled by you at the client side.\n */\nexport const selectAudioTrackVolume = byIDCurry((store: HMSStore, trackID?: string) => {\n  const track = selectTrackByIDBare(store, trackID);\n  if (track) {\n    if (track.type !== 'audio') {\n      HMSLogger.w('Please pass audio track here');\n      return undefined;\n    }\n    return track.volume;\n  }\n  return undefined;\n});\n\n/**\n * Select the local audio volume of the primary audio track of a peer given a peer ID.\n */\nexport const selectAudioVolumeByPeerID = byIDCurry((store: HMSStore, peerID?: string) => {\n  const peer = selectPeerByIDBare(store, peerID);\n  return selectAudioTrackVolume(peer?.audioTrack)(store);\n});\n\n/**\n * Select the local audio volume of the screen share of a peer given a peer ID.\n */\nexport const selectScreenshareAudioVolumeByPeerID = byIDCurry(\n  (store: HMSStore, peerID?: string) => {\n    const track = selectScreenShareAudioByPeerID(peerID)(store);\n    return selectAudioTrackVolume(track?.id)(store);\n  },\n);\n\n/**\n * Select the current simulcast layer of a track given a track ID.\n */\nexport const selectSimulcastLayerByTrack = byIDCurry((store: HMSStore, trackID?: string) => {\n  const track = selectTrackByIDBare(store, trackID);\n  if (track) {\n    if (track.type !== 'video') {\n      HMSLogger.w('Please pass video track here');\n      return undefined;\n    }\n    return track.layer;\n  }\n  return undefined;\n});\n\nconst selectMessagesByPeerIDInternal = createSelector(\n  [selectHMSMessages, selectLocalPeerID, selectPeerID],\n  (messages, localPeerID, peerID) => {\n    if (!peerID) {\n      return undefined;\n    }\n    return messages.filter(message => {\n      // Broadcast message\n      if (!message.recipientPeer && !message.recipientRoles?.length) {\n        return false;\n      }\n      // if localPeer or peerID is not a sender remove this\n      if (![localPeerID, peerID].includes(message.sender)) {\n        return false;\n      }\n      // at this point we know the sender is one of local or passed in peer, check the recipient side\n      return [localPeerID, peerID].includes(message.recipientPeer!);\n    });\n  },\n);\n\nconst selectMessagesByRoleInternal = createSelector(\n  [selectHMSMessages, selectRoleName],\n  (messages, roleName) => {\n    if (!roleName) {\n      return undefined;\n    }\n    return messages.filter(message => {\n      // Not Role message - Broadcast message or Private Peer message\n      if (!message.recipientRoles?.length) {\n        return false;\n      }\n      return message.recipientRoles?.includes(roleName);\n    });\n  },\n);\n\nexport const selectBroadcastMessages = createSelector(selectHMSMessages, messages => {\n  return messages.filter(message => {\n    if (!message.recipientPeer && !message.recipientRoles?.length) {\n      return true;\n    }\n    return false;\n  });\n});\n\nconst selectUnreadMessageCountByRole = createSelector(\n  [selectMessagesByRoleInternal, selectRoleName],\n  messages => {\n    if (!messages) {\n      return 0;\n    }\n    return messages.filter(m => !m.read).length;\n  },\n);\n\nconst selectUnreadMessageCountByPeerID = createSelector(\n  [selectMessagesByPeerIDInternal, selectPeerID],\n  messages => {\n    if (!messages) {\n      return 0;\n    }\n    return messages.filter(m => !m.read).length;\n  },\n);\n\nexport const selectBroadcastMessagesUnreadCount = createSelector(\n  selectBroadcastMessages,\n  messages => {\n    return messages.filter(m => !m.read).length;\n  },\n);\n\nexport const selectMessagesByPeerID = byIDCurry(selectMessagesByPeerIDInternal);\n\nexport const selectMessagesByRole = byIDCurry(selectMessagesByRoleInternal);\n\nexport const selectMessagesUnreadCountByRole = byIDCurry(selectUnreadMessageCountByRole);\nexport const selectMessagesUnreadCountByPeerID = byIDCurry(selectUnreadMessageCountByPeerID);\n","import { HMSPeer, HMSStore } from '../schema';\nimport { selectLocalPeerRole, selectPeersMap, selectRolesMap, selectTracksMap } from './selectors';\nimport { createSelector } from 'reselect';\nimport { HMSRole } from '@100mslive/hms-video';\n\nexport interface HMSPeerWithMuteStatus {\n  peer: HMSPeer;\n  isAudioEnabled?: boolean;\n}\n\n/**\n * @privateRemarks\n * this is more friendly to UI format, the object in store has only peer id and role name instead of the full objects\n */\nexport interface HMSRoleChangeRequest {\n  requestedBy: HMSPeer;\n  role: HMSRole;\n  token: string;\n}\n\nexport interface HMSPublishAllowed {\n  video: boolean;\n  audio: boolean;\n  screen: boolean;\n}\n\nexport const selectPeersWithAudioStatus = createSelector(\n  [selectPeersMap, selectTracksMap],\n  (peersMap, tracksMap) => {\n    const participants: HMSPeerWithMuteStatus[] = Object.values(peersMap).map(peer => {\n      return {\n        peer: peer,\n        isAudioEnabled: peer.audioTrack ? tracksMap[peer.audioTrack]?.enabled : false,\n      };\n    });\n    return participants;\n  },\n);\n\nconst selectRoleChangeStoreRequest = (store: HMSStore) => {\n  return store.roleChangeRequests[0] || null;\n};\n\n/**\n * Select the role change request received for your local peer.\n */\nexport const selectRoleChangeRequest = createSelector(\n  [selectRoleChangeStoreRequest, selectPeersMap, selectRolesMap],\n  (request, peersMap, rolesMap): HMSRoleChangeRequest | null => {\n    if (!request) {\n      return null;\n    }\n    return {\n      requestedBy: peersMap[request.requestedBy],\n      role: rolesMap[request.roleName],\n      token: request.token,\n    };\n  },\n);\n\n/**\n * Select what streams is the local peer allowed to publish from video, audio and screenshare.\n */\nexport const selectIsAllowedToPublish = createSelector(\n  [selectLocalPeerRole],\n  (role): HMSPublishAllowed => {\n    let video = false,\n      audio = false,\n      screen = false;\n    if (role?.publishParams?.allowed) {\n      video = role.publishParams.allowed.includes('video');\n      audio = role.publishParams.allowed.includes('audio');\n      screen = role.publishParams.allowed.includes('screen');\n    }\n    return {\n      video,\n      audio,\n      screen,\n    };\n  },\n);\n","import { createSelector } from 'reselect';\nimport {\n  selectLocalAudioTrackID,\n  selectLocalVideoTrackID,\n  selectRolesMap,\n  selectTracksMap,\n} from './selectors';\nimport { HMSTrack } from '../schema';\n\nexport const selectRoleByRoleName = (roleName: string) =>\n  createSelector([selectRolesMap], rolesMap => rolesMap[roleName]);\n\nconst selectLocalVideoPlugins = createSelector(\n  [selectLocalVideoTrackID, selectTracksMap],\n  (trackID, tracksMap) => {\n    let track: HMSTrack | null = null;\n    if (trackID) {\n      track = tracksMap[trackID];\n    }\n    return track?.plugins || [];\n  },\n);\n\nconst selectLocalAudioPlugins = createSelector(\n  [selectLocalAudioTrackID, selectTracksMap],\n  (trackID, tracksMap) => {\n    let track: HMSTrack | null = null;\n    if (trackID) {\n      track = tracksMap[trackID];\n    }\n    return track?.plugins || [];\n  },\n);\n\nexport const selectIsLocalVideoPluginPresent = (pluginName: string) => {\n  return createSelector([selectLocalVideoPlugins], plugins => {\n    return plugins.includes(pluginName);\n  });\n};\n\nexport const selectIsLocalAudioPluginPresent = (pluginName: string) => {\n  return createSelector([selectLocalAudioPlugins], plugins => {\n    return plugins.includes(pluginName);\n  });\n};\n","import { HMSTrack, HMSRemoteAudioTrack, HMSRemoteVideoTrack } from '@100mslive/hms-video';\n\nexport function isRemoteTrack(track: HMSTrack) {\n  return track instanceof HMSRemoteAudioTrack || track instanceof HMSRemoteVideoTrack;\n}\n","import { HMSPlaylistItem, HMSPlaylistType, IHMSPlaylistActions } from '../schema';\nimport { HMSPlaylistManager } from './sdkTypes';\nimport { HMSLogger } from '../../common/ui-logger';\nimport { IHMSStore } from '../IHMSStore';\nimport { selectVideoPlaylist, selectAudioPlaylist } from '../selectors';\n\nexport class HMSPlaylist implements IHMSPlaylistActions {\n  private type: HMSPlaylistType;\n  constructor(\n    private playlistManager: HMSPlaylistManager,\n    type: HMSPlaylistType,\n    private syncPlaylistState: (action: string) => void,\n    private store: IHMSStore,\n  ) {\n    this.type = type;\n  }\n\n  async play(id: string): Promise<void> {\n    if (!id) {\n      HMSLogger.w('Please pass id to play');\n      return;\n    }\n    await this.playlistManager.setEnabled(true, { id, type: this.type });\n  }\n\n  async pause(): Promise<void> {\n    const selector =\n      this.type === HMSPlaylistType.audio ? selectAudioPlaylist : selectVideoPlaylist;\n    const selection = this.store.getState(selector.selection);\n    if (!selection.id) {\n      HMSLogger.w('No item is currently playing to pause');\n      return;\n    }\n    await this.playlistManager.setEnabled(false, { id: selection.id, type: this.type });\n  }\n\n  async playNext(): Promise<void> {\n    await this.playlistManager.playNext(this.type);\n  }\n\n  async playPrevious(): Promise<void> {\n    await this.playlistManager.playPrevious(this.type);\n  }\n\n  seek(seekValue: number): void {\n    this.playlistManager.seek(seekValue, this.type);\n    this.syncPlaylistState(`seekOn${this.type}Playlist`);\n  }\n\n  seekTo(seekValue: number): void {\n    this.playlistManager.seekTo(seekValue, this.type);\n    this.syncPlaylistState(`seekToOn${this.type}Playlist`);\n  }\n\n  setVolume(volume: number): void {\n    this.playlistManager.setVolume(volume, this.type);\n    this.syncPlaylistState(`setVolumeOn${this.type}Playlist`);\n  }\n\n  setList<T>(list: HMSPlaylistItem<T>[]): void {\n    this.playlistManager.setList(list);\n    this.syncPlaylistState(`setListOn${this.type}Playlist`);\n  }\n\n  async stop(): Promise<void> {\n    await this.playlistManager.stop(this.type);\n    this.syncPlaylistState(`stop${this.type}Playlist`);\n  }\n}\n","import {\n  createDefaultStoreState,\n  HMSMediaSettings,\n  HMSMessage,\n  HMSMessageInput,\n  HMSPeer,\n  HMSPeerID,\n  HMSPlaylistType,\n  HMSRoomState,\n  HMSStore,\n  HMSTrack,\n  HMSTrackID,\n  HMSTrackSource,\n  HMSChangeMultiTrackStateParams,\n  IHMSPlaylistActions,\n} from '../schema';\nimport { IHMSActions } from '../IHMSActions';\nimport * as sdkTypes from './sdkTypes';\nimport { SDKToHMS } from './adapter';\nimport {\n  HMSRoleChangeRequest,\n  selectHMSMessagesCount,\n  selectIsLocalScreenShared,\n  selectIsLocalVideoDisplayEnabled,\n  selectIsLocalVideoEnabled,\n  selectLocalAudioTrackID,\n  selectLocalPeer,\n  selectLocalTrackIDs,\n  selectLocalVideoTrackID,\n  selectPeerByID,\n  selectPermissions,\n  selectRolesMap,\n  selectRoomStarted,\n  selectRoomState,\n  selectLocalMediaSettings,\n  selectTrackByID,\n  selectTracksMap,\n} from '../selectors';\nimport { HMSLogger } from '../../common/ui-logger';\nimport {\n  HMSAudioPlugin,\n  HMSAudioTrack as SDKHMSAudioTrack,\n  HMSException as SDKHMSException,\n  HMSLeaveRoomRequest as SDKHMSLeaveRoomRequest,\n  HMSLocalAudioTrack as SDKHMSLocalAudioTrack,\n  HMSLocalTrack as SDKHMSLocalTrack,\n  HMSLocalVideoTrack as SDKHMSLocalVideoTrack,\n  HMSLogLevel,\n  HMSRemoteTrack as SDKHMSRemoteTrack,\n  HMSRemoteVideoTrack as SDKHMSRemoteVideoTrack,\n  HMSRoleChangeRequest as SDKHMSRoleChangeRequest,\n  HMSChangeTrackStateRequest as SDKHMSChangeTrackStateRequest,\n  HMSChangeMultiTrackStateParams as SDKHMSChangeMultiTrackStateParams,\n  HMSChangeMultiTrackStateRequest as SDKHMSChangeMultiTrackStateRequest,\n  HMSSdk,\n  HMSSimulcastLayer,\n  HMSTrack as SDKHMSTrack,\n  HMSVideoPlugin,\n  HMSVideoTrack as SDKHMSVideoTrack,\n} from '@100mslive/hms-video';\nimport { IHMSStore } from '../IHMSStore';\n\nimport {\n  areArraysEqual,\n  mergeNewPeersInDraft,\n  mergeNewTracksInDraft,\n} from './sdkUtils/storeMergeUtils';\nimport { HMSNotifications } from './HMSNotifications';\nimport { NamedSetState } from './internalTypes';\nimport { isRemoteTrack } from './sdkUtils/sdkUtils';\nimport { HMSPlaylist } from './HMSPlaylist';\n// import { ActionBatcher } from './sdkUtils/ActionBatcher';\n\n/**\n * This class implements the IHMSActions interface for 100ms SDK. It connects with SDK\n * and takes control of data management by letting every action pass through it. The\n * passed in store is ensured to be the single source of truth reflecting current\n * room related data at any point in time.\n *\n * @privateRemarks\n * Things to keep in mind while updating store -\n * 1. Treat setState as an atomic operation, if an action results in multiple changes,\n *    the changes should all happen within single setState function.\n * 2. While updating the state it's very important to not update the reference if\n *    something is unchanged. Copy data in same reference object don't assign new\n *    object.\n * 3. Mental Model(1) - Actions from backend -> Listeners of this class -> update store -> views update themselves\n *    eg. for this - peer added, remote muted etc.\n * 4. Mental Model(2) - Actions from local -> View calls actions -> update store -> views update themselves\n *    eg. local track enabled, join, leave etc.\n * 5. State is immutable, a new copy with new references is created when there is a change,\n *    if you try to modify state outside of setState, there'll be an error.\n */\nexport class HMSSDKActions implements IHMSActions {\n  private hmsSDKTracks: Record<string, SDKHMSTrack> = {};\n  private hmsSDKPeers: Record<string, sdkTypes.HMSPeer> = {};\n  private readonly sdk: HMSSdk;\n  private readonly store: IHMSStore;\n  private isRoomJoinCalled: boolean = false;\n  private hmsNotifications: HMSNotifications;\n  // private actionBatcher: ActionBatcher;\n  audioPlaylist!: IHMSPlaylistActions;\n  videoPlaylist!: IHMSPlaylistActions;\n\n  constructor(store: IHMSStore, sdk: HMSSdk, notificationManager: HMSNotifications) {\n    this.store = store;\n    this.sdk = sdk;\n    this.hmsNotifications = notificationManager;\n    // this.actionBatcher = new ActionBatcher(store);\n  }\n\n  async unblockAudio() {\n    await this.sdk.getAudioOutput().unblockAutoplay();\n  }\n\n  setVolume(value: number, trackId?: HMSTrackID): void {\n    if (trackId) {\n      this.setTrackVolume(value, trackId);\n    } else {\n      this.sdk.getAudioOutput().setVolume(value);\n      this.syncRoomState('setOutputVolume');\n    }\n  }\n\n  setAudioOutputDevice(deviceId: string): void {\n    const deviceInfo = this.sdk.getAudioOutput().setDevice(deviceId);\n    if (deviceInfo) {\n      this.setState(draftStore => {\n        draftStore.settings.audioOutputDeviceId = deviceId;\n      }, 'setAudioOutputDevice');\n    }\n  }\n\n  setPreferredLayer(trackId: string, layer: HMSSimulcastLayer) {\n    const track = this.hmsSDKTracks[trackId];\n    if (track) {\n      if (track instanceof SDKHMSRemoteVideoTrack) {\n        track.preferLayer(layer);\n        this.updateVideoLayer(trackId, 'setPreferredLayer');\n      } else {\n        HMSLogger.w(`track ${trackId} is not an video track`);\n      }\n    } else {\n      this.logPossibleInconsistency(`track ${trackId} not present, unable to set preffer layer`);\n    }\n  }\n\n  async preview(config: sdkTypes.HMSConfig) {\n    if (this.isRoomJoinCalled) {\n      this.logPossibleInconsistency('attempting to call preview after join was called');\n      return; // ignore\n    }\n    const roomState = this.store.getState(selectRoomState);\n    if (roomState === HMSRoomState.Preview || roomState === HMSRoomState.Connecting) {\n      this.logPossibleInconsistency(\n        'attempting to call preview while room is in preview/connecting',\n      );\n      return;\n    }\n\n    try {\n      await this.sdkPreviewWithListeners(config);\n      this.setState(store => {\n        store.room.roomState = HMSRoomState.Connecting;\n      }, 'preview');\n    } catch (err) {\n      HMSLogger.e('Cannot show preview. Failed to connect to room - ', err);\n      throw err;\n    }\n  }\n\n  join(config: sdkTypes.HMSConfig) {\n    if (this.isRoomJoinCalled) {\n      this.logPossibleInconsistency('room join is called again');\n      return; // ignore\n    }\n    try {\n      this.sdkJoinWithListeners(config);\n      this.isRoomJoinCalled = true;\n      this.setState(store => {\n        store.room.roomState = HMSRoomState.Connecting;\n      }, 'join');\n    } catch (err) {\n      this.isRoomJoinCalled = false; // so it can be called again if needed\n      HMSLogger.e('Failed to connect to room - ', err);\n      throw err;\n    }\n  }\n\n  async leave() {\n    const hasRoomStarted = this.store.getState(selectRoomStarted);\n    if (!hasRoomStarted) {\n      this.logPossibleInconsistency('room leave is called when no room is connected');\n      return; // ignore\n    }\n    return this.sdk\n      .leave()\n      .then(() => {\n        this.resetState('leave');\n        HMSLogger.i('left room');\n      })\n      .catch(err => {\n        HMSLogger.e('error in leaving room - ', err);\n      });\n  }\n\n  async setScreenShareEnabled(enabled: boolean, audioOnly?: boolean) {\n    if (enabled) {\n      await this.startScreenShare(audioOnly);\n    } else {\n      await this.stopScreenShare();\n    }\n  }\n\n  async addTrack(track: MediaStreamTrack, type: HMSTrackSource = 'regular') {\n    await this.sdk.addTrack(track, type);\n    this.syncRoomState('addTrack');\n  }\n\n  async removeTrack(trackId: string) {\n    await this.sdk.removeTrack(trackId);\n    this.syncRoomState('removeTrack');\n  }\n\n  async setLocalAudioEnabled(enabled: boolean) {\n    const trackID = this.store.getState(selectLocalAudioTrackID);\n    if (trackID) {\n      await this.setEnabledTrack(trackID, enabled);\n    }\n  }\n\n  async setLocalVideoEnabled(enabled: boolean) {\n    const trackID = this.store.getState(selectLocalVideoTrackID);\n    if (trackID) {\n      await this.setEnabledTrack(trackID, enabled);\n    }\n  }\n\n  async setEnabledTrack(trackID: string, enabled: boolean) {\n    // if mute/unmute is clicked multiple times for same operation, ignore repeated ones\n    const alreadyInSameState = this.store.getState().tracks[trackID]?.enabled === enabled;\n    if (alreadyInSameState) {\n      // it could also be a case of possible inconsistency where UI state is out of sync with truth\n      this.logPossibleInconsistency(`local track[${trackID}] enabled state - ${enabled}`);\n      return;\n    }\n    this.setState(store => {\n      // show on UI immediately\n      if (!store.tracks[trackID]) {\n        this.logPossibleInconsistency('track id not found for setEnabled');\n      } else {\n        store.tracks[trackID].displayEnabled = enabled;\n      }\n    }, 'displayEnabled');\n    try {\n      await this.setEnabledSDKTrack(trackID, enabled); // do the operation\n      this.syncRoomState('setEnabled');\n    } catch (err) {\n      // rollback on failure\n      this.setState(store => {\n        store.tracks[trackID].displayEnabled = !enabled;\n      }, 'rollbackDisplayEnabled');\n      this.hmsNotifications.sendError(SDKToHMS.convertException(err as SDKHMSException));\n      throw err;\n    }\n    const type = enabled\n      ? sdkTypes.HMSTrackUpdate.TRACK_UNMUTED\n      : sdkTypes.HMSTrackUpdate.TRACK_MUTED;\n    this.hmsNotifications.sendTrackUpdate(type, trackID);\n  }\n\n  async setAudioSettings(settings: Partial<sdkTypes.HMSAudioTrackSettings>) {\n    const trackID = this.store.getState(selectLocalAudioTrackID);\n    if (trackID) {\n      await this.setSDKLocalAudioTrackSettings(trackID, settings);\n      this.syncRoomState('setAudioSettings');\n    }\n  }\n\n  async setVideoSettings(settings: Partial<sdkTypes.HMSVideoTrackSettings>) {\n    const trackID = this.store.getState(selectLocalVideoTrackID);\n    if (trackID) {\n      await this.setSDKLocalVideoTrackSettings(trackID, settings);\n      this.syncRoomState('setVideoSettings');\n    }\n  }\n\n  sendMessage(message: string) {\n    this.sendBroadcastMessage(message);\n  }\n\n  async sendBroadcastMessage(message: string, type?: string) {\n    const sdkMessage = await this.sdk.sendBroadcastMessage(message, type);\n    this.updateMessageInStore(sdkMessage, { message, type });\n  }\n\n  async sendGroupMessage(message: string, roles: string[], type?: string) {\n    const storeRoles = this.store.getState(selectRolesMap);\n    const hmsRoles = roles.map(roleName => {\n      return storeRoles[roleName];\n    });\n    const sdkMessage = await this.sdk.sendGroupMessage(message, hmsRoles, type);\n    this.updateMessageInStore(sdkMessage, { message, recipientRoles: roles, type });\n  }\n\n  async sendDirectMessage(message: string, peerID: string, type?: string) {\n    const hmsPeer = this.hmsSDKPeers[peerID];\n    const sdkMessage = await this.sdk.sendDirectMessage(message, hmsPeer);\n    this.updateMessageInStore(sdkMessage, { message, recipientPeer: hmsPeer.peerId, type });\n  }\n\n  private updateMessageInStore(\n    sdkMessage: sdkTypes.HMSMessage | void,\n    messageInput: string | HMSMessageInput,\n  ) {\n    if (!sdkMessage) {\n      HMSLogger.w('sendMessage', 'Failed to send message', messageInput);\n      throw Error(`sendMessage Failed - ${JSON.stringify(messageInput)}`);\n    }\n    const hmsMessage = SDKToHMS.convertMessage(sdkMessage) as HMSMessage;\n    hmsMessage.read = true;\n    hmsMessage.senderName = 'You';\n    this.onHMSMessage(hmsMessage);\n    return hmsMessage;\n  }\n\n  setMessageRead(readStatus: boolean, messageId?: string) {\n    this.setState(store => {\n      if (messageId) {\n        if (!store.messages.byID[messageId]) {\n          this.logPossibleInconsistency('no message with id is found');\n        } else {\n          store.messages.byID[messageId].read = readStatus;\n        }\n      } else {\n        store.messages.allIDs.forEach((id: string) => {\n          store.messages.byID[id].read = readStatus;\n        });\n      }\n    }, 'setMessageRead');\n  }\n\n  async attachVideo(trackID: string, videoElement: HTMLVideoElement) {\n    if (this.localAndVideoUnmuting(trackID)) {\n      // wait till video unmute has finished\n      return new Promise<void>(resolve => {\n        const unsub = this.store.subscribe(async enabled => {\n          if (enabled) {\n            await this.attachVideoInternal(trackID, videoElement);\n            unsub();\n            resolve();\n          }\n        }, selectIsLocalVideoEnabled);\n      });\n    } else {\n      await this.attachVideoInternal(trackID, videoElement);\n    }\n  }\n\n  async detachVideo(trackID: string, videoElement: HTMLVideoElement) {\n    const sdkTrack = this.hmsSDKTracks[trackID];\n    if (sdkTrack && sdkTrack.type === 'video') {\n      await (sdkTrack as SDKHMSVideoTrack).removeSink(videoElement);\n      this.updateVideoLayer(trackID, 'detachVideo');\n    } else {\n      this.logPossibleInconsistency('no video track found to remove sink');\n    }\n  }\n\n  async addPluginToVideoTrack(plugin: HMSVideoPlugin, pluginFrameRate?: number): Promise<void> {\n    return this.addRemoveVideoPlugin(plugin, 'add', pluginFrameRate);\n  }\n  async addPluginToAudioTrack(plugin: HMSAudioPlugin): Promise<void> {\n    return this.addRemoveAudioPlugin(plugin, 'add');\n  }\n\n  async removePluginFromVideoTrack(plugin: HMSVideoPlugin): Promise<void> {\n    return this.addRemoveVideoPlugin(plugin, 'remove');\n  }\n  async removePluginFromAudioTrack(plugin: HMSAudioPlugin): Promise<void> {\n    return this.addRemoveAudioPlugin(plugin, 'remove');\n  }\n\n  async changeRole(forPeerId: string, toRole: string, force: boolean = false) {\n    const peer = this.hmsSDKPeers[forPeerId];\n    if (!peer) {\n      this.logPossibleInconsistency(`Unknown peer ID given ${forPeerId} for changerole`);\n      return;\n    }\n\n    await this.sdk.changeRole(peer, toRole, force);\n  }\n\n  // TODO: separate out role related things in another file\n  async acceptChangeRole(request: HMSRoleChangeRequest) {\n    let sdkPeer: sdkTypes.HMSPeer | undefined = request.requestedBy\n      ? this.hmsSDKPeers[request.requestedBy.id]\n      : undefined;\n    if (!sdkPeer) {\n      HMSLogger.w(\n        `peer for which role change is requested no longer available - ${request.requestedBy}`,\n      );\n    }\n    const sdkRequest = {\n      requestedBy: sdkPeer,\n      role: request.role,\n      token: request.token,\n    };\n    // TODO: hotfix for HMS-3639. Needs a better solution\n    //@ts-ignore\n    await this.sdk.acceptChangeRole(sdkRequest);\n    this.removeRoleChangeRequest(request);\n  }\n\n  /**\n   * @privateRemarks\n   * there is no corresponding sdk method for rejecting change role but as the store also maintains the full\n   * state of current pending requests, this method allows it to clean up when the request is rejected\n   */\n  rejectChangeRole(request: HMSRoleChangeRequest) {\n    this.removeRoleChangeRequest(request);\n  }\n\n  async endRoom(lock: boolean, reason: string) {\n    const permissions = this.store.getState(selectPermissions);\n    if (!permissions?.endRoom) {\n      HMSLogger.w('You are not allowed to perform this action - endRoom');\n      return;\n    }\n    await this.sdk.endRoom(lock, reason);\n  }\n\n  async removePeer(peerID: string, reason: string) {\n    const peer = this.hmsSDKPeers[peerID];\n    if (peer && !peer.isLocal) {\n      await this.sdk.removePeer(peer as sdkTypes.HMSRemotePeer, reason);\n    } else {\n      this.logPossibleInconsistency(`No remote peer found for peerID - ${peerID}`);\n      return;\n    }\n  }\n\n  async startRTMPOrRecording(params: sdkTypes.RTMPRecordingConfig) {\n    await this.sdk.startRTMPOrRecording(params);\n  }\n\n  async stopRTMPAndRecording() {\n    await this.sdk.stopRTMPAndRecording();\n  }\n\n  async setRemoteTrackEnabled(trackID: HMSTrackID | HMSTrackID[], enabled: boolean) {\n    if (typeof trackID === 'string') {\n      const track = this.hmsSDKTracks[trackID];\n      if (track && isRemoteTrack(track)) {\n        await this.sdk.changeTrackState(track as SDKHMSRemoteTrack, enabled);\n      } else {\n        this.logPossibleInconsistency(\n          `No remote track with ID ${trackID} found for change track state`,\n        );\n      }\n    } else if (Array.isArray(trackID)) {\n      trackID.forEach(id => this.setRemoteTrackEnabled(id, enabled));\n    }\n  }\n\n  async setRemoteTracksEnabled(params: HMSChangeMultiTrackStateParams) {\n    const sdkRequest: SDKHMSChangeMultiTrackStateParams = {\n      enabled: params.enabled,\n      type: params.type,\n      source: params.source,\n    };\n    if (params.roles) {\n      const rolesMap = this.store.getState(selectRolesMap);\n      sdkRequest.roles = params.roles.map(role => rolesMap[role]);\n    }\n    await this.sdk.changeMultiTrackState(sdkRequest);\n  }\n\n  setLogLevel(level: HMSLogLevel) {\n    HMSLogger.level = level;\n    this.sdk.setLogLevel(level);\n  }\n\n  private resetState(reason: string = 'resetState') {\n    this.setState(store => {\n      Object.assign(store, createDefaultStoreState());\n    }, reason);\n    this.isRoomJoinCalled = false;\n    this.hmsSDKTracks = {};\n    HMSLogger.cleanUp();\n  }\n\n  private sdkJoinWithListeners(config: sdkTypes.HMSConfig) {\n    this.sdk.join(config, {\n      onJoin: this.onJoin.bind(this),\n      onRoomUpdate: this.onRoomUpdate.bind(this),\n      onPeerUpdate: this.onPeerUpdate.bind(this),\n      onTrackUpdate: this.onTrackUpdate.bind(this),\n      onMessageReceived: this.onMessageReceived.bind(this),\n      onError: this.onError.bind(this),\n      onReconnected: this.onReconnected.bind(this),\n      onReconnecting: this.onReconnecting.bind(this),\n      onRoleChangeRequest: this.onRoleChangeRequest.bind(this),\n      onRoleUpdate: this.onRoleUpdate.bind(this),\n      onDeviceChange: this.onDeviceChange.bind(this),\n      onChangeTrackStateRequest: this.onChangeTrackStateRequest.bind(this),\n      onChangeMultiTrackStateRequest: this.onChangeMultiTrackStateRequest.bind(this),\n      onRemovedFromRoom: this.onRemovedFromRoom.bind(this),\n    });\n    this.sdk.addAudioListener({\n      onAudioLevelUpdate: this.onAudioLevelUpdate.bind(this),\n    });\n  }\n\n  private onRemovedFromRoom(request: SDKHMSLeaveRoomRequest) {\n    const requestedBy = this.store.getState(selectPeerByID(request.requestedBy.peerId));\n    if (!requestedBy) {\n      this.logPossibleInconsistency(\n        `Not found peer who requested leave room, ${request.requestedBy}`,\n      );\n      return;\n    }\n    this.hmsNotifications.sendLeaveRoom({\n      ...request,\n      requestedBy,\n    });\n    HMSLogger.i('resetting state after peer removed', request);\n    this.resetState(request.roomEnded ? 'roomEnded' : 'removedFromRoom');\n  }\n\n  private onDeviceChange(event: sdkTypes.HMSDeviceChangeEvent) {\n    const devices = event.devices;\n    if (!devices) {\n      return;\n    }\n    const localPeer = this.store.getState(selectLocalPeer);\n    this.setState(store => {\n      if (!areArraysEqual(store.devices.audioInput, devices.audioInput)) {\n        store.devices.audioInput = devices.audioInput;\n      }\n      if (!areArraysEqual(store.devices.videoInput, devices.videoInput)) {\n        store.devices.videoInput = devices.videoInput;\n      }\n      if (!areArraysEqual(store.devices.audioOutput, devices.audioOutput)) {\n        store.devices.audioOutput = devices.audioOutput;\n      }\n      if (this.hmsSDKPeers[localPeer?.id]) {\n        Object.assign(store.settings, this.getMediaSettings(this.hmsSDKPeers[localPeer?.id]));\n      }\n    }, 'deviceChange');\n    // sync is needed to update the current selected device\n    // this.syncRoomState('deviceChangeSync');\n    // send notification only on device change - selection is present\n    if (event.selection) {\n      const notification = SDKToHMS.convertDeviceChangeUpdate(event);\n      this.hmsNotifications.sendDeviceChange(notification);\n    }\n  }\n\n  private async sdkPreviewWithListeners(config: sdkTypes.HMSConfig) {\n    await this.sdk.preview(config, {\n      onPreview: this.onPreview.bind(this),\n      onError: this.onError.bind(this),\n      onDeviceChange: this.onDeviceChange.bind(this),\n    });\n    this.sdk.addAudioListener({\n      onAudioLevelUpdate: this.onAudioLevelUpdate.bind(this),\n    });\n  }\n\n  private async startScreenShare(audioOnly?: boolean) {\n    const isScreenShared = this.store.getState(selectIsLocalScreenShared);\n    if (!isScreenShared) {\n      await this.sdk.startScreenShare(() => this.syncRoomState('screenshareStopped'), audioOnly);\n      this.syncRoomState('startScreenShare');\n    } else {\n      this.logPossibleInconsistency(\"start screenshare is called while it's on\");\n    }\n  }\n\n  private async stopScreenShare() {\n    const isScreenShared = this.store.getState(selectIsLocalScreenShared);\n    if (isScreenShared) {\n      await this.sdk.stopScreenShare();\n      this.syncRoomState('stopScreenShare');\n    } else {\n      this.logPossibleInconsistency(\"stop screenshare is called while it's not on\");\n    }\n  }\n\n  private async attachVideoInternal(trackID: string, videoElement: HTMLVideoElement) {\n    const sdkTrack = this.hmsSDKTracks[trackID];\n    if (sdkTrack && sdkTrack.type === 'video') {\n      await (sdkTrack as SDKHMSVideoTrack).addSink(videoElement);\n      this.updateVideoLayer(trackID, 'attachVideo');\n    } else {\n      this.logPossibleInconsistency('no video track found to add sink');\n    }\n  }\n\n  /**\n   * This is a very important function as it's responsible for maintaining the source of\n   * truth with maximum efficiency. The efficiency comes from the fact that the only\n   * those portions of the store are updated which have actually changed.\n   * While making a change in this function don't use functions like map, reduce etc.\n   * which return a new copy of the data. Use Object.assign etc. to ensure that if the data\n   * doesn't change reference is also not changed.\n   * The UI and selectors rely on the fact that the store is immutable that is if there is\n   * any change and only if there is a change, they'll get a new copy of the data they're\n   * interested in with a new reference.\n   * @protected\n   */\n  protected syncRoomState(action?: string) {\n    HMSLogger.time(`store-sync-${action}`);\n    const newHmsPeers: Record<HMSPeerID, Partial<HMSPeer>> = {};\n    const newHmsPeerIDs: HMSPeerID[] = []; // to add in room.peers\n    const newHmsTracks: Record<HMSTrackID, Partial<HMSTrack>> = {};\n    const newHmsSDkTracks: Record<HMSTrackID, SDKHMSTrack> = {};\n    const newMediaSettings: Partial<HMSMediaSettings> = {};\n\n    const sdkPeers: sdkTypes.HMSPeer[] = this.sdk.getPeers();\n\n    // first convert everything in the new format\n    for (let sdkPeer of sdkPeers) {\n      const hmsPeer = SDKToHMS.convertPeer(sdkPeer);\n      newHmsPeers[hmsPeer.id] = hmsPeer;\n      newHmsPeerIDs.push(hmsPeer.id);\n      this.hmsSDKPeers[hmsPeer.id] = sdkPeer;\n\n      const sdkTracks = [sdkPeer.audioTrack, sdkPeer.videoTrack, ...sdkPeer.auxiliaryTracks];\n      for (let sdkTrack of sdkTracks) {\n        if (!sdkTrack) {\n          continue;\n        }\n        const hmsTrack = SDKToHMS.convertTrack(sdkTrack);\n        newHmsTracks[hmsTrack.id] = hmsTrack;\n        newHmsSDkTracks[sdkTrack.trackId] = sdkTrack;\n      }\n\n      if (hmsPeer.isLocal) {\n        Object.assign(newMediaSettings, this.getMediaSettings(sdkPeer));\n      }\n    }\n\n    const recording = this.sdk.getRecordingState();\n    const rtmp = this.sdk.getRTMPState();\n\n    // then merge them carefully with our store so if something hasn't changed\n    // the reference shouldn't change. Note that the draftStore is an immer draft\n    // object.\n    this.setState(draftStore => {\n      draftStore.room.peers = newHmsPeerIDs;\n      const draftPeers = draftStore.peers;\n      const draftTracks = draftStore.tracks;\n      // the order of below statements are important as merge functions are mutating\n      mergeNewPeersInDraft(draftPeers, newHmsPeers);\n      mergeNewTracksInDraft(draftTracks, newHmsTracks);\n      Object.assign(draftStore.settings, newMediaSettings);\n      this.hmsSDKTracks = newHmsSDkTracks;\n      Object.assign(draftStore.roles, SDKToHMS.convertRoles(this.sdk.getRoles()));\n      Object.assign(draftStore.playlist, SDKToHMS.convertPlaylist(this.sdk.getPlaylistManager()));\n      Object.assign(draftStore.room, SDKToHMS.convertRecordingRTMPState(recording, rtmp));\n    }, action);\n    HMSLogger.timeEnd(`store-sync-${action}`);\n  }\n\n  protected onPreview(sdkRoom: sdkTypes.HMSRoom) {\n    this.setState(store => {\n      Object.assign(store.room, SDKToHMS.convertRoom(sdkRoom));\n      store.room.roomState = HMSRoomState.Preview;\n    }, 'previewStart');\n    this.syncRoomState('previewSync');\n  }\n\n  protected onJoin(sdkRoom: sdkTypes.HMSRoom) {\n    this.audioPlaylist = new HMSPlaylist(\n      this.sdk.getPlaylistManager(),\n      HMSPlaylistType.audio,\n      this.syncPlaylistState.bind(this),\n      this.store,\n    );\n    this.videoPlaylist = new HMSPlaylist(\n      this.sdk.getPlaylistManager(),\n      HMSPlaylistType.video,\n      this.syncRoomState.bind(this),\n      this.store,\n    );\n    this.syncRoomState('joinSync');\n    this.setState(store => {\n      Object.assign(store.room, SDKToHMS.convertRoom(sdkRoom));\n      store.room.isConnected = true;\n      store.room.roomState = HMSRoomState.Connected;\n    }, 'joined');\n    this.sdk.getPlaylistManager().onProgress(this.setProgress);\n    this.sdk.getPlaylistManager().onNewTrackStart((item: sdkTypes.HMSPlaylistItem<any>) => {\n      this.syncPlaylistState(`${item.type}PlaylistUpdate`);\n    });\n    this.sdk.getPlaylistManager().onPlaylistEnded((type: HMSPlaylistType) => {\n      this.syncPlaylistState(`${type}PlaylistEnded`);\n    });\n  }\n\n  //@ts-ignore\n  protected onRoomUpdate(type: sdkTypes.HMSRoomUpdate, room: sdkTypes.HMSRoom) {\n    this.setState(store => {\n      Object.assign(store.room, SDKToHMS.convertRoom(room));\n    }, 'RoomUpdate');\n  }\n\n  protected onPeerUpdate(\n    type: sdkTypes.HMSPeerUpdate,\n    sdkPeer: sdkTypes.HMSPeer | sdkTypes.HMSPeer[],\n  ) {\n    if (\n      [\n        sdkTypes.HMSPeerUpdate.BECAME_DOMINANT_SPEAKER,\n        sdkTypes.HMSPeerUpdate.RESIGNED_DOMINANT_SPEAKER,\n      ].includes(type)\n    ) {\n      return; // ignore, high frequency update so no point of syncing peers\n    }\n    if (Array.isArray(sdkPeer)) {\n      this.syncRoomState('peersJoined');\n      const hmsPeers = [];\n      for (let peer of sdkPeer) {\n        const hmsPeer = this.store.getState(selectPeerByID(peer.peerId));\n        if (hmsPeer) {\n          hmsPeers.push(hmsPeer);\n        }\n      }\n      this.hmsNotifications.sendPeerList(hmsPeers);\n      return;\n    }\n    this.sendPeerUpdateNotification(type, sdkPeer);\n  }\n\n  protected onTrackUpdate(\n    type: sdkTypes.HMSTrackUpdate,\n    track: SDKHMSTrack,\n    peer: sdkTypes.HMSPeer,\n  ) {\n    // this check is needed because for track removed case, the notification needs to\n    // be send before the track is removed from store\n    if (type === sdkTypes.HMSTrackUpdate.TRACK_REMOVED) {\n      this.hmsNotifications.sendTrackUpdate(type, track.trackId);\n      this.handleTrackRemove(track, peer);\n    } else {\n      const actionName =\n        type === sdkTypes.HMSTrackUpdate.TRACK_ADDED ? 'trackAdded' : 'trackUpdate';\n      this.syncRoomState(actionName);\n      this.hmsNotifications.sendTrackUpdate(type, track.trackId);\n    }\n  }\n\n  protected onMessageReceived(sdkMessage: sdkTypes.HMSMessage) {\n    const hmsMessage = SDKToHMS.convertMessage(sdkMessage) as HMSMessage;\n    hmsMessage.read = false;\n    this.onHMSMessage(hmsMessage);\n    this.hmsNotifications.sendMessageReceived(hmsMessage);\n  }\n\n  protected onHMSMessage(hmsMessage: HMSMessage) {\n    this.setState(store => {\n      hmsMessage.id = String(this.store.getState(selectHMSMessagesCount) + 1);\n      store.messages.byID[hmsMessage.id] = hmsMessage;\n      store.messages.allIDs.push(hmsMessage.id);\n    }, 'newMessage');\n  }\n\n  /*\n   * Note: speakers array contain the value only for peers who have audioLevel != 0\n   */\n  protected onAudioLevelUpdate(sdkSpeakers: sdkTypes.HMSSpeaker[]) {\n    this.setState(store => {\n      const trackIDAudioLevelMap: Record<HMSPeerID, number> = {};\n      sdkSpeakers.forEach(sdkSpeaker => {\n        if (!sdkSpeaker.track || !sdkSpeaker.peer) {\n          return;\n        }\n        const trackID = sdkSpeaker.track.trackId;\n        trackIDAudioLevelMap[trackID] = sdkSpeaker.audioLevel;\n        if (!store.speakers[trackID]) {\n          // Set store instances(peers, tracks) references in speaker, not the new ones received.\n          store.speakers[trackID] = {\n            audioLevel: sdkSpeaker.audioLevel,\n            peerID: sdkSpeaker.peer.peerId,\n            trackID: trackID,\n          };\n        }\n      });\n      const speakerEntries = Object.entries(store.speakers);\n      for (let [trackID, speaker] of speakerEntries) {\n        speaker.audioLevel = trackIDAudioLevelMap[trackID] || 0;\n        if (speaker.audioLevel === 0) {\n          delete store.speakers[trackID];\n        }\n      }\n    }, 'audioLevel');\n  }\n\n  protected onChangeTrackStateRequest(request: SDKHMSChangeTrackStateRequest) {\n    const requestedBy = this.store.getState(selectPeerByID(request.requestedBy.peerId));\n    const storeTrackID = this.getStoreLocalTrackIDfromSDKTrack(request.track);\n    const track = this.store.getState(selectTrackByID(storeTrackID));\n\n    if (!requestedBy) {\n      return this.logPossibleInconsistency(\n        `Not found peer who requested track state change, ${request.requestedBy}`,\n      );\n    }\n    if (!track) {\n      return this.logPossibleInconsistency(\n        `Not found track for which track state change was requested, ${request.track}`,\n      );\n    }\n\n    if (!request.enabled) {\n      this.syncRoomState('changeTrackStateRequest');\n    }\n\n    this.hmsNotifications.sendChangeTrackStateRequest({\n      requestedBy,\n      track,\n      enabled: request.enabled,\n    });\n  }\n\n  protected onChangeMultiTrackStateRequest(request: SDKHMSChangeMultiTrackStateRequest) {\n    const requestedBy = this.store.getState(selectPeerByID(request.requestedBy.peerId));\n\n    if (!requestedBy) {\n      return this.logPossibleInconsistency(\n        `Not found peer who requested track state change, ${request.requestedBy}`,\n      );\n    }\n\n    if (!request.enabled) {\n      this.syncRoomState('changeMultiTrackStateRequest');\n    }\n\n    const tracks: HMSTrack[] = [];\n    const tracksMap = this.store.getState(selectTracksMap);\n    for (const track of request.tracks) {\n      const storeTrackID = this.getStoreLocalTrackIDfromSDKTrack(track);\n      if (storeTrackID && tracksMap[storeTrackID]) {\n        tracks.push(tracksMap[storeTrackID]);\n      }\n    }\n\n    this.hmsNotifications.sendChangeMultiTrackStateRequest({\n      requestedBy,\n      tracks,\n      enabled: request.enabled,\n      type: request.type,\n      source: request.source,\n    });\n  }\n\n  protected onReconnected() {\n    this.syncRoomState('reconnectedSync');\n    this.hmsNotifications.sendReconnected();\n    this.setState(store => {\n      store.room.roomState = HMSRoomState.Connected;\n    }, 'reconnected');\n  }\n\n  protected onReconnecting(sdkError: SDKHMSException) {\n    const error = SDKToHMS.convertException(sdkError);\n    HMSLogger.e('Reconnection: received error from sdk', error);\n    this.hmsNotifications.sendReconnecting(error);\n    this.setState(store => {\n      store.room.roomState = HMSRoomState.Reconnecting;\n      store.errors.push(error);\n    }, 'reconnecting');\n  }\n\n  protected onError(sdkException: SDKHMSException) {\n    const error = SDKToHMS.convertException(sdkException);\n    if (error.isTerminal) {\n      // terminal error leave room as it is not recoverable\n      this.leave().then(() => console.log('error from SDK, left room.'));\n      this.setState(store => {\n        store.room.roomState = HMSRoomState.Failed;\n        store.errors.push(error);\n      }, 'errorTerminal');\n    } else {\n      const numExistingErrors = this.store.getState().errors.length;\n      // just in case there is some infinite loop sending errors\n      if (numExistingErrors < 50) {\n        this.setState(store => {\n          store.errors.push(error);\n        }, 'error');\n      }\n    }\n    // send notification\n    this.hmsNotifications.sendError(error);\n    HMSLogger.e('received error from sdk', error);\n  }\n\n  /**\n   * the layer gets updated on addsink/removesink/preferlayer calls, for simulcast there\n   * can be multiple layers, while for non simulcast there will be None and High.\n   */\n  private updateVideoLayer(trackID: string, action: string) {\n    const sdkTrack = this.hmsSDKTracks[trackID];\n    if (sdkTrack && sdkTrack instanceof SDKHMSRemoteVideoTrack) {\n      this.setState(draft => {\n        draft.tracks[trackID].layer = sdkTrack.getSimulcastLayer();\n      }, action);\n    }\n  }\n\n  private handleTrackRemove(sdkTrack: SDKHMSTrack, sdkPeer: sdkTypes.HMSPeer) {\n    this.setState(draftStore => {\n      const hmsPeer = draftStore.peers[sdkPeer.peerId];\n      const draftTracks = draftStore.tracks;\n      const trackId = sdkTrack.trackId;\n      // find and remove the exact track from hmsPeer\n      if (this.isSameStoreSDKTrack(trackId, hmsPeer?.audioTrack)) {\n        delete hmsPeer?.audioTrack;\n      } else if (this.isSameStoreSDKTrack(trackId, hmsPeer?.videoTrack)) {\n        delete hmsPeer?.videoTrack;\n      } else {\n        const auxiliaryIndex = hmsPeer?.auxiliaryTracks.indexOf(trackId);\n        if (\n          auxiliaryIndex > -1 &&\n          this.isSameStoreSDKTrack(trackId, hmsPeer?.auxiliaryTracks[auxiliaryIndex])\n        ) {\n          hmsPeer?.auxiliaryTracks.splice(auxiliaryIndex, 1);\n        }\n      }\n      delete draftTracks[trackId];\n      delete this.hmsSDKTracks[trackId];\n    }, 'trackRemoved');\n  }\n\n  private async setEnabledSDKTrack(trackID: string, enabled: boolean) {\n    const track = this.hmsSDKTracks[trackID];\n    if (track) {\n      await track.setEnabled(enabled);\n    } else {\n      this.logPossibleInconsistency(`track ${trackID} not present, unable to enabled/disable`);\n    }\n  }\n\n  private async setSDKLocalVideoTrackSettings(\n    trackID: string,\n    settings: Partial<sdkTypes.HMSVideoTrackSettings>,\n  ) {\n    const track = this.hmsSDKTracks[trackID] as SDKHMSLocalVideoTrack;\n    if (track) {\n      await track.setSettings(settings);\n    } else {\n      this.logPossibleInconsistency(`local track ${trackID} not present, unable to set settings`);\n    }\n  }\n\n  private async setSDKLocalAudioTrackSettings(\n    trackID: string,\n    settings: Partial<sdkTypes.HMSAudioTrackSettings>,\n  ) {\n    const track = this.hmsSDKTracks[trackID] as SDKHMSLocalAudioTrack;\n    if (track) {\n      await track.setSettings(settings);\n    } else {\n      this.logPossibleInconsistency(`local track ${trackID} not present, unable to set settings`);\n    }\n  }\n\n  private getMediaSettings(sdkPeer: sdkTypes.HMSPeer): Partial<HMSMediaSettings> {\n    const settings = this.store.getState(selectLocalMediaSettings);\n    const audioTrack = sdkPeer.audioTrack as SDKHMSLocalAudioTrack;\n    const videoTrack = sdkPeer.videoTrack as SDKHMSLocalVideoTrack;\n    return {\n      audioInputDeviceId:\n        audioTrack && audioTrack.enabled\n          ? audioTrack.getMediaTrackSettings()?.deviceId\n          : settings.audioInputDeviceId,\n      videoInputDeviceId:\n        videoTrack && videoTrack.enabled\n          ? videoTrack.getMediaTrackSettings()?.deviceId\n          : settings.videoInputDeviceId,\n      audioOutputDeviceId: this.sdk.getAudioOutput().getDevice()?.deviceId,\n    };\n  }\n\n  private setTrackVolume(value: number, trackId: HMSTrackID) {\n    const track = this.hmsSDKTracks[trackId];\n    if (track) {\n      if (track instanceof SDKHMSAudioTrack) {\n        track.setVolume(value);\n        this.setState(draftStore => {\n          const track = draftStore.tracks[trackId];\n          if (track) {\n            track.volume = value;\n          }\n        }, 'trackVolume');\n      } else {\n        HMSLogger.w(`track ${trackId} is not an audio track`);\n      }\n    } else {\n      this.logPossibleInconsistency(`track ${trackId} not present, unable to set volume`);\n    }\n  }\n\n  /**\n   * Tells if the trackID is for local peer and video unmute is in process\n   * @private\n   */\n  private localAndVideoUnmuting(trackID: string) {\n    const localPeer = this.store.getState(selectLocalPeer);\n    if (localPeer.videoTrack !== trackID) {\n      return false;\n    }\n    const displayEnabled = this.store.getState(selectIsLocalVideoDisplayEnabled);\n    const actuallyEnabled = this.store.getState(selectIsLocalVideoEnabled);\n    return displayEnabled && !actuallyEnabled;\n  }\n\n  private logPossibleInconsistency(inconsistency: string) {\n    HMSLogger.w('possible inconsistency detected - ', inconsistency);\n  }\n\n  private async addRemoveVideoPlugin(\n    plugin: HMSVideoPlugin,\n    action: 'add' | 'remove',\n    pluginFrameRate?: number,\n  ) {\n    if (!plugin) {\n      HMSLogger.w('Invalid plugin received in store');\n      return;\n    }\n    const trackID = this.store.getState(selectLocalVideoTrackID);\n    if (trackID) {\n      const sdkTrack = this.hmsSDKTracks[trackID];\n      if (sdkTrack) {\n        if (action === 'add') {\n          await (sdkTrack as SDKHMSLocalVideoTrack).addPlugin(plugin, pluginFrameRate);\n        } else if (action === 'remove') {\n          await (sdkTrack as SDKHMSLocalVideoTrack).removePlugin(plugin);\n        }\n        this.syncRoomState(`${action}VideoPlugin`);\n      } else {\n        this.logPossibleInconsistency(`track ${trackID} not present, unable to remove plugin`);\n      }\n    }\n  }\n  private async addRemoveAudioPlugin(plugin: HMSAudioPlugin, action: 'add' | 'remove') {\n    if (!plugin) {\n      HMSLogger.w('Invalid plugin received in store');\n      return;\n    }\n    const trackID = this.store.getState(selectLocalAudioTrackID);\n    if (trackID) {\n      const sdkTrack = this.hmsSDKTracks[trackID];\n      if (sdkTrack) {\n        if (action === 'add') {\n          await (sdkTrack as SDKHMSLocalAudioTrack).addPlugin(plugin);\n        } else if (action === 'remove') {\n          await (sdkTrack as SDKHMSLocalAudioTrack).removePlugin(plugin);\n        }\n        this.syncRoomState(`${action}AudioPlugin`);\n      } else {\n        this.logPossibleInconsistency(`track ${trackID} not present, unable to remove plugin`);\n      }\n    }\n  }\n\n  /**\n   * In case of replace track id is changed but not in store. Given the store id, check the real id\n   * sdk is using to refer to the track and match them.\n   */\n  private isSameStoreSDKTrack(sdkTrackID: string, storeTrackID?: string): boolean {\n    if (!storeTrackID) {\n      return false;\n    }\n    return this.hmsSDKTracks[storeTrackID]?.trackId === sdkTrackID;\n  }\n\n  /**\n   * convert new role change requests to store format and save.\n   * keep only one request at a time in store till we figure out how to handle multiple requests at the same time\n   */\n  private onRoleChangeRequest(request: SDKHMSRoleChangeRequest) {\n    this.setState(store => {\n      if (store.roleChangeRequests.length === 0) {\n        store.roleChangeRequests.push(SDKToHMS.convertRoleChangeRequest(request));\n      }\n    }, 'roleChangeRequest');\n  }\n\n  private removeRoleChangeRequest(toRemove: HMSRoleChangeRequest) {\n    this.setState(store => {\n      const index = store.roleChangeRequests.findIndex(req => {\n        return req.token === toRemove.token;\n      });\n      if (index !== -1) {\n        store.roleChangeRequests.splice(index, 1);\n      }\n    }, 'removeRoleChangeRequest');\n  }\n\n  private onRoleUpdate() {\n    this.syncRoomState('roleUpdate');\n  }\n\n  private getStoreLocalTrackIDfromSDKTrack(sdkTrack: SDKHMSLocalTrack) {\n    const trackIDs = this.store.getState(selectLocalTrackIDs);\n    return trackIDs.find(trackID => this.hmsSDKTracks[trackID].trackId === sdkTrack.trackId);\n  }\n\n  private setProgress = ({ type, progress }: sdkTypes.HMSPlaylistProgressEvent) => {\n    this.setState(draftStore => {\n      draftStore.playlist[type].progress = progress;\n      draftStore.playlist[type].currentTime = this.sdk.getPlaylistManager().getCurrentTime(type);\n    }, 'playlistProgress');\n  };\n\n  private syncPlaylistState = (action: string) => {\n    this.setState(draftStore => {\n      Object.assign(draftStore.playlist, SDKToHMS.convertPlaylist(this.sdk.getPlaylistManager()));\n    }, action);\n  };\n\n  private sendPeerUpdateNotification = (\n    type: sdkTypes.HMSPeerUpdate,\n    sdkPeer: sdkTypes.HMSPeer,\n  ) => {\n    let peer = this.store.getState(selectPeerByID(sdkPeer.peerId));\n    let actionName = 'peerUpdate';\n    if (type === sdkTypes.HMSPeerUpdate.PEER_JOINED) {\n      actionName = 'peerJoined';\n    } else if (type === sdkTypes.HMSPeerUpdate.PEER_LEFT) {\n      actionName = 'peerLeft';\n    }\n    this.syncRoomState(actionName);\n    // if peer wasn't available before sync(will happen if event is peer join)\n    if (!peer) {\n      peer = this.store.getState(selectPeerByID(sdkPeer.peerId));\n    }\n    this.hmsNotifications.sendPeerUpdate(type, peer);\n  };\n\n  /**\n   * setState is separate so any future changes to how state change can be done from one place.\n   * @param fn\n   * @param name\n   */\n  private setState: NamedSetState<HMSStore> = (fn, name) => {\n    return this.store.namedSetState(fn, name);\n  };\n}\n","import * as sdkTypes from '../sdkTypes';\nimport { HMSNotificationTypes } from '../../schema';\n\ninterface notifcationMap {\n  [key: number]: string;\n}\n\nexport const PEER_NOTIFICATION_TYPES: notifcationMap = {\n  [sdkTypes.HMSPeerUpdate.PEER_JOINED]: HMSNotificationTypes.PEER_JOINED,\n  [sdkTypes.HMSPeerUpdate.PEER_LEFT]: HMSNotificationTypes.PEER_LEFT,\n  [sdkTypes.HMSPeerUpdate.ROLE_UPDATED]: HMSNotificationTypes.ROLE_UPDATED,\n  [sdkTypes.HMSPeerUpdate.AUDIO_TOGGLED]: 'PEER_AUDIO_UPDATED',\n  [sdkTypes.HMSPeerUpdate.VIDEO_TOGGLED]: 'PEER_VIDEO_UPDATED',\n};\n\nexport const TRACK_NOTIFICATION_TYPES: notifcationMap = {\n  [sdkTypes.HMSTrackUpdate.TRACK_ADDED]: HMSNotificationTypes.TRACK_ADDED,\n  [sdkTypes.HMSTrackUpdate.TRACK_REMOVED]: HMSNotificationTypes.TRACK_REMOVED,\n  [sdkTypes.HMSTrackUpdate.TRACK_MUTED]: HMSNotificationTypes.TRACK_MUTED,\n  [sdkTypes.HMSTrackUpdate.TRACK_UNMUTED]: HMSNotificationTypes.TRACK_UNMUTED,\n};\n","import EventEmitter from 'events';\nimport { IHMSNotifications } from '../IHMSNotifications';\nimport { IHMSStore } from '../IHMSStore';\nimport { selectPeerByID, selectTrackByID } from '../selectors';\nimport * as sdkTypes from './sdkTypes';\nimport { PEER_NOTIFICATION_TYPES, TRACK_NOTIFICATION_TYPES } from './common/mapping';\nimport {\n  HMSNotification,\n  HMSNotificationTypes,\n  HMSNotificationSeverity,\n  HMSPeer,\n  HMSException,\n  HMSMessage,\n  HMSTrack,\n  HMSTrackID,\n  HMSChangeTrackStateRequest,\n  HMSChangeMultiTrackStateRequest,\n  HMSLeaveRoomRequest,\n  HMSDeviceChangeEvent,\n} from '../schema';\n\nconst HMS_NOTIFICATION_EVENT = 'hmsNotification';\nexport class HMSNotifications implements IHMSNotifications {\n  private id: number = 0;\n  private eventEmitter: EventEmitter;\n  private store: IHMSStore;\n\n  constructor(store: IHMSStore) {\n    this.store = store;\n    this.eventEmitter = new EventEmitter();\n  }\n\n  onNotification = (cb: (notification: HMSNotification) => void): (() => void) => {\n    this.eventEmitter.addListener(HMS_NOTIFICATION_EVENT, cb);\n    return () => {\n      this.eventEmitter.removeListener(HMS_NOTIFICATION_EVENT, cb);\n    };\n  };\n\n  sendDeviceChange(request: HMSDeviceChangeEvent) {\n    const notification = this.createNotification(\n      HMSNotificationTypes.DEVICE_CHANGE_UPDATE,\n      request,\n      request.error ? HMSNotificationSeverity.ERROR : HMSNotificationSeverity.INFO,\n      `Selected ${request.type} device - ${request.selection?.label}`,\n    );\n    this.emitEvent(notification);\n  }\n\n  sendLeaveRoom(request: HMSLeaveRoomRequest) {\n    const notification = this.createNotification(\n      request.roomEnded ? HMSNotificationTypes.ROOM_ENDED : HMSNotificationTypes.REMOVED_FROM_ROOM,\n      request,\n      HMSNotificationSeverity.INFO,\n      `${request.roomEnded ? `Room ended` : 'Removed from room'} by ${request.requestedBy.name}`,\n    );\n    this.emitEvent(notification);\n  }\n\n  sendPeerList(peers: HMSPeer[]) {\n    const notification = this.createNotification(\n      HMSNotificationTypes.PEER_LIST,\n      peers,\n      HMSNotificationSeverity.INFO,\n    );\n    this.emitEvent(notification);\n  }\n\n  sendPeerUpdate(type: sdkTypes.HMSPeerUpdate, peer: HMSPeer | null) {\n    const hmsPeer = this.store.getState(selectPeerByID(peer?.id)) || peer;\n    const notificationType = PEER_NOTIFICATION_TYPES[type];\n    if (notificationType) {\n      const notification = this.createNotification(\n        notificationType,\n        hmsPeer,\n        HMSNotificationSeverity.INFO,\n      );\n      this.emitEvent(notification);\n    }\n  }\n\n  sendTrackUpdate(type: sdkTypes.HMSTrackUpdate, trackID: HMSTrackID) {\n    const hmsTrack = this.store.getState(selectTrackByID(trackID));\n    const notificationType = TRACK_NOTIFICATION_TYPES[type];\n    if (notificationType) {\n      const notification = this.createNotification(\n        notificationType,\n        hmsTrack,\n        HMSNotificationSeverity.INFO,\n      );\n      this.emitEvent(notification);\n    }\n  }\n\n  sendMessageReceived(message: HMSMessage) {\n    const notification = this.createNotification(\n      HMSNotificationTypes.NEW_MESSAGE,\n      message,\n      HMSNotificationSeverity.INFO,\n    );\n    this.emitEvent(notification);\n  }\n\n  sendError(error: HMSException) {\n    const notification = this.createNotification(\n      HMSNotificationTypes.ERROR,\n      error,\n      HMSNotificationSeverity.ERROR,\n    );\n    this.emitEvent(notification);\n  }\n\n  sendReconnecting(error: HMSException) {\n    const notification = this.createNotification(\n      HMSNotificationTypes.RECONNECTING,\n      error,\n      HMSNotificationSeverity.ERROR,\n    );\n    this.emitEvent(notification);\n  }\n\n  sendReconnected() {\n    const notification = this.createNotification(\n      HMSNotificationTypes.RECONNECTED,\n      null,\n      HMSNotificationSeverity.INFO,\n    );\n    this.emitEvent(notification);\n  }\n\n  sendChangeTrackStateRequest(request: HMSChangeTrackStateRequest) {\n    const notification = this.createNotification(\n      HMSNotificationTypes.CHANGE_TRACK_STATE_REQUEST,\n      request,\n      HMSNotificationSeverity.INFO,\n    );\n    this.emitEvent(notification);\n  }\n\n  sendChangeMultiTrackStateRequest(request: HMSChangeMultiTrackStateRequest) {\n    const notification = this.createNotification(\n      HMSNotificationTypes.CHANGE_MULTI_TRACK_STATE_REQUEST,\n      request,\n      HMSNotificationSeverity.INFO,\n    );\n    this.emitEvent(notification);\n  }\n\n  private emitEvent(notification: HMSNotification) {\n    this.eventEmitter.emit(HMS_NOTIFICATION_EVENT, notification);\n  }\n\n  private createNotification(\n    type: string,\n    data?:\n      | HMSPeer\n      | HMSPeer[]\n      | HMSTrack\n      | HMSMessage\n      | HMSException\n      | HMSChangeTrackStateRequest\n      | HMSChangeMultiTrackStateRequest\n      | HMSLeaveRoomRequest\n      | HMSDeviceChangeEvent\n      | null,\n    severity?: HMSNotificationSeverity,\n    message: string = '',\n  ): HMSNotification {\n    this.id++;\n    return {\n      id: this.id,\n      type,\n      message,\n      data,\n      severity,\n    };\n  }\n}\n","import produce from 'immer';\nimport create, {\n  StateSelector,\n  StoreApi,\n  SetState,\n  StateSliceListener,\n  EqualityChecker,\n  PartialState,\n  State,\n} from 'zustand/vanilla';\nimport shallow from 'zustand/shallow';\nimport { HMSSdk } from '@100mslive/hms-video';\nimport { IHMSActions } from '../IHMSActions';\nimport { HMSSDKActions } from './HMSSDKActions';\nimport { IHMSStore, IHMSStoreReadOnly } from '../IHMSStore';\nimport { createDefaultStoreState, HMSStore } from '../schema';\nimport { HMSNotifications } from './HMSNotifications';\nimport { IHMSNotifications } from '../IHMSNotifications';\nimport { NamedSetState } from './internalTypes';\n\nexport class HMSReactiveStore {\n  private readonly actions: IHMSActions;\n  private readonly store: IHMSStore;\n  private readonly notifications: HMSNotifications;\n  private initialTriggerOnSubscribe: boolean;\n\n  constructor(hmsStore?: IHMSStore, hmsActions?: IHMSActions, hmsNotifications?: HMSNotifications) {\n    if (hmsStore) {\n      this.store = hmsStore;\n    } else {\n      this.store = HMSReactiveStore.createNewHMSStore();\n    }\n    if (hmsNotifications) {\n      this.notifications = hmsNotifications;\n    } else {\n      this.notifications = new HMSNotifications(this.store);\n    }\n    if (hmsActions) {\n      this.actions = hmsActions;\n    } else {\n      this.actions = new HMSSDKActions(this.store, new HMSSdk(), this.notifications);\n    }\n    this.initialTriggerOnSubscribe = false;\n  }\n\n  /**\n   * By default store.subscribe does not call the handler with the current state at time of subscription,\n   * this behaviour can be modified by calling this function. What it means is that instead of calling the\n   * handler only for changes which happen post subscription we'll also call it exactly once at the time\n   * of subscription with the current state. This behaviour is similar to that of BehaviourSubject in rxjs.\n   * This will be an irreversible change\n   *\n   * Note: you don't need this if you're using our react hooks, it takes care of this requirement.\n   */\n  triggerOnSubscribe(): void {\n    if (this.initialTriggerOnSubscribe) {\n      // already done\n      return;\n    }\n    HMSReactiveStore.makeStoreTriggerOnSubscribe(this.store);\n    this.initialTriggerOnSubscribe = true;\n  }\n\n  /**\n   * A reactive store which has a subscribe method you can use in combination with selectors\n   * to subscribe to a subset of the store. The store serves as a single source of truth for\n   * all data related to the corresponding HMS Room.\n   */\n  getStore(): IHMSStoreReadOnly {\n    return this.store;\n  }\n\n  /**\n   * Any action which may modify the store or may need to talk to the SDK will happen\n   * through the IHMSActions instance returned by this\n   */\n  getHMSActions(): IHMSActions {\n    return this.actions;\n  }\n\n  /**\n   * This return notification handler function to which you can pass your callback to\n   * receive notifications like peer joined, peer left, etc. to show in your UI or use\n   * for analytics\n   */\n  getNotifications(): IHMSNotifications {\n    return { onNotification: this.notifications.onNotification };\n  }\n\n  /**\n   * @internal\n   */\n  static createNewHMSStore(): IHMSStore {\n    const hmsStore = create<HMSStore>(() => createDefaultStoreState());\n    // make set state immutable, by passing functions through immer\n    const savedSetState = hmsStore.setState;\n    hmsStore.setState = (partial: any) => {\n      const nextState = typeof partial === 'function' ? produce(partial) : partial;\n      savedSetState(nextState);\n    };\n    // add option to pass selector to getState\n    const prevGetState = hmsStore.getState;\n    // eslint-disable-next-line complexity\n    hmsStore.getState = <StateSlice>(selector?: StateSelector<HMSStore, StateSlice>) => {\n      if (selector) {\n        const name = selector.name || 'byIDSelector';\n        // @ts-ignore\n        if (!window.selectorsCount) {\n          // @ts-ignore\n          window.selectorsCount = {};\n        }\n        // @ts-ignore\n        window.selectorsCount[name] = (window.selectorsCount[name] || 0) + 1;\n        const start = performance.now();\n        const updatedState = selector(prevGetState());\n        const diff = performance.now() - start;\n        // store selectors that take more than 1ms\n        if (diff > 1) {\n          // @ts-ignore\n          window.expensiveSelectors = window.expensiveSelectors || new Map();\n          // @ts-ignore\n          window.expensiveSelectors.set(name, diff);\n        }\n        return updatedState;\n      }\n      return prevGetState();\n    };\n    HMSReactiveStore.useShallowCheckInSubscribe(hmsStore);\n    const namedSetState = HMSReactiveStore.setUpDevtools(hmsStore, 'HMSStore');\n    return { ...hmsStore, namedSetState };\n  }\n\n  /**\n   * @internal\n   */\n  static makeStoreTriggerOnSubscribe(store: IHMSStore) {\n    const prevSubscribe = store.subscribe;\n    store.subscribe = <StateSlice>(\n      listener: StateSliceListener<StateSlice>,\n      selector?: StateSelector<HMSStore, StateSlice>,\n      equalityFn?: EqualityChecker<StateSlice>,\n    ): (() => void) => {\n      // initial call, the prev state will always be null for this\n      listener(store.getState(selector), (undefined as unknown) as StateSlice);\n      // then subscribe\n      return prevSubscribe(listener, selector!, equalityFn);\n    };\n  }\n\n  /**\n   * use shallow equality check by default for subscribe to optimize for array/object selectors.\n   * by default zustand does only reference matching so something like, getPeers for eg. would trigger\n   * the corresponding component even if peers didn't actually change, as selectPeers creates a new array everytime.\n   * Although the array reference changes, the order of peers and peer objects don't themselves change in this case,\n   * and a shallow check avoids that triggering.\n   * @private\n   */\n  private static useShallowCheckInSubscribe(hmsStore: StoreApi<HMSStore>) {\n    const prevSubscribe = hmsStore.subscribe;\n    hmsStore.subscribe = <StateSlice>(\n      listener: StateSliceListener<StateSlice>,\n      selector?: StateSelector<HMSStore, StateSlice>,\n      equalityFn?: EqualityChecker<StateSlice>,\n    ): (() => void) => {\n      if (!selector) {\n        selector = (store): StateSlice => (store as unknown) as StateSlice;\n      }\n      equalityFn = equalityFn || shallow;\n      return prevSubscribe(listener, selector, equalityFn);\n    };\n  }\n\n  /**\n   * @private\n   * @privateRemarks\n   * sets up redux devtools for the store, so redux extension can be used to visualize the store.\n   * zustand's default devtool middleware only enhances the set function, we're here creating another nameSetState in\n   * IHMStore which behaves like setState but takes an extra parameter for action name\n   * https://github.com/zalmoxisus/redux-devtools-extension/blob/master/docs/API/Methods.md\n   * modified version of zustand's devtools - https://github.com/pmndrs/zustand/blob/v3.5.7/src/middleware.ts#L46\n   */\n  private static setUpDevtools<T extends State>(\n    api: StoreApi<T>,\n    prefix: string,\n  ): NamedSetState<HMSStore> {\n    let extension;\n    try {\n      extension =\n        (window as any).__REDUX_DEVTOOLS_EXTENSION__ ||\n        (window as any).top.__REDUX_DEVTOOLS_EXTENSION__;\n    } catch {}\n    if (!extension) {\n      return (fn: any) => {\n        api.setState(fn);\n      };\n    }\n    const devtools = extension.connect(HMSReactiveStore.devtoolsOptions(prefix));\n    devtools.prefix = prefix ? `${prefix} > ` : '';\n    const savedSetState = api.setState;\n    api.setState = (fn: any) => {\n      savedSetState(fn);\n      devtools.send(`${devtools.prefix}setState`, api.getState());\n    };\n\n    devtools.subscribe(HMSReactiveStore.devtoolsSubscribe(devtools, api, savedSetState));\n\n    devtools.send('setUpStore', api.getState());\n\n    return (fn: any, action?: string) => {\n      savedSetState(fn);\n      const actionName = action ? action : `${devtools.prefix}action`;\n      devtools.send(actionName, api.getState());\n    };\n  }\n\n  /**\n   * https://github.com/zalmoxisus/redux-devtools-extension/blob/master/docs/API/Arguments.md\n   */\n  private static devtoolsOptions(prefix: string) {\n    return {\n      name: prefix,\n      actionsBlacklist: ['audioLevel', 'playlistProgress'], // very high frequency update, pollutes the action history\n    };\n  }\n\n  /**\n   * redux devtools allows for time travel debugging where it sends an action to update the store, users can\n   * also export and import state in the devtools, listen to the corresponding functions from devtools and take\n   * required action.\n   * @param devtools - reference to devtools extension object\n   * @param api\n   * @param savedSetState - setState saved before its modified to update devtools\n   * @private\n   */\n  private static devtoolsSubscribe<T extends State>(\n    devtools: any,\n    api: StoreApi<T>,\n    savedSetState: SetState<T>,\n  ) {\n    // disabling complexity check instead of refactoring so as to keep the code close to zustand's and make\n    // any future update based on upstream changes easier.\n    // eslint-disable-next-line complexity\n    return (message: any) => {\n      if (message.type === 'DISPATCH' && message.state) {\n        const ignoreState = ['JUMP_TO_ACTION', 'JUMP_TO_STATE'].includes(message.payload.type);\n        if (!ignoreState) {\n          // manual dispatch from the extension\n          api.setState(JSON.parse(message.state));\n        } else {\n          // for time travel, no need to add new state changes in devtools\n          savedSetState(JSON.parse(message.state));\n        }\n      } else if (message.type === 'DISPATCH' && message.payload?.type === 'COMMIT') {\n        devtools.init(api.getState());\n      } else if (message.type === 'DISPATCH' && message.payload?.type === 'IMPORT_STATE') {\n        const actions = message.payload.nextLiftedState?.actionsById;\n        const computedStates = message.payload.nextLiftedState?.computedStates || [];\n\n        computedStates.forEach(({ state }: { state: PartialState<T> }, index: number) => {\n          const action = actions[index] || `${devtools.prefix}setState`;\n          if (index === 0) {\n            devtools.init(state);\n          } else {\n            savedSetState(state);\n            devtools.send(action, api.getState());\n          }\n        });\n      }\n    };\n  }\n}\n"],"names":["HMSRoomState","runtime","exports","Op","Object","prototype","hasOwn","hasOwnProperty","$Symbol","Symbol","iteratorSymbol","iterator","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","toStringTag","define","obj","key","value","defineProperty","enumerable","configurable","writable","err","wrap","innerFn","outerFn","self","tryLocsList","generator","create","Generator","context","Context","_invoke","state","method","arg","Error","undefined","done","delegate","delegateResult","maybeInvokeDelegate","ContinueSentinel","sent","_sent","dispatchException","abrupt","record","tryCatch","type","makeInvokeMethod","fn","call","GeneratorFunction","GeneratorFunctionPrototype","IteratorPrototype","this","getProto","getPrototypeOf","NativeIteratorPrototype","values","Gp","defineIteratorMethods","forEach","AsyncIterator","PromiseImpl","previousPromise","callInvokeWithMethodAndArg","resolve","reject","invoke","result","__await","then","unwrapped","error","TypeError","info","resultName","next","nextLoc","pushTryEntry","locs","entry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","push","resetTryEntry","completion","reset","iterable","iteratorMethod","isNaN","length","i","doneResult","displayName","isGeneratorFunction","genFun","ctor","constructor","name","mark","setPrototypeOf","__proto__","awrap","async","Promise","iter","keys","object","reverse","pop","skipTempReset","prev","charAt","slice","stop","rootRecord","rval","exception","handle","loc","caught","hasCatch","hasFinally","finallyEntry","complete","finish","catch","thrown","delegateYield","module","regeneratorRuntime","accidentalStrictMode","globalThis","Function","HMSNotificationSeverity","HMSNotificationTypes","HMSPlaylistType","createDefaultStoreState","room","id","isConnected","peers","shareableLink","localPeer","hasWaitingRoom","roomState","Disconnected","recording","browser","running","server","rtmp","tracks","playlist","audio","list","selection","hasPrevious","hasNext","progress","volume","currentTime","video","messages","byID","allIDs","speakers","settings","audioInputDeviceId","audioOutputDeviceId","videoInputDeviceId","devices","audioInput","audioOutput","videoInput","roles","roleChangeRequests","errors","HMSMessageType","mergeTrackArrayFields","oldTrack","newTrack","plugins","areArraysEqual","layerDefinitions","isEntityUpdated","oldItem","newItem","isEntityRemoved","isEntityAdded","arr1","arr2","union","set","Set","add","Array","from","SDKToHMS","convertPeer","sdkPeer","peerId","roleName","role","_sdkPeer$role","isLocal","videoTrack","_sdkPeer$videoTrack","trackId","audioTrack","_sdkPeer$audioTrack","auxiliaryTracks","map","track","customerUserId","customerDescription","convertTrack","sdkTrack","source","enabled","displayEnabled","enrichTrack","mediaSettings","getMediaTrackSettings","displaySurface","height","width","deviceID","deviceId","SDKHMSRemoteAudioTrack","getVolume","enrichVideoTrack","enrichPluginsDetails","SDKHMSRemoteVideoTrack","layer","getSimulcastLayer","degraded","getSimulcastDefinitions","SDKHMSLocalVideoTrack","SDKHMSLocalAudioTrack","getPlugins","convertRoom","sdkRoom","_sdkRoom$localPeer","_sdkRoom$recording","_sdkRoom$recording2","_sdkRoom$rtmp","convertMessage","sdkMessage","sender","senderName","senderRole","_sdkMessage$sender$ro","senderUserId","recipientPeer","_sdkMessage$recipient","recipientRoles","_sdkMessage$recipient2","time","message","convertRoles","sdkRoles","convertRoleChangeRequest","req","requestedBy","token","convertException","sdkException","code","action","description","isTerminal","nativeError","timestamp","Date","convertDeviceChangeUpdate","sdkDeviceChangeEvent","convertedData","convertPlaylist","playlistManager","getConvertedPlaylistType","convertedPlaylist","currentSelection","getCurrentSelection","getCurrentProgress","isPlaying","getList","currentIndex","getCurrentIndex","playlistItem","isSelected","url","selected","playing","getCurrentTime","convertRecordingRTMPState","_recording$browser","_recording$server","getPeerTracksByCondition","peer","trackCheckFn","isScreenShare","isAudio","isVideo","isVideoPlaylist","isDegraded","Boolean","isTrackEnabled","store","trackID","selectRoom","selectPeersMap","selectMessagesMap","selectMessageIDsInOrder","selectTracksMap","selectLocalMediaSettings","selectSpeakers","selectIsConnectedToRoom","createSelector","selectPeerCount","selectPeers","storePeers","peerID","selectTracks","storeTracks","selectLocalPeer","selectLocalPeerID","selectLocalAudioTrackID","selectLocalVideoTrackID","selectLocalTrackIDs","audioTrackID","videoTrackID","auxiliaryTrackIDs","trackIDs","unshift","selectRemotePeers","filter","p","selectDominantSpeaker","peersMap","speakersInOrder","entries","sort","s1","s2","s1Level","audioLevel","selectIsLocalVideoEnabled","selectIsLocalVideoDisplayEnabled","isTrackDisplayEnabled","selectIsLocalScreenShared","tracksMap","selectPeerScreenSharing","screensharePeer","selectIsSomeoneScreenSharing","selectPeerSharingAudio","selectPeersScreenSharing","videoPeers","audioPeers","concat","selectPeerSharingVideoPlaylist","selectDegradedTracks","selectHMSMessagesCount","messageIDs","selectUnreadHMSMessagesCount","m","read","selectHMSMessages","msgIDs","msgMap","msgId","selectRoomState","selectIsInPreview","Preview","selectRoomStarted","selectRolesMap","selectAvailableRoleNames","rolesMap","selectLocalPeerRole","selectIsAllowedToSubscribe","subscribeParams","_role$subscribeParams","subscribeToRoles","selectPermissions","permissions","selectRecordingState","selectRTMPState","selectPlaylistMap","selectPlaylistSelection","selectPlaylistProgress","selectPlaylistCurrentTime","selectPlaylistVolume","selectPlaylist","storePlaylist","selectPlaylistSelectedItem","selectAudioPlaylist","selectedItem","selectVideoPlaylist","HMS_STORE_TAG","HMSLogger","v","tag","data","log","HMSLogLevel","VERBOSE","d","DEBUG","INFO","w","WARN","e","ERROR","TIME","timeEnd","TIMEEND","cleanUp","performance","clearMarks","clearMeasures","level","valueOf","console","debug","warn","measure","duration","byIDCurry","selector","selectPeerID","_store","selectRoleName","selectPeerByIDBare","selectTrackByIDBare","selectPeerByID","selectPeerNameByID","selectTrackByID","selectVideoTrackByPeerID","selectAudioTrackByPeerID","selectCameraStreamByPeerID","selectAuxiliaryTracksByPeerID","selectSpeakerByTrackID","selectTrackAudioByID","speaker","selectPeerAudioByID","peerAudioTrack","selectAuxiliaryAudioByPeerID","find","selectVideoPlaylistVideoTrackByPeerID","selectVideoPlaylistAudioTrackByPeerID","selectAudioPlaylistTrackByPeerID","isAudioPlaylist","selectScreenSharesByPeerId","selectScreenShareAudioByPeerID","screenshare","selectIsPeerAudioEnabled","selectIsPeerVideoEnabled","selectIsAudioLocallyMuted","selectIsLocallyMutedByPeerID","selectIsScreenShareLocallyMutedByPeerID","selectAudioTrackVolume","selectAudioVolumeByPeerID","selectScreenshareAudioVolumeByPeerID","selectSimulcastLayerByTrack","selectMessagesByPeerIDInternal","localPeerID","_message$recipientRol","includes","selectMessagesByRoleInternal","_message$recipientRol2","_message$recipientRol3","selectBroadcastMessages","_message$recipientRol4","selectUnreadMessageCountByRole","selectUnreadMessageCountByPeerID","selectBroadcastMessagesUnreadCount","selectMessagesByPeerID","selectMessagesByRole","selectMessagesUnreadCountByRole","selectMessagesUnreadCountByPeerID","selectPeersWithAudioStatus","isAudioEnabled","_tracksMap$peer$audio","selectRoleChangeRequest","request","selectIsAllowedToPublish","screen","publishParams","_role$publishParams","allowed","selectLocalVideoPlugins","selectLocalAudioPlugins","isRemoteTrack","HMSRemoteAudioTrack","HMSRemoteVideoTrack","HMSPlaylist","syncPlaylistState","play","setEnabled","pause","getState","playNext","playPrevious","seek","seekValue","seekTo","setVolume","setList","HMSSDKActions","sdk","notificationManager","_this","setState","draftStore","getPlaylistManager","assign","actionName","sdkTypes","PEER_JOINED","PEER_LEFT","syncRoomState","hmsNotifications","sendPeerUpdate","namedSetState","unblockAudio","getAudioOutput","unblockAutoplay","setTrackVolume","setAudioOutputDevice","setDevice","setPreferredLayer","hmsSDKTracks","preferLayer","updateVideoLayer","logPossibleInconsistency","preview","config","isRoomJoinCalled","Connecting","sdkPreviewWithListeners","join","sdkJoinWithListeners","leave","_this2","resetState","setScreenShareEnabled","audioOnly","startScreenShare","stopScreenShare","addTrack","removeTrack","setLocalAudioEnabled","setEnabledTrack","setLocalVideoEnabled","_this3","setEnabledSDKTrack","sendError","sendTrackUpdate","TRACK_UNMUTED","TRACK_MUTED","setAudioSettings","setSDKLocalAudioTrackSettings","setVideoSettings","setSDKLocalVideoTrackSettings","sendMessage","sendBroadcastMessage","updateMessageInStore","sendGroupMessage","storeRoles","hmsRoles","sendDirectMessage","hmsPeer","hmsSDKPeers","messageInput","JSON","stringify","hmsMessage","onHMSMessage","setMessageRead","readStatus","messageId","_this4","attachVideo","videoElement","localAndVideoUnmuting","unsub","_this5","subscribe","attachVideoInternal","detachVideo","removeSink","addPluginToVideoTrack","plugin","pluginFrameRate","addRemoveVideoPlugin","addPluginToAudioTrack","addRemoveAudioPlugin","removePluginFromVideoTrack","removePluginFromAudioTrack","changeRole","forPeerId","toRole","force","acceptChangeRole","sdkRequest","removeRoleChangeRequest","rejectChangeRole","endRoom","lock","reason","removePeer","startRTMPOrRecording","params","stopRTMPAndRecording","setRemoteTrackEnabled","changeTrackState","isArray","_this6","setRemoteTracksEnabled","changeMultiTrackState","setLogLevel","onJoin","bind","onRoomUpdate","onPeerUpdate","onTrackUpdate","onMessageReceived","onError","onReconnected","onReconnecting","onRoleChangeRequest","onRoleUpdate","onDeviceChange","onChangeTrackStateRequest","onChangeMultiTrackStateRequest","onRemovedFromRoom","addAudioListener","onAudioLevelUpdate","sendLeaveRoom","roomEnded","event","_this7","getMediaSettings","notification","sendDeviceChange","onPreview","_this8","addSink","newHmsPeers","newHmsPeerIDs","newHmsTracks","newHmsSDkTracks","newMediaSettings","getPeers","hmsTrack","getRecordingState","getRTMPState","draftTracks","draftPeers","newPeers","oldPeer","newPeer","mergeNewPeersInDraft","newTracks","mergeNewTracksInDraft","_this9","getRoles","audioPlaylist","videoPlaylist","Connected","onProgress","setProgress","onNewTrackStart","item","_this10","onPlaylistEnded","BECAME_DOMINANT_SPEAKER","RESIGNED_DOMINANT_SPEAKER","hmsPeers","sendPeerList","sendPeerUpdateNotification","TRACK_REMOVED","handleTrackRemove","TRACK_ADDED","sendMessageReceived","String","_this11","sdkSpeakers","trackIDAudioLevelMap","sdkSpeaker","storeTrackID","getStoreLocalTrackIDfromSDKTrack","sendChangeTrackStateRequest","sendChangeMultiTrackStateRequest","sendReconnected","sdkError","sendReconnecting","Reconnecting","Failed","draft","_this12","isSameStoreSDKTrack","auxiliaryIndex","indexOf","splice","setSettings","_audioTrack$getMediaT","_videoTrack$getMediaT","getDevice","_this$sdk$getAudioOut","SDKHMSAudioTrack","actuallyEnabled","inconsistency","addPlugin","removePlugin","sdkTrackID","toRemove","index","findIndex","_this13","PEER_NOTIFICATION_TYPES","ROLE_UPDATED","AUDIO_TOGGLED","VIDEO_TOGGLED","TRACK_NOTIFICATION_TYPES","HMSNotifications","cb","eventEmitter","addListener","removeListener","EventEmitter","createNotification","DEVICE_CHANGE_UPDATE","_request$selection","label","emitEvent","ROOM_ENDED","REMOVED_FROM_ROOM","PEER_LIST","notificationType","NEW_MESSAGE","RECONNECTING","RECONNECTED","CHANGE_TRACK_STATE_REQUEST","CHANGE_MULTI_TRACK_STATE_REQUEST","emit","severity","HMSReactiveStore","hmsStore","hmsActions","createNewHMSStore","notifications","actions","HMSSdk","initialTriggerOnSubscribe","triggerOnSubscribe","makeStoreTriggerOnSubscribe","getStore","getHMSActions","getNotifications","onNotification","savedSetState","partial","nextState","produce","prevGetState","window","selectorsCount","start","now","updatedState","diff","expensiveSelectors","Map","useShallowCheckInSubscribe","setUpDevtools","prevSubscribe","listener","equalityFn","shallow","api","prefix","extension","__REDUX_DEVTOOLS_EXTENSION__","top","devtools","connect","devtoolsOptions","send","devtoolsSubscribe","actionsBlacklist","payload","parse","init","nextLiftedState","_message$payload$next","actionsById","computedStates","pluginName"],"mappings":"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"}